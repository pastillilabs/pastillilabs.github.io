{"version":3,"sources":["qmlweb.min.js","qmlweb.js","QMLBoolean.js","QMLInteger.js","QMLList.js","QMLNumber.js","QMLString.js","QMLUrl.js","QMLVariant.js","CustomElements.js","getset.js","import.js","jsparser.js","modules.js","properties.js","qmlstructure.js","QmlWeb.js","QObject.js","JSItemModel.js","QColor.js","QFont.js","QMatrix4x4.js","QPointF.js","QQuaternion.js","QRectF.js","QSizeF.js","QVector2D.js","QVector3D.js","QVector4D.js","Signal.js","Qt.js","QMLBinding.js","QMLEngine.js","QMLOperationState.js","QMLProperty.js","AutoLoader.js","easing.js","helpers.js","keyboard.js","qrc.js","QmlWeb.Dom/DomElement.js","QmlWeb/RestModel.js","Qt.labs.settings/Settings.js","QtBluetooth/BluetoothDiscoveryModel.js","QtGraphicalEffects/FastBlur.js","QtGraphicalEffects/RectangularGlow.js","QtMobility/GeoLocation.js","QtMultimedia/Audio.js","QtMultimedia/Camera.js","QtMultimedia/MediaPlayer.js","QtMultimedia/Video.js","QtMultimedia/VideoOutput.js","QtNfc/NearField.js","QtQml.Models/ListElement.js","QtQml.Models/ListModel.js","QtQml/Binding.js","QtQml/Component.js","QtQml/Connections.js","QtQml/QtObject.js","QtQml/Timer.js","QtQuick.Controls.2/ApplicationWindow.js","QtQuick.Controls/ApplicationWindow.js","QtQuick.Controls/Button.js","QtQuick.Controls/CheckBox.js","QtQuick.Controls/ComboBox.js","QtQuick.Controls/ScrollView.js","QtQuick.Controls/TextArea.js","QtQuick.Controls/TextField.js","QtQuick.Particles/AngleDirection.js","QtQuick.Particles/CustomParticle.js","QtQuick.Particles/Direction.js","QtQuick.Particles/Emitter.js","QtQuick.Particles/ParticlePainter.js","QtQuick.Particles/ParticleSystem.js","QtQuick.Window/Screen.js","QtQuick.Window/Window.js","QtQuick/AnimatedImage.js","QtQuick/Animation.js","QtQuick/Animator.js","QtQuick/Behavior.js","QtQuick/BorderImage.js","QtQuick/Canvas.js","QtQuick/Column.js","QtQuick/DoubleValidator.js","QtQuick/Flow.js","QtQuick/FocusScope.js","QtQuick/FontLoader.js","QtQuick/Grid.js","QtQuick/Image.js","QtQuick/IntValidator.js","QtQuick/Item.js","QtQuick/ListElement.js","QtQuick/ListModel.js","QtQuick/ListView.js","QtQuick/Loader.js","QtQuick/MouseArea.js","QtQuick/NumberAnimation.js","QtQuick/OpacityAnimator.js","QtQuick/ParallelAnimation.js","QtQuick/PauseAnimation.js","QtQuick/Positioner.js","QtQuick/PropertyAnimation.js","QtQuick/PropertyChanges.js","QtQuick/Rectangle.js","QtQuick/RegExpValidator.js","QtQuick/Repeater.js","QtQuick/Rotation.js","QtQuick/RotationAnimator.js","QtQuick/Row.js","QtQuick/Scale.js","QtQuick/ScaleAnimator.js","QtQuick/SequentialAnimation.js","QtQuick/ShaderEffect.js","QtQuick/ShaderEffectSource.js","QtQuick/State.js","QtQuick/SystemPalette.js","QtQuick/Text.js","QtQuick/TextEdit.js","QtQuick/TextInput.js","QtQuick/Transition.js","QtQuick/Translate.js","QtQuick/UniformAnimator.js","QtQuick/XAnimator.js","QtQuick/YAnimator.js","QtTest/TestCase.js","QtWebEngine/WebEngineView.js","QtWebSockets/WebSocket.js","QtWebView/WebView.js"],"names":["global","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","QMLBoolean","val","QMLInteger","QMLList","meta","list","object","push","QmlWeb","construct","parent","context","QMLMetaElement","QMLNumber","QMLString","QMLUrl","engine","$resolvePath","QMLVariant","getProperties","file","div","document","createElement","QMLEngine","loadFile","qml","rootObject","properties","keys","$properties","filter","name","match","anchorNames","indexOf","ignoreProps","type","stop","registerElement","readyState","addEventListener","window","customElements","Error","attributes","map","pname","toLowerCase","attr2prop","reduce","QmlElement","_HTMLElement","this","getPrototypeOf","apply","arguments","_createClass","key","_this17","computedStyle","getComputedStyle","display","style","start","forEach","attr","getAttribute","applyAttribute","defineProperty","get","set","changed","connect","width","height","oldValue","newValue","prop","deleteAttribute","setAttribute","removeAttribute","HTMLElement","define","setupGetter","obj","propName","func","setupSetter","setupGetterSetter","getter","setter","getUrlContents","url","skipExceptions","urlContentCache","xhr","XMLHttpRequest","open","send","e","status","console","log","responseText","readQmlDir","makeurl","path","qmldirFileUrl","parsedUrl","$parseURI","qmldir","scheme","qrc","undefined","internals","externals","lines","split","line","replace","version","importJavascriptInContext","contextSetter","$context","oldExecutionContext","executionContext","registerGlobalQmlType","constructors","modules","Main","registerQmlType","options","baseClass","baseModule","baseName","dot","lastIndexOf","module","substring","found","descr","baseId","join","dependants","hasOwnProperty","descriptor","element","versions","enums","signals","defaultProperty","$qmlTypeInfo","moduleDescriptor","inherit","id","opt","getAttachedObject","QMLBaseObject","getConstructor","moduleName","test","getModuleConstructors","warn","loadImports","imports","mergeObjects","helpers","row","_imports$i","_slicedToArray","moduleVersion","moduleAlias","versionString","toFixed","toString","moduleConstructors","importContextId","importContextIds","perImportContextConstructors","oldProto","getOwnPropertyNames","callSuper","info","createProperties","params","Signal","signal","$defaultProperty","item","classComponents","$class","ci","c","_constructor","qdirInfo","qmldirs","filePath","qualified","qualifiedImportPath","component","Qt","createComponent","$createObject","dom","className","$basePath","applyProperties","createProperty","QMLProperty","initialValue","ReasonInit","readOnly","newVal","$canEditReadOnlyProperties","ReasonUser","$isComponentRoot","skip","noContextOverride","getOwnPropertyDescriptor","desc","metaObject","objectScopeIn","componentScope","objectScope","$children","signalName","slice","connectSignal","$setCustomSlot","applyProperty","$setCustomData","QMLSignalDefinition","parameters","QMLMethod","compile","eval","QMLAliasDefinition","componentScopeBasePath","objectName","propertyName","reason","_objectScope","_componentScope","con","error","targetProp","loopWatchdog","_len24","args","_key24","_len25","_key25","pendingOperations","QMLPropertyDefinition","QMLMetaPropertyGroup","compiled","j","src","isFunction","slot","convertToEngine","tree","walk","stringifyDots","elem","sub","applyProp","curr","loadParser","parse","tags","getElementsByTagName","Function","jsparse","parseQML","nowParsingFile","parsetree","QmlDocument","sliceIterator","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","_get","property","receiver","_typeof","defineProperties","target","props","protoProps","staticProps","objectIds","QObject","$parent","$tidyupList","$signals","objectId","$Component","destruction","$delete","disconnect","index","splice","_len","_key","JSItemModel","roleNames","dataChanged","rowsInserted","rowsMoved","rowsRemoved","modelReset","names","QColor","$changed","$r","$g","$b","$a","a","r","g","b","lval","colormap","rgb","hex","substr","parseInt","_rgb","x","shift","$string","argb","Math","round","$cssValue","intr","intg","intb","execute","v","hsvValue","m","min","h","$hsv","hsvSaturation","s","hsvHue","max","$hsl","hslSaturation","hslLightness","abs","hslHue","l","$hcma","hh","floor","y","baseColor","factor","color","hsva","lhs","rhs","rgba","bind","concat","hsla","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","nonNullableType","requireConstructor","QFont","_QmlWeb$QObject","_this","Font","bold","capitalization","MixedCase","family","italic","letterSpacing","pixelSize","pointSize","strikeout","underline","weight","Normal","wordSpacing","$sizeLock","boldChanged","$onBoldChanged","capitalizationChanged","$onCapitalizationChanged","familyChanged","$onFamilyChanged","italicChanged","$onItalicChanged","letterSpacingChanged","$onLetterSpacingChanged","pixelSizeChanged","$onPixelSizeChanged","pointSizeChanged","$onPointSizeChanged","strikeoutChanged","$onStrikeoutChanged","underlineChanged","$onUnderlineChanged","weightChanged","$onWidthChanged","wordSpacingChanged","$onWordSpacingChanged","Bold","firstChild","fontVariant","SmallCaps","textTransform","$capitalizationToTextTransform","fontFamily","fontStyle","fontSize","textDecoration","font","fontWeight","$weightToCss","Thin","ExtraLight","Light","Medium","DemiBold","ExtraBold","Black","AllUppercase","AllLowercase","Capitalize","requireParent","QMatrix4x4","_QmlWeb$QObject2","_this2","_len2","_key2","data","col","_row","_col","_row2","_col2","_name","m11","m12","m13","m14","m21","m22","m23","m24","m31","m32","m33","m34","m41","m42","m43","m44","t","QVector4D","_t","z","w","QVector3D","times","other","_this3","_this4","s0","c5","s1","c4","s2","c3","s3","c2","s4","c1","s5","c0","det","adj","epsilon","QPointF","_QmlWeb$QObject3","_this5","_len3","_key3","parseFloat","trim","QQuaternion","_QmlWeb$QObject4","_this6","_len4","_key4","scalar","QRectF","_QmlWeb$QObject5","_this7","_len5","_key5","mask","QSizeF","_QmlWeb$QObject6","_this8","_len6","_key6","QVector2D","_QmlWeb$QObject7","_this9","_len7","_key7","sqrt","dotProduct","every","delta","_QmlWeb$QObject8","_this10","_len8","_key8","_QmlWeb$QObject9","_this11","_len9","_key9","_t2","_this12","connectedSlots","isConnected","pushEvalStack","_len10","_key10","QueuedConnection","$addQueued","$execute","popEvalStack","AutoConnection","_len11","_key11","pop","UniqueConnection","thisObj","String","$connectNotify","_len12","_key12","callType","_connectedSlots$i","$disconnectNotify","_len13","_key13","_connectedSlots$i2","_len14","_key14","message","$queued","setImmediate","$executeQueued","setTimeout","queued","DirectConnection","openUrlExternally","page","focus","loadComponent","nameIsUrl","moreDirs","importSearchPaths","QMLComponent","extractBasePath","$imports","$file","createQmlObject","resolvedFile","resolvedUrl","createObject","QMLOperationState","operationState","Init","Idle","$initializePropertyBindings","callCompletedSignals","qmlUrl","point","_len15","_key15","rect","_len16","_key16","size","_len17","_key17","vector2d","_len18","_key18","vector3d","_len19","_key19","vector4d","_len20","_key20","quaternion","_len21","_key21","matrix4x4","_len22","_key22","_QmlWeb$QColor","_QmlWeb$QColor2","_QmlWeb$QColor3","colorEqual","_QmlWeb$QColor4","equal","darker","_QmlWeb$QColor5","lighter","_QmlWeb$QColor6","include","uri","$qmlJsIncludes","js","loadJS","platform","os","LeftButton","RightButton","MiddleButton","NoModifier","ShiftModifier","ControlModifier","AltModifier","MetaModifier","KeypadModifier","LeftToRight","RightToLeft","Vertical","Horizontal","Key_Escape","Key_Tab","Key_Backtab","Key_Backspace","Key_Return","Key_Enter","Key_Insert","Key_Delete","Key_Pause","Key_Print","Key_SysReq","Key_Clear","Key_Home","Key_End","Key_Left","Key_Up","Key_Right","Key_Down","Key_PageUp","Key_PageDown","Key_Shift","Key_Control","Key_Meta","Key_Alt","Key_AltGr","Key_CapsLock","Key_NumLock","Key_ScrollLock","Key_F1","Key_F2","Key_F3","Key_F4","Key_F5","Key_F6","Key_F7","Key_F8","Key_F9","Key_F10","Key_F11","Key_F12","Key_F13","Key_F14","Key_F15","Key_F16","Key_F17","Key_F18","Key_F19","Key_F20","Key_F21","Key_F22","Key_F23","Key_F24","Key_F25","Key_F26","Key_F27","Key_F28","Key_F29","Key_F30","Key_F31","Key_F32","Key_F33","Key_F34","Key_F35","Key_Super_L","Key_Super_R","Key_Menu","Key_Hyper_L","Key_Hyper_R","Key_Help","Key_Direction_L","Key_Direction_R","Key_Space","Key_Any","Key_Exclam","Key_QuoteDbl","Key_NumberSign","Key_Dollar","Key_Percent","Key_Ampersant","Key_Apostrophe","Key_ParenLeft","Key_ParenRight","Key_Asterisk","Key_Plus","Key_Comma","Key_Minus","Key_Period","Key_Slash","Key_0","Key_1","Key_2","Key_3","Key_4","Key_5","Key_6","Key_7","Key_8","Key_9","Key_Colon","Key_Semicolon","Key_Less","Key_Equal","Key_Greater","Key_Question","Key_At","Key_A","Key_B","Key_C","Key_D","Key_E","Key_F","Key_G","Key_H","Key_I","Key_J","Key_K","Key_L","Key_M","Key_N","Key_O","Key_P","Key_Q","Key_R","Key_S","Key_T","Key_U","Key_V","Key_W","Key_X","Key_Y","Key_Z","Key_BracketLeft","Key_Backslash","Key_BracketRight","Key_AsciiCircum","Key_Underscore","Key_QuoteLeft","Key_BraceLeft","Key_Bar","Key_BraceRight","Key_AsciiTilde","Key_Back","Key_Forward","Key_Stop","Key_VolumeDown","Key_VolumeUp","Key_VolumeMute","Key_multiply","Key_add","Key_substract","Key_divide","Key_News","Key_OfficeHome","Key_Option","Key_Paste","Key_Phone","Key_Calendar","Key_Reply","Key_Reload","Key_RotateWindows","Key_RotationPB","Key_RotationKB","Key_Save","Key_Send","Key_Spell","Key_SplitScreen","Key_Support","Key_TaskPane","Key_Terminal","Key_Tools","Key_Travel","Key_Video","Key_Word","Key_Xfer","Key_ZoomIn","Key_ZoomOut","Key_Away","Key_Messenger","Key_WebCam","Key_MailForward","Key_Pictures","Key_Music","Key_Battery","Key_Bluetooth","Key_WLAN","Key_UWB","Key_AudioForward","Key_AudioRepeat","Key_AudioRandomPlay","Key_Subtitle","Key_AudioCycleTrack","Key_Time","Key_Hibernate","Key_View","Key_TopMenu","Key_PowerDown","Key_Suspend","Key_ContrastAdjust","Key_MediaLast","Key_unknown","Key_Call","Key_Camera","Key_CameraFocus","Key_Context1","Key_Context2","Key_Context3","Key_Context4","Key_Flip","Key_Hangup","Key_No","Key_Select","Key_Yes","Key_ToggleCallHangup","Key_VoiceDial","Key_LastNumberRedial","Key_Execute","Key_Printer","Key_Play","Key_Sleep","Key_Zoom","Key_Cancel","AlignLeft","AlignRight","AlignHCenter","AlignJustify","AlignTop","AlignBottom","AlignVCenter","AlignCenter","AlignBaseline","AlignAbsolute","AlignLeading","AlignTrailing","AlignHorizontal_Mask","AlignVertical_Mask","PrimaryOrientation","PortraitOrientation","LandscapeOrientation","InvertedPortraitOrientation","InvertedLandscapeOrientation","ArrowCursor","UpArrowCursor","CrossCursor","WaitCursor","IBeamCursor","SizeVerCursor","SizeHorCursor","SizeBDiagCursor","SizeFDiagCursor","SizeAllCursor","BlankCursor","SplitVCursor","SplitHCursor","PointingHandCursor","ForbiddenCursor","WhatsThisCursor","BusyCursor","OpenHandCursor","ClosedHandCursor","DragCopyCursor","DragMoveCursor","DragLinkCursor","LastCursor","BitmapCursor","CustomCursor","ScrollBarAsNeeded","ScrollBarAlwaysOff","ScrollBarAlwaysOn","QMLBinding","deps","JSON","stringify","basePath","impl","bindSrc","plainType","qmlBoolean","useShadowDom","geometryProperties","_this13","fps","$interval","body","domTarget","attachShadow","mode","components","completedSignals","bindedProperties","userAddedModulePaths","userAddedImportPaths","_tickers","_lastTick","Date","now","_whenStop","_whenStart","$initKeyboard","overflow","position","getPropertyValue","top","left","updateGeometry","innerWidth","innerHeight","Running","_tickerId","setInterval","_tick","callback","clearInterval","leadingSlash","segments","out","pos","segment","parentComponent","$basePathA","href","fileName","extractFileName","loadQMLTree","appendChild","dirpath","qualifier","componentImportPaths","paths","unqualified","arrayOfDirs","dirPath","dependantProperties","evaluatingProperty","update","importsArray","currentFileDir","qmldirsContents","loadImport","entry","nameIsQualifiedModuleName","nameIsJs","nameIsDir","content","probableDirs","importPathList","diredName","k","addComponentImportPath","attrname","getWidth","getHeight","rootContext","activeFocus","_this14","onkeypress","focusedElement","event","eventToKeyboard","eventName","keyboardSignals","accepted","backup","Keys","pressed","preventDefault","onkeyup","released","elapsed","ticker","jsData","source","exports","sym","f","binding","needsUpdate","$updateHGeometry","$updateVGeometry","$initializeAliasSignals","authority","schemes","basePathURI","removeDotSegments","fileURL","op","handler","qmlInteger","qmlList","qmlNumber","animation","_this15","_QMLComponent","oldVal","pushEvaluatingProperty","$setVal","popEvaluatingProperty","$actions","to","restart","ReasonAnimation","typeInitialValues","running","$syncPropertyToRemote","evaluatingPropertyStackOfStacks","evaluatingPropertyStack","evaluatingPropertyPaused","int","real","double","string","bool","enum","qmlString","qmlVariant","metaTags","metaTag","qmlEngine","Easing","Linear","InQuad","OutQuad","InOutQuad","OutInQuad","InCubic","OutCubic","InOutCubic","OutInCubic","InQuart","OutQuart","InOutQuart","OutInQuart","InQuint","OutQuint","InOutQuint","OutInQuint","InSine","OutSine","InOutSine","OutInSine","InExpo","OutExpo","InOutExpo","OutInExpo","InCirc","OutCirc","InOutCirc","OutInCirc","InElastic","OutElastic","InOutElastic","OutInElastic","InBack","OutBack","InOutBack","OutInBack","InBounce","OutBounce","InOutBounce","OutInBounce","$ease","period","amplitude","overshoot","pow","cos","PI","sin","asin","QmlWebHelpers","array","findIndex","merged","_len23","_key23","arg","keyCodeToQt","keypad","keyCode","shiftKey","count","isAutoRepeat","modifiers","ctrlKey","CtrlModifier","altKey","metaKey","text","fromCharCode","charCode","qtName","toUpperCase","prefix","variant","var","_QmlWeb$QMLBinding","objName","onProp","$on","walkers","toplevel","statement","qmlelem","statements","qmlprop","bindout","qmlobjdef","qmlobj","qmlmethod","qmlpropdef","qmlaliasdef","qmlsignaldef","qmldefaultprop","num","isList","hasBinding","walker","amIn","str","tagName","_class","isLoading","mimeType","queryMimeType","fetched","saved","_class2","getAttributes","runningRequests","_this19","$ajax","method","mimetype","success","$xhrReadResponse","_this20","destroy","$sendToServer","_this21","$generateBodyForPostQuery","$objectToUrlEncoded","parts","ekey","$myEncodeURIComponent","evalue","encodeURIComponent","charCodeAt","_this22","overrideMimeType","onreadystatechange","DONE","failure","setRequestHeader","responseObject","$updatePropertiesFromResponseObject","$hasProperty","category","_class3","localStorage","Component","completed","Component$onCompleted","$loadProperties","$initializeProperties","attrName","_this23","$attributes","$getKey","getItem","_this24","emitter","setItem","BluetoothDiscoveryModel","FullServiceDiscovery","MinimalServiceDiscovery","DeviceDiscovery","NoError","InputOutputError","PoweredOffError","InvalidBluetoothAdapterError","UnknownError","discoveryMode","remoteAddress","uuidFilter","deviceDiscovered","serviceDiscovered","_class4","radius","_class5","$previousSource","$filterObject","radiusChanged","$onRadiusChanged","sourceChanged","$onSourceChanged","$updateEffect","transformType","operation","transform","$updateTransform","$updateFilterObject","cached","cornerRadius","glowRadius","spread","_class6","pointerEvents","right","bottom","border","backgroundColor","$css","colorChanged","$onColorChanged","glowRadiusChanged","$updateBoxShadow","cornerRadiusChanged","widthChanged","heightChanged","spreadChanged","$onSpreadChanged","totle","glow","blur_radius","spread_radius","glow2","blur_radius_2","spread_radius_2","boxShadow","spread_cornerR","rest_cornerR","xScale","yScale","borderRadius","accuracy","altitude","altitudeAccuracy","heading","latitude","longitude","speed","timestamp","label","_class7","_this25","navigator","geolocation","getCurrentPosition","$updatePosition","watchPosition","coords","Audio","Available","Busy","Unavailable","ResourceMissing","ResourceError","FormatError","NetworkError","AccessDenied","ServiceMissing","StoppedState","PlayingState","PausedState","NoMedia","Loading","Loaded","Buffering","Stalled","EndOfMedia","InvalidMedia","UnknownStatus","audioRole","autoLoad","autoPlay","availability","duration","errorString","hasAudio","hasVideo","loops","mediaObject","muted","playbackRate","playbackState","playlinst","seekable","volume","paused","playing","stopped","_class8","Camera","UnloadedState","LoadedState","ActiveState","cameraState","cameraStatus","captureMode","deviceId","digitalZoom","displayName","errorCode","lockStatus","maximumDigitalZoom","maximumOpticalZoom","opticalZoom","orientation","_class9","MediaPlayer","bufferProgress","_class10","VideoOutput","PreserveAspectFit","PreserveAspectCrop","Stretch","fillMode","_class11","_this26","$runningEventListener","margin","currentTime","buffered","progress","end","Buffered","autoPlayChanged","$onAutoPlayChanged","positionChanged","$onPositionChanged","volumeChanged","$onVolumeChanged","playbackRateChanged","$onPlaybackRateChanged","mutedChanged","$onMutedChanged","fillModeChanged","$onFillModeChanged","autoplay","extension","mime","mimetypeFromExtension","canPlayType","$volulmeBackup","$volumeBackup","objectFit","pause","play","offset","mimetypes","ogg","ogv","ogm","mp4","webm","autoOrientation","contentRect","filters","sourceRect","_class12","messageRecords","orderMatch","polling","tagFound","tagRemoved","_class13","_class14","_class15","when","_class16","$property","valueChanged","$onValueChanged","targetChanged","$updateBinding","propertyChanged","whenChanged","QMLContext","_this27","$metaObject","$jsImports","moduleImports","importDesc","oldState","bp","newContext","isComponentRoot","finalizeImports","propname","QMLItem","ignoreUnknownSignals","_class17","$connections","$old_target","$onTargetChanged","$reconnectTarget","old_target","_currentConnection","_QmlWeb$QObject10","_class18","_this28","asteriskPresed","backPressed","backtabPressed","callPressed","cancelPressed","deletePressed","escapePressed","flipPressed","hangupPressed","leftPressed","menuPressed","noPressed","returnPressed","rightPressed","selectPressed","spacePressed","tabPressed","upPressed","volumeDownPressed","volumeUpPressed","yesPressed","interval","repeat","triggeredOnStart","triggered","_class19","_this29","runningChanged","$onRunningChanged","$addTicker","$ticker","$registerStart","$registerStop","$prevTrigger","$trigger","activeFocusControl","background","contentData","footer","header","overlay","_class20","menuBar","statusBar","toolBar","_class21","enabled","clicked","_class22","_this30","textChanged","$onTextChanged","enabledChanged","$onEnabledChanged","button","onclick","implicitWidth","offsetWidth","implicitHeight","offsetHeight","textContent","disabled","checked","_class23","_this31","checkbox","verticalAlign","span","checkedChanged","$onCheckedChanged","children","innerHTML","currentIndex","currentText","menu","model","activated","_class24","_this32","modelChanged","$onModelChanged","currentIndexChanged","$onCurrentIndexChanged","$onHeightChanged","selectedIndex","Option","$updateCurrentText","$updateImpl","contentItem","flickableItem","viewport","frameVisible","highlightOnFocus","verticalScrollBarPolicy","horizontalScrollBarPolicy","_class25","css","setupFocusOnDom","contentItemChanged","$onContentItemChanged","flickableItemChanged","$onFlickableItemChanged","viewportChanged","$onViewportChanged","frameVisibleChanged","$onFrameVisibleChanged","highlightOnFocusChanged","$onHighlightOnFocusChanged","horizontalScrollBarPolicyChanged","$onHorizontalScrollBarPolicyChanged","verticalScrollBarPolicyChanged","$onVerticalScrollBarPolicyChanged","styleChanged","$onStyleChanged","childrenChanged","$onChildrenChanged","focusChanged","$onFocusChanged","newItem","outline","highlight","visible","newPolicy","overflowX","$scrollBarPolicyToCssOverflow","overflowY","policy","_class26","textarea","padding","borderWidth","TextInput","Password","NoEcho","PasswordEchoOnEdit","maximumLength","validator","echoMode","_class27","_this33","input","echoModeChanged","$onEchoModeChanged","maximumLengthChanged","$onMaximumLengthChanged","readOnlyChanged","$onReadOnlyChanged","Keys$onPressed","$updateValue","maxLength","submit","$testValidator","validate","angle","angleVariation","magnitude","magnitudeVariation","_class28","fragmentShader","vertexShader","_class29","_class30","acceleration","emitRate","endSize","group","lifeSpan","lifeSpanVariation","maximumEmitted","shape","sizeVariation","startTime","system","velocity","velocityFromMovement","emitParticles","_class31","_this34","groups","_class32","empty","particleStates","_class33","Screen","$Screen","screen","orientationUpdateMask","primaryOrientation","pixelDensity","devicePixelRatio","desktopAvailableHeight","desktopAvailableWidth","appName","$populateScreen","_Qt","outerHeight","outerWidth","active","activeFocusItem","contentOrientation","flags","maximumHeight","maximumWidth","minimumHeight","minimumWidth","modality","title","visibility","closing","_class34","_class35","Animation","Infinite","alwaysRunToEnd","_class36","_class37","easing","bezierCurve","_class38","animationChanged","$onAnimationChanged","BorderImage","Repeat","Round","Null","Ready","smooth","horizontalTileMode","verticalTileMode","_class39","_this35","bg","boxSizing","$img","Image","leftChanged","$updateBorder","rightChanged","topChanged","bottomChanged","horizontalTileModeChanged","verticalTileModeChanged","smoothChanged","$onSmoothChanged","imageURL","$resolveImageURL","OBorderImageSource","borderImageSource","complete","_border","OBorderImageSlice","OBorderImageRepeat","OBorderImageWidth","borderImageSlice","borderImageRepeat","borderImageWidth","imageRendering","available","canvasSize","canvasWindow","contextType","renderStrategy","renderTarget","tileSize","imageLoaded","paint","painted","_class40","image","isImageLoaded","area","_class41","curPos","maxWidth","child","spacing","DoubleValidator","StandardNotation","ScientificNotation","Infinity","decimals","notation","_class42","$standardRegExp","$scientificRegExp","number","exec","regExp","getRegExpForNotation","$getDecimalsForNumber","Flow","TopToBottom","flow","layoutDirection","_class43","flowChanged","layoutChildren","layoutDirectionChanged","curHPos","curVPos","rowSize","$isUsingImplicitWidth","$isUsingImplicitHeight","_class44","FontLoader","_class45","$lastName","$inTouchName","$timeouts","nameChanged","$onNameChanged","fontName","fontFace","_this36","promise","loaded","fonts","load","then","fontLoader","fontsLoaded","notLoadedFontFamilies","fontLoaded","testDiv","loadFonts","$cycleTouchName","_this37","font_src","rand","random","FontFace","add","$loadFont","$domStyle","Grid","columns","rows","_class46","columnsChanged","rowsChanged","visibleItems","$getVisibleItems","_$calculateSize","$calculateSize","_$calculateSize2","_$calculateGrid","$calculateGrid","_$calculateGrid2","colWidth","rowHeight","step","startingPoint","endPoint","_i2","_j","_item","gridWidth","gridHeight","_i3","_i4","cols","ceil","_i5","_j2","_item2","Tile","TileVertically","TileHorizontally","asynchronous","cache","mirror","_class47","_this38","sourceSize","naturalWidth","naturalHeight","mirrorChanged","$onMirrorChanged","backgroundRepeat","backgroundSize","backgroundPosition","backgroundImage","$updateFillMode","transformRule","_class48","acceptable","$opacity","antialiasing","state","states","transitions","resources","horizontalCenter","verticalCenter","rotation","scale","opacity","clip","_class49","classComponent","parentChanged","$onParentChanged_","$onDataChanged","stateChanged","$onStateChanged","visibleChanged","$onVisibleChanged_","clipChanged","$onClipChanged","zChanged","$onZChanged","xChanged","$onXChanged","yChanged","$onYChanged","$onWidthChanged_","$onHeightChanged_","$onFocusChanged_","implicitWidthChanged","$onImplicitWidthChanged","implicitHeightChanged","$onImplicitHeightChanged","anchors","fill","centerIn","margins","leftMargin","rightMargin","topMargin","bottomMargin","horizontalCenterChanged","verticalCenterChanged","fillChanged","centerInChanged","leftMarginChanged","rightMarginChanged","topMarginChanged","bottomMarginChanged","marginsChanged","childrenRect","rotationChanged","scaleChanged","transformChanged","Component$onCompleted_","opacityChanged","$calculateOpacity","$opacityChanged","$revertActions","newParent","oldParent","removeChild","newData","newState","actions","_i6","action","changes","$getAllChanges","_i7","$applyChange","_i8","_action","_i9","_action2","explicit","transition","rating","_i10","$stop","curTransition","curRating","reversible","$start","change","_this39","arrayFindIndex","_loop","origValue","actionIndex","revertIndex","restoreEntryValues","qmlFocus","base","_this40","updateFocus","hasFocus","activeElement","QMLTranslate","QMLRotation","QMLScale","transformStyle","ax","axis","zIndex","webkitTransform","webkitTransformStyle","msTransform","webkitFilter","parentOpacity","$updatingHGeometry","lM","rM","u","leftProp","$updateChildrenRect","$updatingVGeometry","tM","bM","topProp","maxHeight","minX","minY","heighth","_class50","$items","_class51","_this41","$firstItem","$itemsChanged","$on$itemsChanged","$model","role","rowCount","QMLListElement","dict","setRoleNames","n","vals","_class52","$styleChanged","delegateChanged","orientationChanged","spacingChanged","_childrenInserted","$applyStyleOnItem","$item","sourceComponent","_class53","$sourceUrl","activeChanged","$onActiveChanged","sourceComponentChanged","$onSourceComponentChanged","$updateGeometry","$unload","qmlComponent","loadedComponent","$createComponentObject","$callOnCompleted","newComponent","acceptedButtons","hoverEnabled","mouseX","mouseY","containsMouse","pressedButtons","cursorShape","entered","exited","wheel","_class54","_this42","cursorShapeChanged","$onCursorShapeChanged","$handleClick","handleMouseMove","$handlePositionChanged","handleMouseUp","removeEventListener","$clientTransform","boundingRect","getBoundingClientRect","mouse","$eventToMouse","$handleWheel","cursor","$cursorShapeToCSS","angleDelta","deltaX","deltaY","stopPropagation","clientX","clientY","offsetX","layerX","offsetY","layerY","_class55","_this43","$at","$loop","_action3","$redoActions","_action4","$valueForProgress","$startLoop","_action5","_class56","animations","_class57","_this44","$runningAnimations","animationsChanged","$onAnimationsChanged","$animationFinished","_class58","_this45","_class59","targets","_class60","$props","$targets","$redoTargets","targetsChanged","$redoProperties","propertiesChanged","matches","_class61","_class62","$borderActive","borderStyle","borderColor","border$onColorChanged","border$onWidthChanged","borderTopWidth","_class63","delegate","_class64","$completed","$onDelegateChanged","$onParentChanged","$applyModel","QMLListModel","$getModel","$_onModelDataChanged","$_onRowsInserted","$_onRowsMoved","$_onRowsRemoved","$_onModelReset","$removeChildren","$insertChildren","startIndex","endIndex","roles","_item3","modelData","roleName","roleData","sourceStartIndex","sourceEndIndex","destinationIndex","smallestChangedIndex","_i11","container","_i12","removed","$removeChildProperties","_class65","origin","angleChanged","$updateOrigin","transformOrigin","webkitTransformOrigin","_class66","_class67","_class68","xScaleChanged","yScaleChanged","_class69","_class70","_this46","$onAnimatonsChanged","$nextAnimation","proceed","$curIndex","anim","$passedLoops","ShaderEffect","NoCulling","BackFaceCulling","FrontFaceCulling","Compiled","Uncompiled","blending","cullMode","mesh","supportsAtlasTextures","_class71","ShaderEffectSource","Alpha","RGB","RGBA","NoMirroring","MirrorHorizontally","MirrorVertically","ClampToEdge","RepeatHorizontally","RepeatVertically","format","hideSource","live","mipmap","recursive","sourceItem","textureMirroring","textureSize","wrapMode","_class72","extend","_class73","$onWhenChanged","_this47","platformsDetectors","regexp","systemPalettes","SystemPalette","Active","Inactive","Disabled","alternateBase","buttonText","dark","highlightedText","light","mid","midlight","shadow","windowText","colorGroup","_class74","colorGroupChanged","$onColorGroupChanged","$platform","userAgent","_this48","pallete","OSX","highlightText","inactive","Text","NoWrap","WordWrap","WrapAnywhere","Wrap","WrapAtWordBoundaryOrAnywhere","AutoText","PlainText","StyledText","RichText","Outline","Raised","Sunken","textFormat","lineHeight","horizontalAlignment","styleColor","_class75","fc","whiteSpace","textAlign","textFormatChanged","$onTextFormatChanged","lineHeightChanged","$onLineHeightChanged","wrapModeChanged","$onWrapModeChanged","horizontalAlignmentChanged","$onHorizontalAlignmentChanged","styleColorChanged","$onStyleColorChanged","fontChanged","$onFontChanged","createTextNode","$updateImplicit","$redrawText","$updateShadow","wordWrap","wordBreak","$updateJustifyWhiteSpace","textStyle","textShadow","activeFocusOnPress","baseUrl","canPaste","canRedo","canUndo","contentHeight","contentWidth","cursorDelegate","cursorPosition","cursorRectangle","cursorVisible","effectiveHorizontalAlignment","hoveredLink","inputMethodComposing","inputMethodHints","lineCount","mouseSelectionMode","persistentSelection","renderType","selectByKeyboard","selectByMouse","selectedText","selectedTextColor","selectionColor","selectionEnd","selectionStart","textDocument","textMargin","verticalAlignment","linkActivated","linkHovered","_class76","_this49","undoStack","undoStackPosition","redoStack","redoStackPosition","resize","$getLineCount","$updateCss","supported","o","_class77","_this50","_class78","_action6","_class79","uniform","_class80","_class81","_class82","optional","windowShown","_class83","_this51","tests","started","finished","total","errors","stats","pass","fail","assert","_console","_console2","_len26","_key26","$testId","_console3","_len27","_key27","_console4","_len28","_key28","time","_console5","timeEnd","_console6","trace","_console7","_console8","_len29","_key29","_this52","sort","unshift","special","dstart","performance","init_data","dend","tag","init","cleanup","actual","expected","_info$stats","condition","_class84","WebSocket","Connecting","Open","Closing","Closed","textMessageReceived","_class85","$socket","$reconnect","statusChanged","$onStatusChanged","$reconnectSocket","urlChanged","_this53","onopen","onclose","$connectSocket","onerror","onmessage","close","canGoBack","canGoForward","loadProgress","loading","_class86","_this54","$onUrlChanged","iframe","onload","contentDocument"],"mappings":"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","file":"qmlweb.min.js","sourcesContent":[";(function(global) {\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QmlWeb = {};\n\nglobal.QmlWeb = QmlWeb;\n\nvar objectIds = 0;\n\nvar QObject = function () {\n  function QObject(parent) {\n    _classCallCheck(this, QObject);\n\n    this.$parent = parent;\n    if (parent && parent.$tidyupList) {\n      parent.$tidyupList.push(this);\n    }\n\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n    this.$signals = [];\n\n    this.objectId = objectIds++;\n  }\n\n  _createClass(QObject, [{\n    key: \"$delete\",\n    value: function $delete() {\n      if (this.$Component) {\n        this.$Component.destruction();\n      }\n\n      while (this.$tidyupList.length > 0) {\n        var item = this.$tidyupList[0];\n        if (item.$delete) {\n          // It's a QObject\n          item.$delete();\n        } else {\n          // It must be a signal\n          item.disconnect(this);\n        }\n      }\n\n      for (var i in this.$properties) {\n        var prop = this.$properties[i];\n        while (prop.$tidyupList.length > 0) {\n          prop.$tidyupList[0].disconnect(prop);\n        }\n      }\n\n      if (this.$parent && this.$parent.$tidyupList) {\n        var index = this.$parent.$tidyupList.indexOf(this);\n        this.$parent.$tidyupList.splice(index, 1);\n      }\n\n      // must do this:\n      // 1) parent will be notified and erase object from it's children.\n      // 2) DOM node will be removed.\n      this.parent = undefined;\n\n      // Disconnect any slots connected to any of our signals. Do this after\n      // clearing the parent, as that relies on parentChanged being handled.\n      for (var _i in this.$signals) {\n        this.$signals[_i].disconnect();\n      }\n    }\n\n    // must have a `destroy` method\n    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.$delete();\n    }\n  }, {\n    key: \"$toString\",\n    value: function $toString() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.constructor.name + \"(\" + args.join(\", \") + \")\";\n    }\n  }]);\n\n  return QObject;\n}();\n\nQmlWeb.QObject = QObject;\n\nvar JSItemModel = function () {\n  function JSItemModel() {\n    _classCallCheck(this, JSItemModel);\n\n    this.roleNames = [];\n\n    var Signal = QmlWeb.Signal;\n    this.dataChanged = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsInserted = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsMoved = Signal.signal([{ type: \"int\", name: \"sourceStartIndex\" }, { type: \"int\", name: \"sourceEndIndex\" }, { type: \"int\", name: \"destinationIndex\" }]);\n    this.rowsRemoved = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.modelReset = Signal.signal();\n  }\n\n  _createClass(JSItemModel, [{\n    key: \"setRoleNames\",\n    value: function setRoleNames(names) {\n      this.roleNames = names;\n    }\n  }]);\n\n  return JSItemModel;\n}();\n\nQmlWeb.JSItemModel = JSItemModel;\n\nvar QColor = function () {\n  function QColor() {\n    _classCallCheck(this, QColor);\n\n    this.$changed = new QmlWeb.Signal();\n    this.$r = this.$g = this.$b = 0;\n    this.$a = 1;\n    var val = arguments.length <= 0 ? undefined : arguments[0];\n    if (arguments.length >= 3) {\n      this.$r = arguments.length <= 0 ? undefined : arguments[0];\n      this.$g = arguments.length <= 1 ? undefined : arguments[1];\n      this.$b = arguments.length <= 2 ? undefined : arguments[2];\n      if (arguments.length >= 4) {\n        this.$a = arguments.length <= 3 ? undefined : arguments[3];\n      }\n    } else if (val instanceof QColor) {\n      // Copy constructor\n      this.$a = val.a;\n      this.$r = val.r;\n      this.$g = val.g;\n      this.$b = val.b;\n    } else if (typeof val === \"string\") {\n      var lval = val.toLowerCase();\n      if (QColor.colormap[lval]) {\n        var rgb = QColor.colormap[lval];\n        this.$r = rgb[0] / 255;\n        this.$g = rgb[1] / 255;\n        this.$b = rgb[2] / 255;\n      } else if (lval === \"transparent\") {\n        this.$a = 0;\n      } else if (lval[0] === \"#\") {\n        var hex = lval.substr(1);\n        if (hex.length === 3) {\n          this.$r = parseInt(hex[0], 16) / 15;\n          this.$g = parseInt(hex[1], 16) / 15;\n          this.$b = parseInt(hex[2], 16) / 15;\n        } else {\n          var _rgb = hex.match(/.{2}/g).map(function (x) {\n            return parseInt(x, 16);\n          });\n          if (_rgb.length === 4) {\n            this.$a = _rgb.shift() / 255;\n          }\n          this.$r = _rgb[0] / 255;\n          this.$g = _rgb[1] / 255;\n          this.$b = _rgb[2] / 255;\n        }\n      } else {\n        throw new Error(\"Can not convert \" + val + \" to color\");\n      }\n    } else if (typeof val !== \"undefined\") {\n      throw new Error(\"Can not assign \" + (typeof val === \"undefined\" ? \"undefined\" : _typeof(val)) + \" to QColor\");\n    }\n  }\n\n  _createClass(QColor, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.$string) return this.$string;\n      var argb = [this.$a, this.$r, this.$g, this.$b].map(function (x) {\n        return (Math.round(x * 255) + 0x100).toString(16).substr(-2);\n      });\n      if (argb[0] === \"ff\") {\n        argb.shift(); // We don't need alpha if it's ff\n      }\n      this.$string = \"#\" + argb.join(\"\");\n      return \"#\" + argb.join(\"\");\n    }\n  }, {\n    key: \"$css\",\n    get: function get() {\n      if (this.$cssValue) return this.$cssValue;\n      if (this.$a === 1) {\n        this.$cssValue = this.toString();\n      } else if (this.$a === 0) {\n        this.$cssValue = \"transparent\";\n      } else {\n        var intr = Math.round(this.$r * 255);\n        var intg = Math.round(this.$g * 255);\n        var intb = Math.round(this.$b * 255);\n        this.$cssValue = \"rgba(\" + intr + \",\" + intg + \",\" + intb + \",\" + this.$a + \")\";\n      }\n      return this.$cssValue;\n    }\n  }, {\n    key: \"r\",\n    get: function get() {\n      return this.$r;\n    },\n    set: function set(r) {\n      this.$r = r;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"g\",\n    get: function get() {\n      return this.$g;\n    },\n    set: function set(g) {\n      this.$g = g;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"b\",\n    get: function get() {\n      return this.$b;\n    },\n    set: function set(b) {\n      this.$b = b;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"a\",\n    get: function get() {\n      return this.$a;\n    },\n    set: function set(a) {\n      this.$a = a;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvHue\",\n    get: function get() {\n      var v = this.hsvValue;\n      var m = Math.min(this.$r, this.$g, this.$b);\n      if (v === m) return -1;\n      if (v === this.$r) return ((this.$g - this.$b) / (v - m) + 1) % 1 / 6;\n      if (v === this.$g) return ((this.$b - this.$r) / (v - m) + 2) / 6;\n      if (v === this.$b) return ((this.$r - this.$g) / (v - m) + 4) / 6;\n      throw new Error();\n    },\n    set: function set(h) {\n      var rgb = QColor.$hsv(h, this.hsvSaturation, this.hsvValue);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvSaturation\",\n    get: function get() {\n      var v = this.hsvValue;\n      if (v === 0) return 0;\n      return 1 - Math.min(this.$r, this.$g, this.$b) / v;\n    },\n    set: function set(s) {\n      var rgb = QColor.$hsv(this.hsvHue, s, this.hsvValue);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvValue\",\n    get: function get() {\n      return Math.max(this.$r, this.$g, this.$b);\n    },\n    set: function set(v) {\n      var rgb = QColor.$hsv(this.hsvHue, this.hsvSaturation, v);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslHue\",\n    get: function get() {\n      return this.hsvHue;\n    },\n    set: function set(h) {\n      var rgb = QColor.$hsl(h, this.hslSaturation, this.hslLightness);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslSaturation\",\n    get: function get() {\n      var max = Math.max(this.$r, this.$g, this.$b);\n      var min = Math.min(this.$r, this.$g, this.$b);\n      if (max === min) return 0;\n      return (max - min) / (1 - Math.abs(1 - max - min));\n    },\n    set: function set(s) {\n      var rgb = QColor.$hsl(this.hslHue, s, this.hslLightness);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslLightness\",\n    get: function get() {\n      var max = Math.max(this.$r, this.$g, this.$b);\n      var min = Math.min(this.$r, this.$g, this.$b);\n      return (max + min) / 2;\n    },\n    set: function set(l) {\n      var rgb = QColor.$hsl(this.hslHue, this.hslSaturation, l);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }], [{\n    key: \"$hsv\",\n    value: function $hsv(h, s, v) {\n      var c = v * s;\n      var m = v - c;\n      return QColor.$hcma(h, c, m);\n    }\n  }, {\n    key: \"$hsl\",\n    value: function $hsl(h, s, l) {\n      var c = (1 - Math.abs(2 * l - 1)) * s;\n      var m = l - c / 2;\n      return QColor.$hcma(h, c, m);\n    }\n  }, {\n    key: \"$hcma\",\n    value: function $hcma(h, c, m) {\n      var hh = h > 0 ? h * 6 % 6 : 0;\n      var x = c * (1 - Math.abs(hh % 2 - 1));\n      var rgb = void 0;\n      switch (Math.floor(hh)) {\n        case 0:\n          rgb = [c, x, 0];\n          break;\n        case 1:\n          rgb = [x, c, 0];\n          break;\n        case 2:\n          rgb = [0, c, x];\n          break;\n        case 3:\n          rgb = [0, x, c];\n          break;\n        case 4:\n          rgb = [x, 0, c];\n          break;\n        case 5:\n          rgb = [c, 0, x];\n          break;\n      }\n      return rgb.map(function (y) {\n        return Math.min(1, y + m);\n      });\n    }\n  }, {\n    key: \"darker\",\n    value: function darker(baseColor) {\n      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);\n      var v = color.hsvValue / factor;\n      // Undocumented in Qt, but this matches the observed Qt behaviour\n      var s = color.hsvSaturation - Math.max(0, v - 1);\n      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\n    }\n  }, {\n    key: \"lighter\",\n    value: function lighter(baseColor) {\n      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;\n\n      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);\n      var v = color.hsvValue * factor;\n      // Undocumented in Qt, but this matches the observed Qt behaviour\n      var s = color.hsvSaturation - Math.max(0, v - 1);\n      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\n    }\n  }, {\n    key: \"equal\",\n    value: function equal(lhs, rhs) {\n      var a = lhs instanceof QColor ? lhs : new QColor(lhs);\n      var b = rhs instanceof QColor ? rhs : new QColor(rhs);\n      return a.toString() === b.toString();\n    }\n  }]);\n\n  return QColor;\n}();\n\nQColor.rgba = function (r, g, b) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new QColor(r, g, b, a);\n};\n\nQColor.hsva = function (h, s, v) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsv(h, s, v)), [a])))();\n};\n\nQColor.hsla = function (h, s, l) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsl(h, s, l)), [a])))();\n};\n\nQColor.colormap = { // https://www.w3.org/TR/SVG/types.html#ColorKeywords\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nQColor.nonNullableType = true;\nQColor.requireConstructor = true;\n\nQmlWeb.QColor = QColor;\n\nvar QFont = function (_QmlWeb$QObject) {\n  _inherits(QFont, _QmlWeb$QObject);\n\n  function QFont(parent) {\n    _classCallCheck(this, QFont);\n\n    var _this = _possibleConstructorReturn(this, (QFont.__proto__ || Object.getPrototypeOf(QFont)).call(this, parent));\n\n    _this.Font = QFont.Font;\n\n    var Font = _this.Font;\n\n    QmlWeb.createProperties(_this, {\n      bold: \"bool\",\n      capitalization: { type: \"enum\", initialValue: Font.MixedCase },\n      family: { type: \"string\", initialValue: \"sans-serif\" },\n      italic: \"bool\",\n      letterSpacing: \"real\",\n      pixelSize: { type: \"int\", initialValue: 13 },\n      pointSize: { type: \"real\", initialValue: 10 },\n      strikeout: \"bool\",\n      underline: \"bool\",\n      weight: { type: \"enum\", initialValue: Font.Normal },\n      wordSpacing: \"real\"\n    });\n\n    _this.$sizeLock = false;\n\n    _this.boldChanged.connect(_this, _this.$onBoldChanged);\n    _this.capitalizationChanged.connect(_this, _this.$onCapitalizationChanged);\n    _this.familyChanged.connect(_this, _this.$onFamilyChanged);\n    _this.italicChanged.connect(_this, _this.$onItalicChanged);\n    _this.letterSpacingChanged.connect(_this, _this.$onLetterSpacingChanged);\n    _this.pixelSizeChanged.connect(_this, _this.$onPixelSizeChanged);\n    _this.pointSizeChanged.connect(_this, _this.$onPointSizeChanged);\n    _this.strikeoutChanged.connect(_this, _this.$onStrikeoutChanged);\n    _this.underlineChanged.connect(_this, _this.$onUnderlineChanged);\n    _this.weightChanged.connect(_this, _this.$onWidthChanged);\n    _this.wordSpacingChanged.connect(_this, _this.$onWordSpacingChanged);\n    return _this;\n  }\n\n  _createClass(QFont, [{\n    key: \"$onBoldChanged\",\n    value: function $onBoldChanged(newVal) {\n      var Font = this.Font;\n      this.weight = newVal ? Font.Bold : Font.Normal;\n    }\n  }, {\n    key: \"$onCapitalizationChanged\",\n    value: function $onCapitalizationChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontVariant = newVal === this.Font.SmallCaps ? \"small-caps\" : \"none\";\n      style.textTransform = this.$capitalizationToTextTransform(newVal);\n    }\n  }, {\n    key: \"$onFamilyChanged\",\n    value: function $onFamilyChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontFamily = newVal;\n    }\n  }, {\n    key: \"$onItalicChanged\",\n    value: function $onItalicChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontStyle = newVal ? \"italic\" : \"normal\";\n    }\n  }, {\n    key: \"$onLetterSpacingChanged\",\n    value: function $onLetterSpacingChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.letterSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n    }\n  }, {\n    key: \"$onPixelSizeChanged\",\n    value: function $onPixelSizeChanged(newVal) {\n      if (!this.$sizeLock) {\n        this.pointSize = newVal * 0.75;\n      }\n      var val = newVal + \"px\";\n      this.$parent.dom.style.fontSize = val;\n      this.$parent.dom.firstChild.style.fontSize = val;\n    }\n  }, {\n    key: \"$onPointSizeChanged\",\n    value: function $onPointSizeChanged(newVal) {\n      this.$sizeLock = true;\n      this.pixelSize = Math.round(newVal / 0.75);\n      this.$sizeLock = false;\n    }\n  }, {\n    key: \"$onStrikeoutChanged\",\n    value: function $onStrikeoutChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.textDecoration = newVal ? \"line-through\" : this.$parent.font.underline ? \"underline\" : \"none\";\n    }\n  }, {\n    key: \"$onUnderlineChanged\",\n    value: function $onUnderlineChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.textDecoration = this.$parent.font.strikeout ? \"line-through\" : newVal ? \"underline\" : \"none\";\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontWeight = this.$weightToCss(newVal);\n    }\n  }, {\n    key: \"$onWordSpacingChanged\",\n    value: function $onWordSpacingChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.wordSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n    }\n  }, {\n    key: \"$weightToCss\",\n    value: function $weightToCss(weight) {\n      var Font = this.Font;\n      switch (weight) {\n        case Font.Thin:\n          return \"100\";\n        case Font.ExtraLight:\n          return \"200\";\n        case Font.Light:\n          return \"300\";\n        case Font.Normal:\n          return \"400\";\n        case Font.Medium:\n          return \"500\";\n        case Font.DemiBold:\n          return \"600\";\n        case Font.Bold:\n          return \"700\";\n        case Font.ExtraBold:\n          return \"800\";\n        case Font.Black:\n          return \"900\";\n      }\n      return \"normal\";\n    }\n  }, {\n    key: \"$capitalizationToTextTransform\",\n    value: function $capitalizationToTextTransform(capitalization) {\n      var Font = this.Font;\n      switch (capitalization) {\n        case Font.AllUppercase:\n          return \"uppercase\";\n        case Font.AllLowercase:\n          return \"lowercase\";\n        case Font.Capitalize:\n          return \"capitalize\";\n      }\n      return \"none\";\n    }\n  }]);\n\n  return QFont;\n}(QmlWeb.QObject);\n\nQFont.Font = {\n  // Capitalization\n  MixedCase: 0,\n  AllUppercase: 1,\n  AllLowercase: 2,\n  SmallCaps: 3,\n  Capitalize: 4,\n  // Weight\n  Thin: 0,\n  ExtraLight: 12,\n  Light: 25,\n  Normal: 50,\n  Medium: 57,\n  DemiBold: 63,\n  Bold: 75,\n  ExtraBold: 81,\n  Black: 87\n};\nQFont.requireParent = true;\n\n\nQmlWeb.QFont = QFont;\nglobal.Font = QFont.Font; // HACK\n\nvar QMatrix4x4 = function (_QmlWeb$QObject2) {\n  _inherits(QMatrix4x4, _QmlWeb$QObject2);\n\n  function QMatrix4x4() {\n    _classCallCheck(this, QMatrix4x4);\n\n    var _this2 = _possibleConstructorReturn(this, (QMatrix4x4.__proto__ || Object.getPrototypeOf(QMatrix4x4)).call(this));\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [];\n      for (var row = 1; row <= 4; row++) {\n        for (var col = 1; col <= 4; col++) {\n          data.push(col === row ? 1 : 0);\n        }\n      }\n    } else if (args.length === 1 && args[0] instanceof QMatrix4x4) {\n      data = [];\n      for (var _row = 1; _row <= 4; _row++) {\n        for (var _col = 1; _col <= 4; _col++) {\n          var name = \"m\" + _row + _col;\n          data.push(args[0][name]);\n        }\n      }\n    } else if (args.length !== 16) {\n      throw new Error(\"Invalid arguments\");\n    }\n    for (var _row2 = 1; _row2 <= 4; _row2++) {\n      for (var _col2 = 1; _col2 <= 4; _col2++) {\n        var _name = \"m\" + _row2 + _col2;\n        var value = data[4 * (_row2 - 1) + _col2 - 1];\n        QmlWeb.createProperty(\"real\", _this2, _name, { initialValue: value });\n      }\n    }\n    return _this2;\n  }\n\n  _createClass(QMatrix4x4, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QMatrix4x4.prototype.__proto__ || Object.getPrototypeOf(QMatrix4x4.prototype), \"$toString\", this).call(this, this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44);\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var t = this;\n        return new QmlWeb.QMatrix4x4(t.m11 * a.m11 + t.m12 * a.m21 + t.m13 * a.m31 + t.m14 * a.m41, t.m11 * a.m12 + t.m12 * a.m22 + t.m13 * a.m32 + t.m14 * a.m42, t.m11 * a.m13 + t.m12 * a.m23 + t.m13 * a.m33 + t.m14 * a.m43, t.m11 * a.m14 + t.m12 * a.m24 + t.m13 * a.m34 + t.m14 * a.m44, t.m21 * a.m11 + t.m22 * a.m21 + t.m23 * a.m31 + t.m24 * a.m41, t.m21 * a.m12 + t.m22 * a.m22 + t.m23 * a.m32 + t.m24 * a.m42, t.m21 * a.m13 + t.m22 * a.m23 + t.m23 * a.m33 + t.m24 * a.m43, t.m21 * a.m14 + t.m22 * a.m24 + t.m23 * a.m34 + t.m24 * a.m44, t.m31 * a.m11 + t.m32 * a.m21 + t.m33 * a.m31 + t.m34 * a.m41, t.m31 * a.m12 + t.m32 * a.m22 + t.m33 * a.m32 + t.m34 * a.m42, t.m31 * a.m13 + t.m32 * a.m23 + t.m33 * a.m33 + t.m34 * a.m43, t.m31 * a.m14 + t.m32 * a.m24 + t.m33 * a.m34 + t.m34 * a.m44, t.m41 * a.m11 + t.m42 * a.m21 + t.m43 * a.m31 + t.m44 * a.m41, t.m41 * a.m12 + t.m42 * a.m22 + t.m43 * a.m32 + t.m44 * a.m42, t.m41 * a.m13 + t.m42 * a.m23 + t.m43 * a.m33 + t.m44 * a.m43, t.m41 * a.m14 + t.m42 * a.m24 + t.m43 * a.m34 + t.m44 * a.m44);\n      }\n      if (a instanceof QmlWeb.QVector4D) {\n        var _t = this;\n        return new QmlWeb.QVector4D(_t.m11 * a.x + _t.m12 * a.y + _t.m13 * a.z + _t.m14 * a.w, _t.m21 * a.x + _t.m22 * a.y + _t.m23 * a.z + _t.m24 * a.w, _t.m31 * a.x + _t.m32 * a.y + _t.m33 * a.z + _t.m34 * a.w, _t.m41 * a.x + _t.m42 * a.y + _t.m43 * a.z + _t.m44 * a.w);\n      }\n      if (a instanceof QmlWeb.QVector3D) {\n        var v = this.times(new QmlWeb.QVector4D(a.x, a.y, a.z, 1));\n        return new QmlWeb.QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\n      }\n      return new QMatrix4x4(this.m11 * a, this.m12 * a, this.m13 * a, this.m14 * a, this.m21 * a, this.m22 * a, this.m23 * a, this.m24 * a, this.m31 * a, this.m32 * a, this.m33 * a, this.m34 * a, this.m41 * a, this.m42 * a, this.m43 * a, this.m44 * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(other) {\n      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\n      return new QMatrix4x4(this.m11 + a.m11, this.m12 + a.m12, this.m13 + a.m13, this.m14 + a.m14, this.m21 + a.m21, this.m22 + a.m22, this.m23 + a.m23, this.m24 + a.m24, this.m31 + a.m31, this.m32 + a.m32, this.m33 + a.m33, this.m34 + a.m34, this.m41 + a.m41, this.m42 + a.m42, this.m43 + a.m43, this.m44 + a.m44);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(other) {\n      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\n      return new QMatrix4x4(this.m11 - a.m11, this.m12 - a.m12, this.m13 - a.m13, this.m14 - a.m14, this.m21 - a.m21, this.m22 - a.m22, this.m23 - a.m23, this.m24 - a.m24, this.m31 - a.m31, this.m32 - a.m32, this.m33 - a.m33, this.m34 - a.m34, this.m41 - a.m41, this.m42 - a.m42, this.m43 - a.m43, this.m44 - a.m44);\n    }\n  }, {\n    key: \"row\",\n    value: function row(i) {\n      var _this3 = this;\n\n      var row = i + 1;\n      var arr = [1, 2, 3, 4].map(function (col) {\n        return _this3[\"m\" + row + col];\n      });\n      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();\n    }\n  }, {\n    key: \"column\",\n    value: function column(i) {\n      var _this4 = this;\n\n      var col = i + 1;\n      var arr = [1, 2, 3, 4].map(function (row) {\n        return _this4[\"m\" + row + col];\n      });\n      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();\n    }\n  }, {\n    key: \"determinant\",\n    value: function determinant() {\n      // Laplace expansion\n      var t = this;\n      var s0 = t.m11 * t.m22 - t.m12 * t.m21;\n      var c5 = t.m33 * t.m44 - t.m34 * t.m43;\n      var s1 = t.m11 * t.m23 - t.m13 * t.m21;\n      var c4 = t.m32 * t.m44 - t.m34 * t.m42;\n      var s2 = t.m11 * t.m24 - t.m14 * t.m21;\n      var c3 = t.m32 * t.m43 - t.m33 * t.m42;\n      var s3 = t.m12 * t.m23 - t.m13 * t.m22;\n      var c2 = t.m31 * t.m44 - t.m34 * t.m41;\n      var s4 = t.m12 * t.m24 - t.m14 * t.m22;\n      var c1 = t.m31 * t.m43 - t.m33 * t.m41;\n      var s5 = t.m13 * t.m24 - t.m14 * t.m23;\n      var c0 = t.m31 * t.m42 - t.m32 * t.m41;\n      return s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\n    }\n  }, {\n    key: \"inverted\",\n    value: function inverted() {\n      // Laplace expansion\n      var t = this;\n      var s0 = t.m11 * t.m22 - t.m12 * t.m21;\n      var c5 = t.m33 * t.m44 - t.m34 * t.m43;\n      var s1 = t.m11 * t.m23 - t.m13 * t.m21;\n      var c4 = t.m32 * t.m44 - t.m34 * t.m42;\n      var s2 = t.m11 * t.m24 - t.m14 * t.m21;\n      var c3 = t.m32 * t.m43 - t.m33 * t.m42;\n      var s3 = t.m12 * t.m23 - t.m13 * t.m22;\n      var c2 = t.m31 * t.m44 - t.m34 * t.m41;\n      var s4 = t.m12 * t.m24 - t.m14 * t.m22;\n      var c1 = t.m31 * t.m43 - t.m33 * t.m41;\n      var s5 = t.m13 * t.m24 - t.m14 * t.m23;\n      var c0 = t.m31 * t.m42 - t.m32 * t.m41;\n      var det = s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\n      var adj = [+t.m22 * c5 - t.m23 * c4 + t.m24 * c3, -t.m12 * c5 + t.m13 * c4 - t.m14 * c3, +t.m42 * s5 - t.m43 * s4 + t.m44 * s3, -t.m32 * s5 + t.m33 * s4 - t.m34 * s3, -t.m21 * c5 + t.m23 * c2 - t.m24 * c1, +t.m11 * c5 - t.m13 * c2 + t.m14 * c1, -t.m41 * s5 + t.m43 * s2 - t.m44 * s1, +t.m31 * s5 - t.m33 * s2 + t.m34 * s1, +t.m21 * c4 - t.m22 * c2 + t.m24 * c0, -t.m11 * c4 + t.m12 * c2 - t.m14 * c0, +t.m41 * s4 - t.m42 * s2 + t.m44 * s0, -t.m31 * s4 + t.m32 * s2 - t.m34 * s0, -t.m21 * c3 + t.m22 * c1 - t.m23 * c0, +t.m11 * c3 - t.m12 * c1 + t.m13 * c0, -t.m41 * s3 + t.m42 * s1 - t.m43 * s0, +t.m31 * s3 - t.m32 * s1 + t.m33 * s0];\n      return new (Function.prototype.bind.apply(QMatrix4x4, [null].concat(_toConsumableArray(adj.map(function (x) {\n        return x / det;\n      })))))();\n    }\n  }, {\n    key: \"transposed\",\n    value: function transposed() {\n      return new QMatrix4x4(this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43, this.m14, this.m24, this.m34, this.m44);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      for (var row = 1; row <= 4; row++) {\n        for (var col = 1; col <= 4; col++) {\n          var name = \"m\" + row + col;\n          if (Math.abs(this[name] - a[name]) > epsilon) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }]);\n\n  return QMatrix4x4;\n}(QmlWeb.QObject);\n\nQMatrix4x4.nonNullableType = true;\nQMatrix4x4.requireConstructor = true;\n\n\nQmlWeb.QMatrix4x4 = QMatrix4x4;\n\nvar QPointF = function (_QmlWeb$QObject3) {\n  _inherits(QPointF, _QmlWeb$QObject3);\n\n  function QPointF() {\n    _classCallCheck(this, QPointF);\n\n    var _this5 = _possibleConstructorReturn(this, (QPointF.__proto__ || Object.getPrototypeOf(QPointF)).call(this));\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [0, 0];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) throw new Error(\"point expected\");\n    } else if (args.length === 1 && args[0] instanceof QPointF) {\n      data = [args[0].x, args[0].y];\n    } else if (args.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this5, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] }\n    });\n    return _this5;\n  }\n\n  _createClass(QPointF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QPointF.prototype.__proto__ || Object.getPrototypeOf(QPointF.prototype), \"$toString\", this).call(this, this.x, this.y);\n    }\n  }]);\n\n  return QPointF;\n}(QmlWeb.QObject);\n\nQPointF.nonNullableType = true;\nQPointF.requireConstructor = true;\n\n\nQmlWeb.QPointF = QPointF;\n\nvar QQuaternion = function (_QmlWeb$QObject4) {\n  _inherits(QQuaternion, _QmlWeb$QObject4);\n\n  function QQuaternion() {\n    _classCallCheck(this, QQuaternion);\n\n    var _this6 = _possibleConstructorReturn(this, (QQuaternion.__proto__ || Object.getPrototypeOf(QQuaternion)).call(this));\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 4) data = [];\n    } else if (args.length === 1 && args[0] instanceof QQuaternion) {\n      data = [args[0].scalar, args[0].x, args[0].y, args[0].z];\n    }\n    if (data.length === 0) {\n      data = [1, 0, 0, 0];\n    } else if (data.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this6, {\n      scalar: { type: \"real\", initialValue: data[0] },\n      x: { type: \"real\", initialValue: data[1] },\n      y: { type: \"real\", initialValue: data[2] },\n      z: { type: \"real\", initialValue: data[3] }\n    });\n    return _this6;\n  }\n\n  _createClass(QQuaternion, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QQuaternion.prototype.__proto__ || Object.getPrototypeOf(QQuaternion.prototype), \"$toString\", this).call(this, this.scalar, this.x, this.y, this.z);\n    }\n  }]);\n\n  return QQuaternion;\n}(QmlWeb.QObject);\n\nQQuaternion.nonNullableType = true;\nQQuaternion.requireConstructor = true;\n\n\nQmlWeb.QQuaternion = QQuaternion;\n\nvar QRectF = function (_QmlWeb$QObject5) {\n  _inherits(QRectF, _QmlWeb$QObject5);\n\n  function QRectF() {\n    _classCallCheck(this, QRectF);\n\n    var _this7 = _possibleConstructorReturn(this, (QRectF.__proto__ || Object.getPrototypeOf(QRectF)).call(this));\n\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [0, 0, 0, 0];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      var mask = /^\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*x\\s*[-\\d.]+\\s*$/;\n      if (!args[0].match(mask)) throw new Error(\"rect expected\");\n      data = args[0].replace(\"x\", \",\").split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n    } else if (args.length === 1 && args[0] instanceof QRectF) {\n      data = [args[0].x, args[0].y, args[0].z, args[0].width];\n    } else if (args.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this7, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      width: { type: \"real\", initialValue: data[2] },\n      height: { type: \"real\", initialValue: data[3] }\n    });\n    return _this7;\n  }\n\n  _createClass(QRectF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QRectF.prototype.__proto__ || Object.getPrototypeOf(QRectF.prototype), \"$toString\", this).call(this, this.x, this.y, this.width, this.height);\n    }\n  }]);\n\n  return QRectF;\n}(QmlWeb.QObject);\n\nQRectF.nonNullableType = true;\nQRectF.requireConstructor = true;\n\n\nQmlWeb.QRectF = QRectF;\n\nvar QSizeF = function (_QmlWeb$QObject6) {\n  _inherits(QSizeF, _QmlWeb$QObject6);\n\n  function QSizeF() {\n    _classCallCheck(this, QSizeF);\n\n    var _this8 = _possibleConstructorReturn(this, (QSizeF.__proto__ || Object.getPrototypeOf(QSizeF)).call(this));\n\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [-1, -1];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\"x\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) throw new Error(\"size expected\");\n    } else if (args.length === 1 && args[0] instanceof QSizeF) {\n      data = [args[0].width, args[0].height];\n    } else if (args.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this8, {\n      width: { type: \"real\", initialValue: data[0] },\n      height: { type: \"real\", initialValue: data[1] }\n    });\n    return _this8;\n  }\n\n  _createClass(QSizeF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QSizeF.prototype.__proto__ || Object.getPrototypeOf(QSizeF.prototype), \"$toString\", this).call(this, this.width, this.height);\n    }\n  }]);\n\n  return QSizeF;\n}(QmlWeb.QObject);\n\nQSizeF.nonNullableType = true;\nQSizeF.requireConstructor = true;\n\n\nQmlWeb.QSizeF = QSizeF;\n\nvar QVector2D = function (_QmlWeb$QObject7) {\n  _inherits(QVector2D, _QmlWeb$QObject7);\n\n  function QVector2D() {\n    _classCallCheck(this, QVector2D);\n\n    var _this9 = _possibleConstructorReturn(this, (QVector2D.__proto__ || Object.getPrototypeOf(QVector2D)).call(this));\n\n    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector2D) {\n      data = [args[0].x, args[0].y];\n    }\n    if (data.length === 0) {\n      data = [0, 0];\n    } else if (data.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this9, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] }\n    });\n    return _this9;\n  }\n\n  _createClass(QVector2D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector2D.prototype.__proto__ || Object.getPrototypeOf(QVector2D.prototype), \"$toString\", this).call(this, this.x, this.y);\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector2D) {\n        return a.x * this.x + a.y * this.y;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x * a.x, this.y * a.y);\n      }\n      return new QVector2D(this.x * a, this.y * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x + a.x, this.y + a.y);\n      }\n      return new QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x - a.x, this.y - a.y);\n      }\n      return new QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector3d\",\n    value: function toVector3d() {\n      return new QmlWeb.QVector3D(this.x, this.y, 0);\n    }\n  }, {\n    key: \"toVector4d\",\n    value: function toVector4d() {\n      return new QmlWeb.QVector4D(this.x, this.y, 0, 0);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector2D;\n}(QmlWeb.QObject);\n\nQVector2D.nonNullableType = true;\nQVector2D.requireConstructor = true;\n\n\nQmlWeb.QVector2D = QVector2D;\n\nvar QVector3D = function (_QmlWeb$QObject8) {\n  _inherits(QVector3D, _QmlWeb$QObject8);\n\n  function QVector3D() {\n    _classCallCheck(this, QVector3D);\n\n    var _this10 = _possibleConstructorReturn(this, (QVector3D.__proto__ || Object.getPrototypeOf(QVector3D)).call(this));\n\n    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 3) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector3D) {\n      data = [args[0].x, args[0].y, args[0].z];\n    }\n    if (data.length === 0) {\n      data = [0, 0, 0];\n    } else if (data.length !== 3) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this10, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      z: { type: \"real\", initialValue: data[2] }\n    });\n    return _this10;\n  }\n\n  _createClass(QVector3D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector3D.prototype.__proto__ || Object.getPrototypeOf(QVector3D.prototype), \"$toString\", this).call(this, this.x, this.y, this.z);\n    }\n  }, {\n    key: \"crossProduct\",\n    value: function crossProduct(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);\n      }\n      return new QVector3D();\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector3D) {\n        return a.x * this.x + a.y * this.y + a.z * this.z;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var v = new QmlWeb.QVector4D(this.x, this.y, this.z, 1).times(a);\n        return new QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\n      }\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x * a.x, this.y * a.y, this.z * a.z);\n      }\n      return new QVector3D(this.x * a, this.y * a, this.z * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x + a.x, this.y + a.y, this.z + a.z);\n      }\n      return new QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x - a.x, this.y - a.y, this.z - a.z);\n      }\n      return new QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector2d\",\n    value: function toVector2d() {\n      return new QmlWeb.QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"toVector4d\",\n    value: function toVector4d() {\n      return new QmlWeb.QVector4D(this.x, this.y, this.z, 0);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y, this.z - a.z].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector3D;\n}(QmlWeb.QObject);\n\nQVector3D.nonNullableType = true;\nQVector3D.requireConstructor = true;\n\n\nQmlWeb.QVector3D = QVector3D;\n\nvar QVector4D = function (_QmlWeb$QObject9) {\n  _inherits(QVector4D, _QmlWeb$QObject9);\n\n  function QVector4D() {\n    _classCallCheck(this, QVector4D);\n\n    var _this11 = _possibleConstructorReturn(this, (QVector4D.__proto__ || Object.getPrototypeOf(QVector4D)).call(this));\n\n    for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 4) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector4D) {\n      data = [args[0].x, args[0].y, args[0].z, args[0].w];\n    }\n    if (data.length === 0) {\n      data = [0, 0, 0, 0];\n    } else if (data.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this11, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      z: { type: \"real\", initialValue: data[2] },\n      w: { type: \"real\", initialValue: data[3] }\n    });\n    return _this11;\n  }\n\n  _createClass(QVector4D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector4D.prototype.__proto__ || Object.getPrototypeOf(QVector4D.prototype), \"$toString\", this).call(this, this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector4D) {\n        return a.x * this.x + a.y * this.y + a.z * this.z + a.w * this.w;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var t = this;\n        return new QVector4D(t.x * a.m11 + t.y * a.m21 + t.z * a.m31 + t.w * a.m41, t.x * a.m12 + t.y * a.m22 + t.z * a.m32 + t.w * a.m42, t.x * a.m13 + t.y * a.m23 + t.z * a.m33 + t.w * a.m43, t.x * a.m14 + t.y * a.m24 + t.z * a.m34 + t.w * a.m44);\n      }\n      if (a instanceof QVector4D) {\n        var _t2 = this;\n        return new QVector4D(_t2.x * a.x, _t2.y * a.y, _t2.z * a.z, _t2.w * a.w);\n      }\n      return new QVector4D(this.x * a, this.y * a, this.z * a, this.w * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector4D) {\n        var t = this;\n        return new QVector4D(t.x + a.x, t.y + a.y, t.z + a.z, t.w + a.w);\n      }\n      return new QVector4D(this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector4D) {\n        var t = this;\n        return new QVector4D(t.x - a.x, t.y - a.y, t.z - a.z, t.w - a.w);\n      }\n      return new QVector4D(this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector2d\",\n    value: function toVector2d() {\n      return new QmlWeb.QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"toVector3d\",\n    value: function toVector3d() {\n      return new QmlWeb.QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector4D;\n}(QmlWeb.QObject);\n\nQVector4D.nonNullableType = true;\nQVector4D.requireConstructor = true;\n\n\nQmlWeb.QVector4D = QVector4D;\n\nvar Signal = function () {\n  function Signal() {\n    var _this12 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Signal);\n\n    this.connectedSlots = [];\n    this.obj = options.obj;\n    this.options = options;\n\n    this.signal = function () {\n      return _this12.execute.apply(_this12, arguments);\n    };\n    this.signal.parameters = params;\n    this.signal.connect = this.connect.bind(this);\n    this.signal.disconnect = this.disconnect.bind(this);\n    this.signal.isConnected = this.isConnected.bind(this);\n\n    // TODO Fix Keys that don't have an obj for the signal\n    if (this.obj && this.obj.$signals !== undefined) {\n      this.obj.$signals.push(this.signal);\n    }\n  }\n\n  _createClass(Signal, [{\n    key: \"execute\",\n    value: function execute() {\n      QmlWeb.QMLProperty.pushEvalStack();\n\n      for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      for (var i in this.connectedSlots) {\n        var desc = this.connectedSlots[i];\n        if (desc.type & Signal.QueuedConnection) {\n          Signal.$addQueued(desc, args);\n        } else {\n          Signal.$execute(desc, args);\n        }\n      }\n      QmlWeb.QMLProperty.popEvalStack();\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var type = Signal.AutoConnection;\n\n      for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n\n      if (typeof args[args.length - 1] === \"number\") {\n        type = args.pop();\n      }\n      if (type & Signal.UniqueConnection) {\n        if (this.isConnected.apply(this, args)) {\n          return;\n        }\n      }\n      if (args.length === 1) {\n        this.connectedSlots.push({ thisObj: global, slot: args[0], type: type });\n      } else if (typeof args[1] === \"string\" || args[1] instanceof String) {\n        if (args[0].$tidyupList && args[0] !== this.obj) {\n          args[0].$tidyupList.push(this.signal);\n        }\n        var slot = args[0][args[1]];\n        this.connectedSlots.push({ thisObj: args[0], slot: slot, type: type });\n      } else {\n        if (args[0].$tidyupList && (!this.obj || args[0] !== this.obj && args[0] !== this.obj.$parent)) {\n          args[0].$tidyupList.push(this.signal);\n        }\n        this.connectedSlots.push({ thisObj: args[0], slot: args[1], type: type });\n      }\n\n      // Notify object of connect\n      if (this.options.obj && this.options.obj.$connectNotify) {\n        this.options.obj.$connectNotify(this.options);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n\n      // type meaning:\n      //  1 = function, 2 = string\n      //  3 = object with string method,  4 = object with function\n      // No args means disconnect everything connected to this signal\n      var callType = args.length === 1 ? args[0] instanceof Function ? 1 : 2 : typeof args[1] === \"string\" || args[1] instanceof String ? 3 : 4;\n      for (var i = 0; i < this.connectedSlots.length; i++) {\n        var _connectedSlots$i = this.connectedSlots[i],\n            slot = _connectedSlots$i.slot,\n            thisObj = _connectedSlots$i.thisObj;\n\n        if (args.length === 0 || callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] || callType === 3 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {\n          if (thisObj) {\n            var index = thisObj.$tidyupList.indexOf(this.signal);\n            if (index >= 0) {\n              thisObj.$tidyupList.splice(index, 1);\n            }\n          }\n          this.connectedSlots.splice(i, 1);\n          // We have removed an item from the list so the indexes shifted one\n          // backwards\n          i--;\n        }\n      }\n\n      // Notify object of disconnect\n      if (this.options.obj && this.options.obj.$disconnectNotify) {\n        this.options.obj.$disconnectNotify(this.options);\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      for (var _len13 = arguments.length, args = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n\n      var callType = args.length === 1 ? 1 : typeof args[1] === \"string\" || args[1] instanceof String ? 2 : 3;\n      for (var i in this.connectedSlots) {\n        var _connectedSlots$i2 = this.connectedSlots[i],\n            slot = _connectedSlots$i2.slot,\n            thisObj = _connectedSlots$i2.thisObj;\n\n        if (callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }], [{\n    key: \"signal\",\n    value: function signal() {\n      for (var _len14 = arguments.length, args = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n\n      return new (Function.prototype.bind.apply(Signal, [null].concat(args)))().signal;\n    }\n  }, {\n    key: \"$execute\",\n    value: function $execute(desc, args) {\n      try {\n        desc.slot.apply(desc.thisObj, args);\n      } catch (err) {\n        console.error(\"Signal slot error:\", err.message, err, desc.slot ? Function.prototype.toString.call(desc.slot) : \"desc.slot is undefined!\");\n      }\n    }\n  }, {\n    key: \"$addQueued\",\n    value: function $addQueued(desc, args) {\n      if (Signal.$queued.length === 0) {\n        if (global.setImmediate) {\n          global.setImmediate(Signal.$executeQueued);\n        } else {\n          global.setTimeout(Signal.$executeQueued, 0);\n        }\n      }\n      Signal.$queued.push([desc, args]);\n    }\n  }, {\n    key: \"$executeQueued\",\n    value: function $executeQueued() {\n      // New queued signals should be executed on next tick of the event loop\n      var queued = Signal.$queued;\n      Signal.$queued = [];\n\n      QmlWeb.QMLProperty.pushEvalStack();\n      for (var i in queued) {\n        Signal.$execute.apply(Signal, _toConsumableArray(queued[i]));\n      }\n      QmlWeb.QMLProperty.popEvalStack();\n    }\n  }]);\n\n  return Signal;\n}();\n\nSignal.$queued = [];\nSignal.AutoConnection = 0;\nSignal.DirectConnection = 1;\nSignal.QueuedConnection = 2;\nSignal.UniqueConnection = 128;\n\n\nQmlWeb.Signal = Signal;\n\nvar Qt = {\n  openUrlExternally: function openUrlExternally(url) {\n    var page = window.open(url, \"_blank\");\n    page.focus();\n  },\n  // Load file, parse and construct as Component (.qml)\n  createComponent: function createComponent(name) {\n    var engine = QmlWeb.engine;\n\n    var file = engine.$resolvePath(name);\n\n    // If \"name\" was a full URL, \"file\" will be equivalent to name and this\n    // will try and load the Component from the full URL, otherwise, this\n    // doubles as checking for the file in the current directory.\n    var tree = engine.loadComponent(file);\n\n    // If the Component is not found, and it is not a URL, look for \"name\" in\n    // this context's importSearchPaths\n    if (!tree) {\n      var nameIsUrl = engine.$parseURI(name) !== undefined;\n      if (!nameIsUrl) {\n        var moreDirs = engine.importSearchPaths(QmlWeb.executionContext.importContextId);\n        for (var i = 0; i < moreDirs.length; i++) {\n          file = \"\" + moreDirs[i] + name;\n          tree = engine.loadComponent(file);\n          if (tree) break;\n        }\n      }\n    }\n\n    if (!tree) {\n      return undefined;\n    }\n\n    var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    var component = new QMLComponent({\n      object: tree,\n      context: QmlWeb.executionContext\n    });\n    component.$basePath = engine.extractBasePath(file);\n    component.$imports = tree.$imports;\n    component.$file = file; // just for debugging\n\n    engine.loadImports(tree.$imports, component.$basePath, component.importContextId);\n\n    return component;\n  },\n\n  createQmlObject: function createQmlObject(src, parent, file) {\n    var tree = QmlWeb.parseQML(src, file);\n\n    // Create and initialize objects\n\n    var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    var component = new QMLComponent({\n      object: tree,\n      parent: parent,\n      context: QmlWeb.executionContext\n    });\n\n    var engine = QmlWeb.engine;\n    engine.loadImports(tree.$imports, undefined, component.importContextId);\n\n    var resolvedFile = file || Qt.resolvedUrl(\"createQmlObject_function\");\n    component.$basePath = engine.extractBasePath(resolvedFile);\n    component.$imports = tree.$imports; // for later use\n    // not just for debugging, but for basepath too, see above\n    component.$file = resolvedFile;\n\n    var obj = component.createObject(parent);\n\n    var QMLOperationState = QmlWeb.QMLOperationState;\n    if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n      // We don't call those on first creation, as they will be called\n      // by the regular creation-procedures at the right time.\n      engine.$initializePropertyBindings();\n\n      engine.callCompletedSignals();\n    }\n\n    return obj;\n  },\n\n  // Returns url resolved relative to the URL of the caller.\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n  resolvedUrl: function resolvedUrl(url) {\n    return QmlWeb.qmlUrl(url);\n  },\n\n  // Basic QML types constructors\n  point: function point() {\n    for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      args[_key15] = arguments[_key15];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QPointF, [null].concat(args)))();\n  },\n  rect: function rect() {\n    for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n      args[_key16] = arguments[_key16];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QRectF, [null].concat(args)))();\n  },\n  size: function size() {\n    for (var _len17 = arguments.length, args = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n      args[_key17] = arguments[_key17];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QSizeF, [null].concat(args)))();\n  },\n  vector2d: function vector2d() {\n    for (var _len18 = arguments.length, args = Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n      args[_key18] = arguments[_key18];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector2D, [null].concat(args)))();\n  },\n  vector3d: function vector3d() {\n    for (var _len19 = arguments.length, args = Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n      args[_key19] = arguments[_key19];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector3D, [null].concat(args)))();\n  },\n  vector4d: function vector4d() {\n    for (var _len20 = arguments.length, args = Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n      args[_key20] = arguments[_key20];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(args)))();\n  },\n  quaternion: function quaternion() {\n    for (var _len21 = arguments.length, args = Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n      args[_key21] = arguments[_key21];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QQuaternion, [null].concat(args)))();\n  },\n  matrix4x4: function matrix4x4() {\n    for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n      args[_key22] = arguments[_key22];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QMatrix4x4, [null].concat(args)))();\n  },\n\n  // Colors\n  rgba: function rgba() {\n    var _QmlWeb$QColor;\n\n    return (_QmlWeb$QColor = QmlWeb.QColor).rgba.apply(_QmlWeb$QColor, arguments);\n  },\n  hsla: function hsla() {\n    var _QmlWeb$QColor2;\n\n    return (_QmlWeb$QColor2 = QmlWeb.QColor).hsla.apply(_QmlWeb$QColor2, arguments);\n  },\n  hsva: function hsva() {\n    var _QmlWeb$QColor3;\n\n    return (_QmlWeb$QColor3 = QmlWeb.QColor).hsva.apply(_QmlWeb$QColor3, arguments);\n  },\n  colorEqual: function colorEqual() {\n    var _QmlWeb$QColor4;\n\n    return (_QmlWeb$QColor4 = QmlWeb.QColor).equal.apply(_QmlWeb$QColor4, arguments);\n  },\n  darker: function darker() {\n    var _QmlWeb$QColor5;\n\n    return (_QmlWeb$QColor5 = QmlWeb.QColor).darker.apply(_QmlWeb$QColor5, arguments);\n  },\n  lighter: function lighter() {\n    var _QmlWeb$QColor6;\n\n    return (_QmlWeb$QColor6 = QmlWeb.QColor).lighter.apply(_QmlWeb$QColor6, arguments);\n  },\n\n  include: function include(path) {\n    var engine = QmlWeb.engine;\n\n    var uri = engine.$resolvePath(path);\n\n    /* Handle recursive includes */\n    if (QmlWeb.executionContext.$qmlJsIncludes === undefined) {\n      QmlWeb.executionContext.$qmlJsIncludes = [];\n    }\n\n    if (QmlWeb.executionContext.$qmlJsIncludes.indexOf(uri) >= 0) {\n      return;\n    }\n\n    QmlWeb.executionContext.$qmlJsIncludes.push(uri);\n\n    var js = engine.loadJS(uri);\n\n    if (!js) {\n      console.error(\"Unable to load JavaScript module:\", uri, path);\n      return;\n    }\n\n    QmlWeb.importJavascriptInContext(js, QmlWeb.executionContext);\n  },\n\n\n  platform: {\n    os: \"qmlweb\"\n  },\n\n  // Buttons masks\n  LeftButton: 1,\n  RightButton: 2,\n  MiddleButton: 4,\n  // Modifiers masks\n  NoModifier: 0,\n  ShiftModifier: 1,\n  ControlModifier: 2,\n  AltModifier: 4,\n  MetaModifier: 8,\n  KeypadModifier: 16, // Note: Not available in web\n  // Layout directions\n  LeftToRight: 0,\n  RightToLeft: 1,\n  // Orientations\n  Vertical: 0,\n  Horizontal: 1,\n  // Keys\n  Key_Escape: 27,\n  Key_Tab: 9,\n  Key_Backtab: 245,\n  Key_Backspace: 8,\n  Key_Return: 13,\n  Key_Enter: 13,\n  Key_Insert: 45,\n  Key_Delete: 46,\n  Key_Pause: 19,\n  Key_Print: 42,\n  Key_SysReq: 0,\n  Key_Clear: 12,\n  Key_Home: 36,\n  Key_End: 35,\n  Key_Left: 37,\n  Key_Up: 38,\n  Key_Right: 39,\n  Key_Down: 40,\n  Key_PageUp: 33,\n  Key_PageDown: 34,\n  Key_Shift: 16,\n  Key_Control: 17,\n  Key_Meta: 91,\n  Key_Alt: 18,\n  Key_AltGr: 0,\n  Key_CapsLock: 20,\n  Key_NumLock: 144,\n  Key_ScrollLock: 145,\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117,\n  Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122,\n  Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127,\n  Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132,\n  Key_F22: 133, Key_F23: 134, Key_F24: 135,\n  Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0,\n  Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n  Key_Super_L: 0,\n  Key_Super_R: 0,\n  Key_Menu: 0,\n  Key_Hyper_L: 0,\n  Key_Hyper_R: 0,\n  Key_Help: 6,\n  Key_Direction_L: 0,\n  Key_Direction_R: 0,\n  Key_Space: 32,\n  Key_Any: 32,\n  Key_Exclam: 161,\n  Key_QuoteDbl: 162,\n  Key_NumberSign: 163,\n  Key_Dollar: 164,\n  Key_Percent: 165,\n  Key_Ampersant: 166,\n  Key_Apostrophe: 222,\n  Key_ParenLeft: 168,\n  Key_ParenRight: 169,\n  Key_Asterisk: 170,\n  Key_Plus: 171,\n  Key_Comma: 188,\n  Key_Minus: 173,\n  Key_Period: 190,\n  Key_Slash: 191,\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52,\n  Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n  Key_Colon: 58,\n  Key_Semicolon: 59,\n  Key_Less: 60,\n  Key_Equal: 61,\n  Key_Greater: 62,\n  Key_Question: 63,\n  Key_At: 64,\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71,\n  Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78,\n  Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85,\n  Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n  Key_BracketLeft: 219,\n  Key_Backslash: 220,\n  Key_BracketRight: 221,\n  Key_AsciiCircum: 160,\n  Key_Underscore: 167,\n  Key_QuoteLeft: 0,\n  Key_BraceLeft: 174,\n  Key_Bar: 172,\n  Key_BraceRight: 175,\n  Key_AsciiTilde: 176,\n  Key_Back: 0,\n  Key_Forward: 0,\n  Key_Stop: 0,\n  Key_VolumeDown: 182,\n  Key_VolumeUp: 183,\n  Key_VolumeMute: 181,\n  Key_multiply: 106,\n  Key_add: 107,\n  Key_substract: 109,\n  Key_divide: 111,\n  Key_News: 0,\n  Key_OfficeHome: 0,\n  Key_Option: 0,\n  Key_Paste: 0,\n  Key_Phone: 0,\n  Key_Calendar: 0,\n  Key_Reply: 0,\n  Key_Reload: 0,\n  Key_RotateWindows: 0,\n  Key_RotationPB: 0,\n  Key_RotationKB: 0,\n  Key_Save: 0,\n  Key_Send: 0,\n  Key_Spell: 0,\n  Key_SplitScreen: 0,\n  Key_Support: 0,\n  Key_TaskPane: 0,\n  Key_Terminal: 0,\n  Key_Tools: 0,\n  Key_Travel: 0,\n  Key_Video: 0,\n  Key_Word: 0,\n  Key_Xfer: 0,\n  Key_ZoomIn: 0,\n  Key_ZoomOut: 0,\n  Key_Away: 0,\n  Key_Messenger: 0,\n  Key_WebCam: 0,\n  Key_MailForward: 0,\n  Key_Pictures: 0,\n  Key_Music: 0,\n  Key_Battery: 0,\n  Key_Bluetooth: 0,\n  Key_WLAN: 0,\n  Key_UWB: 0,\n  Key_AudioForward: 0,\n  Key_AudioRepeat: 0,\n  Key_AudioRandomPlay: 0,\n  Key_Subtitle: 0,\n  Key_AudioCycleTrack: 0,\n  Key_Time: 0,\n  Key_Hibernate: 0,\n  Key_View: 0,\n  Key_TopMenu: 0,\n  Key_PowerDown: 0,\n  Key_Suspend: 0,\n  Key_ContrastAdjust: 0,\n  Key_MediaLast: 0,\n  Key_unknown: -1,\n  Key_Call: 0,\n  Key_Camera: 0,\n  Key_CameraFocus: 0,\n  Key_Context1: 0,\n  Key_Context2: 0,\n  Key_Context3: 0,\n  Key_Context4: 0,\n  Key_Flip: 0,\n  Key_Hangup: 0,\n  Key_No: 0,\n  Key_Select: 93,\n  Key_Yes: 0,\n  Key_ToggleCallHangup: 0,\n  Key_VoiceDial: 0,\n  Key_LastNumberRedial: 0,\n  Key_Execute: 43,\n  Key_Printer: 42,\n  Key_Play: 250,\n  Key_Sleep: 95,\n  Key_Zoom: 251,\n  Key_Cancel: 3,\n  // Align\n  AlignLeft: 0x0001,\n  AlignRight: 0x0002,\n  AlignHCenter: 0x0004,\n  AlignJustify: 0x0008,\n  AlignTop: 0x0020,\n  AlignBottom: 0x0040,\n  AlignVCenter: 0x0080,\n  AlignCenter: 0x0084,\n  AlignBaseline: 0x0100,\n  AlignAbsolute: 0x0010,\n  AlignLeading: 0x0001,\n  AlignTrailing: 0x0002,\n  AlignHorizontal_Mask: 0x001f,\n  AlignVertical_Mask: 0x01e0,\n  // Screen\n  PrimaryOrientation: 0,\n  PortraitOrientation: 1,\n  LandscapeOrientation: 2,\n  InvertedPortraitOrientation: 4,\n  InvertedLandscapeOrientation: 8,\n  // CursorShape\n  ArrowCursor: 0,\n  UpArrowCursor: 1,\n  CrossCursor: 2,\n  WaitCursor: 3,\n  IBeamCursor: 4,\n  SizeVerCursor: 5,\n  SizeHorCursor: 6,\n  SizeBDiagCursor: 7,\n  SizeFDiagCursor: 8,\n  SizeAllCursor: 9,\n  BlankCursor: 10,\n  SplitVCursor: 11,\n  SplitHCursor: 12,\n  PointingHandCursor: 13,\n  ForbiddenCursor: 14,\n  WhatsThisCursor: 15,\n  BusyCursor: 16,\n  OpenHandCursor: 17,\n  ClosedHandCursor: 18,\n  DragCopyCursor: 19,\n  DragMoveCursor: 20,\n  DragLinkCursor: 21,\n  LastCursor: 21, //DragLinkCursor,\n  BitmapCursor: 24,\n  CustomCursor: 25,\n  // ScrollBar Policy\n  ScrollBarAsNeeded: 0,\n  ScrollBarAlwaysOff: 1,\n  ScrollBarAlwaysOn: 2\n};\n\nQmlWeb.Qt = Qt;\n\nvar QMLBinding = function () {\n  /**\r\n   * Create QML binding.\r\n   * @param {Variant} val Sourcecode or function representing the binding\r\n   * @param {Array} tree Parser tree of the binding\r\n   * @return {Object} Object representing the binding\r\n   */\n  function QMLBinding(val, tree) {\n    _classCallCheck(this, QMLBinding);\n\n    // this.isFunction states whether the binding is a simple js statement or a\n    // function containing a return statement. We decide this on whether it is a\n    // code block or not. If it is, we require a return statement. If it is a\n    // code block it could though also be a object definition, so we need to\n    // check that as well (it is, if the content is labels).\n    this.isFunction = tree && tree[0] === \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\n    this.src = val;\n    this.compiled = false;\n  }\n\n  _createClass(QMLBinding, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        src: this.src,\n        deps: JSON.stringify(this.deps),\n        tree: JSON.stringify(this.tree)\n      };\n    }\n  }, {\n    key: \"eval\",\n    value: function _eval(object, context, basePath) {\n      QmlWeb.executionContext = context;\n      if (basePath) {\n        QmlWeb.engine.$basePath = basePath;\n      }\n      // .call is needed for `this` support\n      return this.impl.call(object, object, context);\n    }\n\n    /**\r\n     * Compile binding. Afterwards you may call binding.eval to evaluate.\r\n     */\n\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      this.src = this.src.trim();\n      this.impl = QMLBinding.bindSrc(this.src, this.isFunction);\n      this.compiled = true;\n    }\n  }], [{\n    key: \"bindSrc\",\n    value: function bindSrc(src, isFunction) {\n      return new Function(\"__executionObject\", \"__executionContext\", \"\\n      with(QmlWeb) with(__executionContext) with(__executionObject) {\\n        \" + (isFunction ? \"\" : \"return\") + \" \" + src + \"\\n      }\\n    \");\n    }\n  }]);\n\n  return QMLBinding;\n}();\n\nQmlWeb.QMLBinding = QMLBinding;\n\nfunction QMLBoolean(val) {\n  return !!val;\n}\nQMLBoolean.plainType = true;\nQmlWeb.qmlBoolean = QMLBoolean;\n\n// There can only be one running QMLEngine.\n// This variable points to the currently running engine.\nQmlWeb.engine = null;\n\nQmlWeb.useShadowDom = true;\n\nvar geometryProperties = [\"width\", \"height\", \"fill\", \"x\", \"y\", \"left\", \"right\", \"top\", \"bottom\"];\n\n// QML engine. EXPORTED.\n\nvar QMLEngine = function () {\n  function QMLEngine(element) {\n    var _this13 = this;\n\n    _classCallCheck(this, QMLEngine);\n\n    //----------Public Members----------\n\n    this.fps = 60;\n    // Math.floor, causes bugs to timing?\n    this.$interval = Math.floor(1000 / this.fps);\n    this.dom = element || document.body;\n\n    // Target for the DOM children\n    this.domTarget = this.dom;\n    if (QmlWeb.useShadowDom && this.dom.attachShadow) {\n      this.domTarget = this.dom.attachShadow({ mode: \"open\" });\n    }\n\n    // Cached component trees (post-QmlWeb.convertToEngine)\n    this.components = {};\n\n    // Cached parsed JS files (post-QmlWeb.jsparse)\n    this.js = {};\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n    // Module import paths overrides\n    this.userAddedModulePaths = {};\n\n    // Stores data for setImportPathList(), importPathList(), and addImportPath\n    this.userAddedImportPaths = [];\n\n    //----------Private Members---------\n\n    // Ticker resource id and ticker callbacks\n    this._tickers = [];\n    this._lastTick = Date.now();\n\n    // Callbacks for stopping or starting the engine\n    this._whenStop = [];\n    this._whenStart = [];\n\n    // Keyboard management\n    this.$initKeyboard();\n\n    //----------Construct----------\n\n    // No QML stuff should stand out the root element\n    this.dom.style.overflow = \"hidden\";\n\n    // Needed to make absolute positioning work\n    if (!this.dom.style.position) {\n      var style = window.getComputedStyle(this.dom);\n      if (style.getPropertyValue(\"position\") === \"static\") {\n        this.dom.style.position = \"relative\";\n        this.dom.style.top = \"0\";\n        this.dom.style.left = \"0\";\n      }\n    }\n\n    window.addEventListener(\"resize\", function () {\n      return _this13.updateGeometry();\n    });\n  }\n\n  //---------- Public Methods ----------\n\n  _createClass(QMLEngine, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      // we have to call `this.implicitHeight =` and `this.implicitWidth =`\n      // each time the root element changes it's geometry\n      // to reposition child elements of qml scene\n      var width = void 0;\n      var height = void 0;\n      if (this.dom === document.body) {\n        width = window.innerWidth;\n        height = window.innerHeight;\n      } else {\n        var style = window.getComputedStyle(this.dom);\n        width = parseFloat(style.getPropertyValue(\"width\"), 10);\n        height = parseFloat(style.getPropertyValue(\"height\"), 10);\n      }\n      if (width) {\n        this.rootObject.width = width;\n      }\n      if (height) {\n        this.rootObject.height = height;\n      }\n    }\n\n    // Start the engine\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      QmlWeb.engine = this;\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      if (this.operationState !== QMLOperationState.Running) {\n        this.operationState = QMLOperationState.Running;\n        this._tickerId = setInterval(this._tick.bind(this), this.$interval);\n        this._whenStart.forEach(function (callback) {\n          return callback();\n        });\n      }\n    }\n\n    // Stop the engine\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      if (this.operationState === QMLOperationState.Running) {\n        clearInterval(this._tickerId);\n        this.operationState = QMLOperationState.Idle;\n        this._whenStop.forEach(function (callback) {\n          return callback();\n        });\n      }\n    }\n\n    // eslint-disable-next-line max-len\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\r\n     *\r\n     * Removes dot segments in given path component, as described in\r\n     * RFC 3986, section 5.2.4.\r\n     *\r\n     * @param {string} path A non-empty path component.\r\n     * @return {string} Path component with removed dot segments.\r\n     */\n\n  }, {\n    key: \"removeDotSegments\",\n    value: function removeDotSegments(path) {\n      // path.startsWith(\"/\") is not supported in some browsers\n      var leadingSlash = path && path[0] === \"/\";\n      var segments = path.split(\"/\");\n      var out = [];\n\n      for (var pos = 0; pos < segments.length;) {\n        var segment = segments[pos++];\n\n        if (segment === \".\") {\n          if (leadingSlash && pos === segments.length) {\n            out.push(\"\");\n          }\n        } else if (segment === \"..\") {\n          if (out.length > 1 || out.length === 1 && out[0] !== \"\") {\n            out.pop();\n          }\n          if (leadingSlash && pos === segments.length) {\n            out.push(\"\");\n          }\n        } else {\n          out.push(segment);\n          leadingSlash = true;\n        }\n      }\n\n      return out.join(\"/\");\n    }\n  }, {\n    key: \"extractBasePath\",\n    value: function extractBasePath(file) {\n      // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n      var basePath = file.split(/[/\\\\]/);\n      basePath[basePath.length - 1] = \"\";\n      return basePath.join(\"/\");\n    }\n  }, {\n    key: \"extractFileName\",\n    value: function extractFileName(file) {\n      return file.split(/[/\\\\]/).pop();\n    }\n\n    // Load file, parse and construct (.qml or .qml.js)\n\n  }, {\n    key: \"loadFile\",\n    value: function loadFile(file) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      // Create an anchor element to get the absolute path from the DOM\n      if (!this.$basePathA) {\n        this.$basePathA = document.createElement(\"a\");\n      }\n      this.$basePathA.href = this.extractBasePath(file);\n      this.$basePath = this.$basePathA.href;\n      var fileName = this.extractFileName(file);\n      var tree = this.loadComponent(this.$resolvePath(fileName));\n      return this.loadQMLTree(tree, parentComponent, file);\n    }\n\n    // parse and construct qml\n    // file is not required; only for debug purposes\n    // This function is only used by the QmlWeb tests\n\n  }, {\n    key: \"loadQML\",\n    value: function loadQML(src) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      return this.loadQMLTree(QmlWeb.parseQML(src, file), parentComponent, file);\n    }\n  }, {\n    key: \"loadQMLTree\",\n    value: function loadQMLTree(tree) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      QmlWeb.engine = this;\n\n      // Create and initialize objects\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var component = new QMLComponent({\n        object: tree,\n        parent: parentComponent\n      });\n\n      this.loadImports(tree.$imports, undefined, component.importContextId);\n      component.$basePath = this.$basePath;\n      component.$imports = tree.$imports; // for later use\n      component.$file = file; // just for debugging\n\n      this.rootObject = component.$createObject(parentComponent);\n      if (this.rootObject.dom) {\n        this.domTarget.appendChild(this.rootObject.dom);\n      }\n      this.$initializePropertyBindings();\n\n      this.start();\n\n      this.updateGeometry();\n\n      this.callCompletedSignals();\n\n      return component;\n    }\n  }, {\n    key: \"rootContext\",\n    value: function rootContext() {\n      return this.rootObject.$context;\n    }\n\n    // next 3 methods used in Qt.createComponent for qml files lookup\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n  }, {\n    key: \"addImportPath\",\n    value: function addImportPath(dirpath) {\n      this.userAddedImportPaths.push(dirpath);\n    }\n\n    /* Add this dirpath to be checked for components. This is the result of\r\n     * something like:\r\n     *\r\n     * import \"SomeDir/AnotherDirectory\"\r\n     *\r\n     * The importContextId ensures it is only accessible from the file in which\r\n     * it was imported. */\n\n  }, {\n    key: \"addComponentImportPath\",\n    value: function addComponentImportPath(importContextId, dirpath, qualifier) {\n      if (!this.componentImportPaths) {\n        this.componentImportPaths = {};\n      }\n      if (!this.componentImportPaths[importContextId]) {\n        this.componentImportPaths[importContextId] = {};\n      }\n\n      var paths = this.componentImportPaths[importContextId];\n\n      if (qualifier) {\n        if (!paths.qualified) {\n          paths.qualified = {};\n        }\n        paths.qualified[qualifier] = dirpath;\n      } else {\n        if (!paths.unqualified) {\n          paths.unqualified = [];\n        }\n        paths.unqualified.push(dirpath);\n      }\n    }\n  }, {\n    key: \"importSearchPaths\",\n    value: function importSearchPaths(importContextId) {\n      if (!this.componentImportPaths) {\n        return [];\n      }\n      var paths = this.componentImportPaths[importContextId];\n      if (!paths) {\n        return [];\n      }\n      return paths.unqualified || [];\n    }\n  }, {\n    key: \"qualifiedImportPath\",\n    value: function qualifiedImportPath(importContextId, qualifier) {\n      if (!this.componentImportPaths) {\n        return \"\";\n      }\n      var paths = this.componentImportPaths[importContextId];\n      if (!paths || !paths.qualified) {\n        return \"\";\n      }\n      return paths.qualified[qualifier] || \"\";\n    }\n  }, {\n    key: \"setImportPathList\",\n    value: function setImportPathList(arrayOfDirs) {\n      this.userAddedImportPaths = arrayOfDirs;\n    }\n  }, {\n    key: \"importPathList\",\n    value: function importPathList() {\n      return this.userAddedImportPaths;\n    }\n\n    // `addModulePath` defines conrete path for module lookup\n    // e.g. addModulePath(\"QtQuick.Controls\", \"http://example.com/controls\")\n    // will force system to `import QtQuick.Controls` module from\n    // `http://example.com/controls/qmldir`\n\n  }, {\n    key: \"addModulePath\",\n    value: function addModulePath(moduleName, dirPath) {\n      // Keep the mapping. It will be used in loadImports() function.\n      // Remove trailing slash as it required for `readQmlDir`.\n      this.userAddedModulePaths[moduleName] = dirPath.replace(/\\/$/, \"\");\n    }\n  }, {\n    key: \"registerProperty\",\n    value: function registerProperty(obj, propName) {\n      var dependantProperties = [];\n      var value = obj[propName];\n\n      var getter = function getter() {\n        var QMLProperty = QmlWeb.QMLProperty;\n        if (QMLProperty.evaluatingProperty && dependantProperties.indexOf(QMLProperty.evaluatingProperty) === -1) {\n          dependantProperties.push(QMLProperty.evaluatingProperty);\n        }\n        return value;\n      };\n\n      var setter = function setter(newVal) {\n        value = newVal;\n        for (var i in dependantProperties) {\n          dependantProperties[i].update();\n        }\n      };\n\n      QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n    }\n  }, {\n    key: \"loadImports\",\n    value: function loadImports(importsArray) {\n      var currentFileDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;\n      var importContextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      if (!this.qmldirsContents) {\n        this.qmldirsContents = {}; // cache\n\n        // putting initial keys in qmldirsContents - is a hack. We should find a\n        // way to explain to qmlweb, is this built-in module or qmldir-style\n        // module.\n        for (var module in QmlWeb.modules) {\n          if (module !== \"Main\") {\n            this.qmldirsContents[module] = {};\n          }\n        }\n      }\n\n      if (!this.qmldirs) {\n        this.qmldirs = {}; // resulting components lookup table\n      }\n\n      if (!importsArray || importsArray.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < importsArray.length; i++) {\n        this.loadImport(importsArray[i], currentFileDir, importContextId);\n      }\n    }\n  }, {\n    key: \"loadImport\",\n    value: function loadImport(entry, currentFileDir, importContextId) {\n      var name = entry[1];\n\n      // is it url to remote resource\n      var nameIsUrl = name.indexOf(\"//\") === 0 || name.indexOf(\"://\") >= 0;\n      // is it a module name, e.g. QtQuick, QtQuick.Controls, etc\n      var nameIsQualifiedModuleName = entry[4];\n      // is it a js file\n      var nameIsJs = name.slice(-3) === \".js\";\n      // local [relative] dir\n      var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl && !nameIsJs;\n\n      if (nameIsDir) {\n        name = this.$resolvePath(name, currentFileDir);\n        if (name[name.length - 1] === \"/\") {\n          // remove trailing slash as it required for `readQmlDir`\n          name = name.substr(0, name.length - 1);\n        }\n      }\n\n      var content = this.qmldirsContents[name];\n      // check if we have already loaded that qmldir file\n      if (!content) {\n        if (nameIsQualifiedModuleName && this.userAddedModulePaths[name]) {\n          // 1. we have qualified module and user had configured path for that\n          // module with this.addModulePath\n          content = QmlWeb.readQmlDir(this.userAddedModulePaths[name]);\n        } else if (nameIsUrl || nameIsDir) {\n          // 2. direct load\n          // nameIsUrl => url do not need dirs\n          // nameIsDir => already computed full path above\n          content = QmlWeb.readQmlDir(name);\n        } else if (nameIsJs) {\n          // 3. Js file, don't need qmldir\n        } else {\n          // 4. qt-style lookup for qualified module\n          var probableDirs = [currentFileDir].concat(this.importPathList());\n          var diredName = name.replace(/\\./g, \"/\");\n\n          for (var k = 0; k < probableDirs.length; k++) {\n            var file = probableDirs[k] + diredName;\n            content = QmlWeb.readQmlDir(file);\n            if (content) {\n              break;\n            }\n          }\n        }\n        this.qmldirsContents[name] = content;\n      }\n\n      /* If there is no qmldir, add these directories to the list of places to\r\n        * search for components (within this import scope). \"noqmldir\" is\r\n        * inserted into the qmldir cache to avoid future attempts at fetching\r\n        * the qmldir file, but we always need to the call to\r\n        * \"addComponentImportPath\" for these sorts of directories. */\n      if (!content || content === \"noqmldir\") {\n        if (nameIsDir) {\n          if (entry[3]) {\n            /* Use entry[1] directly, as we don't want to include the\r\n              * basePath, otherwise it gets prepended twice in\r\n              * createComponent. */\n            this.addComponentImportPath(importContextId, entry[1] + \"/\", entry[3]);\n          } else {\n            this.addComponentImportPath(importContextId, name + \"/\");\n          }\n        }\n\n        this.qmldirsContents[name] = \"noqmldir\";\n        return;\n      }\n\n      // copy founded externals to global var\n      // TODO actually we have to copy it to current component\n      for (var attrname in content.externals) {\n        this.qmldirs[attrname] = content.externals[attrname];\n      }\n\n      // keep already loaded qmldir files\n      this.qmldirsContents[name] = content;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return {\n        width: this.rootObject.getWidth(),\n        height: this.rootObject.getHeight()\n      };\n    }\n  }, {\n    key: \"focusedElement\",\n    value: function focusedElement() {\n      return this.rootContext().activeFocus;\n    }\n\n    //---------- Private Methods ----------\n\n  }, {\n    key: \"$initKeyboard\",\n    value: function $initKeyboard() {\n      var _this14 = this;\n\n      document.onkeypress = function (e) {\n        var focusedElement = _this14.focusedElement();\n        var event = QmlWeb.eventToKeyboard(e || window.event);\n        var eventName = QmlWeb.keyboardSignals[event.key];\n\n        while (focusedElement && !event.accepted) {\n          var backup = focusedElement.$context.event;\n          focusedElement.$context.event = event;\n          focusedElement.Keys.pressed(event);\n          if (eventName) {\n            focusedElement.Keys[eventName](event);\n          }\n          focusedElement.$context.event = backup;\n          if (event.accepted) {\n            e.preventDefault();\n          } else {\n            focusedElement = focusedElement.$parent;\n          }\n        }\n      };\n\n      document.onkeyup = function (e) {\n        var focusedElement = _this14.focusedElement();\n        var event = QmlWeb.eventToKeyboard(e || window.event);\n\n        while (focusedElement && !event.accepted) {\n          var backup = focusedElement.$context.event;\n          focusedElement.$context.event = event;\n          focusedElement.Keys.released(event);\n          focusedElement.$context.event = backup;\n          if (event.accepted) {\n            e.preventDefault();\n          } else {\n            focusedElement = focusedElement.$parent;\n          }\n        }\n      };\n    }\n  }, {\n    key: \"_tick\",\n    value: function _tick() {\n      var now = Date.now();\n      var elapsed = now - this._lastTick;\n      this._lastTick = now;\n      this._tickers.forEach(function (ticker) {\n        return ticker(now, elapsed);\n      });\n    }\n\n    // Load resolved file, parse and construct as Component (.qml)\n\n  }, {\n    key: \"loadComponent\",\n    value: function loadComponent(file) {\n      if (file in this.components) {\n        return this.components[file];\n      }\n\n      var uri = this.$parseURI(file);\n      if (!uri) {\n        return undefined;\n      }\n\n      var tree = void 0;\n      if (uri.scheme === \"qrc://\") {\n        tree = QmlWeb.qrc[uri.path];\n        if (!tree) {\n          return undefined;\n        }\n        // QmlWeb.qrc contains pre-parsed Component objects, but they still need\n        // convertToEngine called on them.\n        tree = QmlWeb.convertToEngine(tree);\n      } else {\n        var src = QmlWeb.getUrlContents(file, true);\n        if (!src) {\n          console.error(\"QMLEngine.loadComponent: Failed to load:\", file);\n          return undefined;\n        }\n\n        console.log(\"QMLEngine.loadComponent: Loading file:\", file);\n        tree = QmlWeb.parseQML(src, file);\n      }\n\n      if (!tree) {\n        return undefined;\n      }\n\n      if (tree.$children.length !== 1) {\n        console.error(\"QMLEngine.loadComponent: Failed to load:\", file, \": A QML component must only contain one root element!\");\n        return undefined;\n      }\n\n      tree.$file = file;\n      this.components[file] = tree;\n      return tree;\n    }\n\n    // Load resolved file and parse as JavaScript\n\n  }, {\n    key: \"loadJS\",\n    value: function loadJS(file) {\n      if (file in this.js) {\n        return this.js[file];\n      }\n\n      var uri = this.$parseURI(file);\n      if (!uri) {\n        return undefined;\n      }\n\n      var jsData = void 0;\n      if (uri.scheme === \"qrc://\") {\n        jsData = QmlWeb.qrc[uri.path];\n      } else {\n        QmlWeb.loadParser();\n        jsData = QmlWeb.jsparse(QmlWeb.getUrlContents(file));\n      }\n\n      if (!jsData) {\n        return undefined;\n      }\n\n      // Remove any \".pragma\" statements, as they are not valid JavaScript\n      jsData.source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\n\n      var contextSetter = new Function(\"$context\", \"\\n      with(QmlWeb) with ($context) {\\n        \" + jsData.source + \"\\n      }\\n      \" + jsData.exports.map(function (sym) {\n        return \"$context.\" + sym + \" = \" + sym + \";\";\n      }).join(\"\") + \"\\n    \");\n\n      this.js[file] = contextSetter;\n\n      return contextSetter;\n    }\n  }, {\n    key: \"$registerStart\",\n    value: function $registerStart(f) {\n      this._whenStart.push(f);\n    }\n  }, {\n    key: \"$registerStop\",\n    value: function $registerStop(f) {\n      this._whenStop.push(f);\n    }\n  }, {\n    key: \"$addTicker\",\n    value: function $addTicker(t) {\n      this._tickers.push(t);\n    }\n  }, {\n    key: \"$removeTicker\",\n    value: function $removeTicker(t) {\n      var index = this._tickers.indexOf(t);\n      if (index !== -1) {\n        this._tickers.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"$initializePropertyBindings\",\n    value: function $initializePropertyBindings() {\n      // Initialize property bindings\n      // we use `while`, because $initializePropertyBindings may be called\n      // recursive (because of Loader and/or createQmlObject )\n      while (this.bindedProperties.length > 0) {\n        var property = this.bindedProperties.shift();\n\n        if (!property.binding) {\n          // Probably, the binding was overwritten by an explicit value. Ignore.\n          continue;\n        }\n\n        if (property.needsUpdate) {\n          property.update();\n        } else if (geometryProperties.indexOf(property.name) >= 0) {\n          // It is possible that bindings with these names was already evaluated\n          // during eval of other bindings but in that case $updateHGeometry and\n          // $updateVGeometry could be blocked during their eval.\n          // So we call them explicitly, just in case.\n          var obj = property.obj,\n              changed = property.changed;\n\n          if (obj.$updateHGeometry && changed.isConnected(obj, obj.$updateHGeometry)) {\n            obj.$updateHGeometry(property.val, property.val, property.name);\n          }\n          if (obj.$updateVGeometry && changed.isConnected(obj, obj.$updateVGeometry)) {\n            obj.$updateVGeometry(property.val, property.val, property.name);\n          }\n        }\n      }\n\n      this.$initializeAliasSignals();\n    }\n\n    // This parses the full URL into scheme, authority and path\n\n  }, {\n    key: \"$parseURI\",\n    value: function $parseURI(uri) {\n      var match = uri.match(/^([^/]*?:\\/\\/)(.*?)(\\/.*)$/);\n      if (match) {\n        return {\n          scheme: match[1],\n          authority: match[2],\n          path: match[3]\n        };\n      }\n      return undefined;\n    }\n\n    // Return a path to load the file\n\n  }, {\n    key: \"$resolvePath\",\n    value: function $resolvePath(file) {\n      var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;\n\n      // probably, replace :// with :/ ?\n      if (!file || file.indexOf(\"://\") !== -1) {\n        return file;\n      }\n\n      var schemes = [\"data:\", \"blob:\", \"about:\"];\n      for (var i = 0; i < schemes.length; i++) {\n        if (file.lastIndexOf(schemes[i], 0) === 0) {\n          return file;\n        }\n      }\n\n      var basePathURI = this.$parseURI(basePath);\n      if (!basePathURI) {\n        return file;\n      }\n\n      var path = basePathURI.path;\n      if (file.indexOf(\"/\") === 0) {\n        path = file;\n      } else {\n        path = \"\" + path + file;\n      }\n\n      // Remove duplicate slashes and dot segments in the path\n      path = this.removeDotSegments(path.replace(/([^:]\\/)\\/+/g, \"$1\"));\n\n      return \"\" + basePathURI.scheme + basePathURI.authority + path;\n    }\n\n    // Return a DOM-valid path to load the image (fileURL is an already-resolved\n    // URL)\n\n  }, {\n    key: \"$resolveImageURL\",\n    value: function $resolveImageURL(fileURL) {\n      var uri = this.$parseURI(fileURL);\n      // If we are within the resource system, look up a \"real\" path that can be\n      // used by the DOM. If not found, return the path itself without the\n      // \"qrc://\" scheme.\n      if (uri && uri.scheme === \"qrc://\") {\n        return QmlWeb.qrc[uri.path] || uri.path;\n      }\n\n      // Something we can't parse, just pass it through\n      return fileURL;\n    }\n  }, {\n    key: \"$initializeAliasSignals\",\n    value: function $initializeAliasSignals() {\n      // Perform pending operations. Now we use it only to init alias's \"changed\"\n      // handlers, that's why we have such strange function name.\n      while (this.pendingOperations.length > 0) {\n        var op = this.pendingOperations.shift();\n        op[0](op[1], op[2], op[3]);\n      }\n      this.pendingOperations = [];\n    }\n  }, {\n    key: \"callCompletedSignals\",\n    value: function callCompletedSignals() {\n      // the while loop is better than for..in loop, because completedSignals\n      // array might change dynamically when some completed signal handlers will\n      // create objects dynamically via createQmlObject or Loader\n      while (this.completedSignals.length > 0) {\n        var handler = this.completedSignals.shift();\n        handler();\n      }\n    }\n  }]);\n\n  return QMLEngine;\n}();\n\nQmlWeb.QMLEngine = QMLEngine;\n\nfunction QMLInteger(val) {\n  return val | 0;\n}\nQMLInteger.plainType = true;\nQmlWeb.qmlInteger = QMLInteger;\n\nfunction QMLList(meta) {\n  var list = [];\n  if (meta.object instanceof Array) {\n    for (var i in meta.object) {\n      list.push(QmlWeb.construct({\n        object: meta.object[i],\n        parent: meta.parent,\n        context: meta.context\n      }));\n    }\n  } else if (meta.object instanceof QmlWeb.QMLMetaElement) {\n    list.push(QmlWeb.construct({\n      object: meta.object,\n      parent: meta.parent,\n      context: meta.context\n    }));\n  }\n\n  return list;\n}\nQMLList.plainType = true;\nQmlWeb.qmlList = QMLList;\n\nfunction QMLNumber(val) {\n  return +val;\n}\nQMLNumber.plainType = true;\nQmlWeb.qmlNumber = QMLNumber;\n\nvar QMLOperationState = {\n  Idle: 1,\n  Init: 2,\n  Running: 3\n};\n\nQmlWeb.QMLOperationState = QMLOperationState;\n\nvar QMLProperty = function () {\n  function QMLProperty(type, obj, name) {\n    _classCallCheck(this, QMLProperty);\n\n    this.obj = obj;\n    this.name = name;\n    this.changed = QmlWeb.Signal.signal([], { obj: obj });\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n    this.needsUpdate = true;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this\n    // object.\n    this.$tidyupList = [];\n  }\n\n  // Called by update and set to actually set this.val, performing any type\n  // conversion required.\n\n\n  _createClass(QMLProperty, [{\n    key: \"$setVal\",\n    value: function $setVal(val, componentScope) {\n      var _this15 = this;\n\n      var constructors = QmlWeb.constructors;\n      if (constructors[this.type] === QmlWeb.qmlList) {\n        this.val = QmlWeb.qmlList({\n          object: val,\n          parent: this.obj,\n          context: componentScope\n        });\n      } else if (val instanceof QmlWeb.QMLMetaElement) {\n        var _QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n        if (constructors[val.$class] === _QMLComponent || constructors[this.type] === _QMLComponent) {\n          this.val = new _QMLComponent({\n            object: val,\n            parent: this.obj,\n            context: componentScope\n          });\n          /* $basePath must be set here so that Components that are assigned to\r\n           * properties (e.g. Repeater delegates) can properly resolve child\r\n           * Components that live in the same directory in\r\n           * Component.createObject. */\n          this.val.$basePath = componentScope.$basePath;\n        } else {\n          this.val = QmlWeb.construct({\n            object: val,\n            parent: this.obj,\n            context: componentScope\n          });\n        }\n      } else if (!constructors[this.type]) {\n        this.val = val;\n      } else if (constructors[this.type].requireParent) {\n        this.val = new constructors[this.type](this.obj, val);\n      } else if (val === undefined && constructors[this.type].nonNullableType) {\n        this.val = new constructors[this.type]();\n      } else if (constructors[this.type].requireConstructor) {\n        this.val = new constructors[this.type](val);\n      } else if (val instanceof Object || val === undefined || val === null) {\n        this.val = val;\n      } else if (constructors[this.type].plainType) {\n        this.val = constructors[this.type](val);\n      } else {\n        this.val = new constructors[this.type](val);\n      }\n      if (this.val && this.val.$changed) {\n        this.val.$changed.connect(function () {\n          var oldVal = _this15.val; // TODO\n          _this15.changed(_this15.val, oldVal, _this15.name);\n        });\n      } else if (this.val && this.val.$properties) {\n        Object.keys(this.val.$properties).forEach(function (pname) {\n          var prop = _this15.val.$properties[pname];\n          if (!prop || !prop.connect) return;\n          // TODO: oldVal\n          prop.connect(function () {\n            return _this15.changed(_this15.val, _this15.val, _this15.name);\n          });\n        });\n      }\n    }\n\n    // Updater recalculates the value of a property if one of the dependencies\n    // changed\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.needsUpdate = false;\n\n      if (!this.binding) {\n        return;\n      }\n\n      var oldVal = this.val;\n\n      try {\n        QMLProperty.pushEvaluatingProperty(this);\n        if (!this.binding.compiled) {\n          this.binding.compile();\n        }\n        this.$setVal(this.binding.eval(this.objectScope, this.componentScope, this.componentScopeBasePath), this.componentScope);\n      } catch (e) {\n        console.log(\"QMLProperty.update binding error:\", e, Function.prototype.toString.call(this.binding.eval));\n      } finally {\n        QMLProperty.popEvaluatingProperty();\n      }\n\n      if (this.animation) {\n        this.animation.$actions = [{\n          target: this.animation.target || this.obj,\n          property: this.animation.property || this.name,\n          from: this.animation.from || oldVal,\n          to: this.animation.to || this.val\n        }];\n        this.animation.restart();\n      }\n\n      if (this.val !== oldVal) {\n        this.changed(this.val, oldVal, this.name);\n      }\n    }\n\n    // Define getter\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      //if (this.needsUpdate && !QMLProperty.evaluatingPropertyPaused) {\n      if (this.needsUpdate && QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n        this.update();\n      }\n\n      // If this call to the getter is due to a property that is dependant on this\n      // one, we need it to take track of changes\n      if (QMLProperty.evaluatingProperty) {\n        //console.log(this,QMLProperty.evaluatingPropertyStack.slice(0),this.val);\n        this.changed.connect(QMLProperty.evaluatingProperty, QMLProperty.prototype.update, QmlWeb.Signal.UniqueConnection);\n      }\n\n      return this.val;\n    }\n    // Define setter\n\n  }, {\n    key: \"set\",\n    value: function set(newVal, reason, objectScope, componentScope) {\n      var oldVal = this.val;\n\n      var val = newVal;\n      if (val instanceof QmlWeb.QMLBinding) {\n        if (!objectScope || !componentScope) {\n          throw new Error(\"Internal error: binding assigned without scope\");\n        }\n        this.binding = val;\n        this.objectScope = objectScope;\n        this.componentScope = componentScope;\n        this.componentScopeBasePath = componentScope.$basePath;\n\n        if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n          if (!val.compiled) {\n            val.compile();\n          }\n          try {\n            QMLProperty.pushEvaluatingProperty(this);\n            this.needsUpdate = false;\n            val = this.binding.eval(objectScope, componentScope, this.componentScopeBasePath);\n          } finally {\n            QMLProperty.popEvaluatingProperty();\n          }\n        } else {\n          QmlWeb.engine.bindedProperties.push(this);\n          return;\n        }\n      } else {\n        if (reason !== QMLProperty.ReasonAnimation) {\n          this.binding = null;\n        }\n        if (val instanceof Array) {\n          val = val.slice(); // Copies the array\n        }\n      }\n\n      if (reason === QMLProperty.ReasonInit && typeof val === \"undefined\") {\n        if (QMLProperty.typeInitialValues.hasOwnProperty(this.type)) {\n          val = QMLProperty.typeInitialValues[this.type];\n        }\n      }\n\n      this.$setVal(val, componentScope);\n\n      if (this.val !== oldVal) {\n        if (this.animation && reason === QMLProperty.ReasonUser) {\n          this.animation.running = false;\n          this.animation.$actions = [{\n            target: this.animation.target || this.obj,\n            property: this.animation.property || this.name,\n            from: this.animation.from || oldVal,\n            to: this.animation.to || this.val\n          }];\n          this.animation.running = true;\n        }\n        if (this.obj.$syncPropertyToRemote instanceof Function && reason === QMLProperty.ReasonUser) {\n          // is a remote object from e.g. a QWebChannel\n          this.obj.$syncPropertyToRemote(this.name, val);\n        } else {\n          this.changed(this.val, oldVal, this.name);\n        }\n      }\n    }\n  }], [{\n    key: \"pushEvalStack\",\n    value: function pushEvalStack() {\n      QMLProperty.evaluatingPropertyStackOfStacks.push(QMLProperty.evaluatingPropertyStack);\n      QMLProperty.evaluatingPropertyStack = [];\n      QMLProperty.evaluatingProperty = undefined;\n      //  console.log(\"evaluatingProperty=>undefined due to push stck \");\n    }\n  }, {\n    key: \"popEvalStack\",\n    value: function popEvalStack() {\n      QMLProperty.evaluatingPropertyStack = QMLProperty.evaluatingPropertyStackOfStacks.pop() || [];\n      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];\n    }\n  }, {\n    key: \"pushEvaluatingProperty\",\n    value: function pushEvaluatingProperty(prop) {\n      // TODO say warnings if already on stack. This means binding loop.\n      // BTW actually we do not loop because needsUpdate flag is reset before\n      // entering update again.\n      if (QMLProperty.evaluatingPropertyStack.indexOf(prop) >= 0) {\n        console.error(\"Property binding loop detected for property\", prop.name, [prop].slice(0));\n      }\n      QMLProperty.evaluatingProperty = prop;\n      QMLProperty.evaluatingPropertyStack.push(prop); //keep stack of props\n    }\n  }, {\n    key: \"popEvaluatingProperty\",\n    value: function popEvaluatingProperty() {\n      QMLProperty.evaluatingPropertyStack.pop();\n      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];\n    }\n  }]);\n\n  return QMLProperty;\n}();\n\n// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\n\n\nQMLProperty.evaluatingProperty = undefined;\nQMLProperty.evaluatingPropertyPaused = false;\nQMLProperty.evaluatingPropertyStack = [];\nQMLProperty.evaluatingPropertyStackOfStacks = [];\n\nQMLProperty.typeInitialValues = {\n  int: 0,\n  real: 0,\n  double: 0,\n  string: \"\",\n  bool: false,\n  list: [],\n  enum: 0,\n  url: \"\"\n};\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\nQmlWeb.QMLProperty = QMLProperty;\n\nfunction QMLString(val) {\n  return \"\" + val;\n}\nQMLString.plainType = true;\nQmlWeb.qmlString = QMLString;\n\nfunction QMLUrl(val) {\n  return QmlWeb.engine.$resolvePath(\"\" + val);\n}\nQMLUrl.plainType = true;\nQmlWeb.qmlUrl = QMLUrl;\n\nfunction QMLVariant(val) {\n  return val;\n}\nQMLVariant.plainType = true;\nQmlWeb.qmlVariant = QMLVariant;\n\nwindow.addEventListener(\"load\", function () {\n  var metaTags = document.getElementsByTagName(\"body\");\n  for (var i = 0; i < metaTags.length; ++i) {\n    var metaTag = metaTags[i];\n    var source = metaTag.getAttribute(\"data-qml\");\n    if (source) {\n      QmlWeb.qmlEngine = new QmlWeb.QMLEngine();\n      QmlWeb.qmlEngine.loadFile(source);\n      QmlWeb.qmlEngine.start();\n      break;\n    }\n  }\n});\n\nvar anchorNames = [\"left\", \"right\", \"top\", \"bottom\", \"verticalCenter\", \"horizontalCenter\"];\n\nvar ignoreProps = [\"x\", \"y\", \"z\", \"scale\", \"rotation\", \"implicitWidth\", \"implicitHeight\"];\n\nfunction getProperties(file) {\n  // TODO: implement a cleaner way\n\n  var div = document.createElement(\"div\");\n  var engine = new QmlWeb.QMLEngine(div);\n  engine.loadFile(file);\n\n  var qml = engine.rootObject;\n  var properties = Object.keys(qml.$properties).filter(function (name) {\n    // Invalid names\n    if (!name.match(/^[a-z]+$/i) || name === \"is\") return false;\n\n    // We don't need anchors\n    if (anchorNames.indexOf(name) !== -1) return false;\n\n    // These properties are not supported in a good way on top-level items\n    if (ignoreProps.indexOf(name) !== -1) return false;\n\n    var type = qml.$properties[name].type;\n    return [\"real\", \"color\", \"int\", \"bool\", \"string\"].indexOf(type) !== -1;\n  });\n\n  engine.stop();\n  return properties;\n}\n\nfunction registerElement(name, file) {\n  // Delay until the document is fully loaded\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      registerElement(name, file);\n    });\n    return;\n  }\n\n  // Bail out if Custom Elements v1 are not present\n  if (!window.customElements) {\n    throw new Error(\"window.customElements are not supported. Consider installing a polyfill.\");\n  }\n\n  // We need attributes list at this point, those form a static property\n  var properties = getProperties(file);\n  var attributes = properties.map(function (pname) {\n    return pname.toLowerCase();\n  });\n  var attr2prop = properties.reduce(function (map, pname) {\n    map[pname.toLowerCase()] = pname;\n    return map;\n  }, {});\n\n  var QmlElement = function (_HTMLElement) {\n    _inherits(QmlElement, _HTMLElement);\n\n    function QmlElement() {\n      _classCallCheck(this, QmlElement);\n\n      return _possibleConstructorReturn(this, (QmlElement.__proto__ || Object.getPrototypeOf(QmlElement)).apply(this, arguments));\n    }\n\n    _createClass(QmlElement, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        var _this17 = this;\n\n        // Default wrapper display is inline-block to support native width/height\n        var computedStyle = window.getComputedStyle(this);\n        if (computedStyle.display === \"inline\") {\n          this.style.display = \"inline-block\";\n        }\n\n        var engine = this.engine = new QmlWeb.QMLEngine(this);\n        engine.loadFile(file);\n        engine.start();\n        var qml = this.qml = engine.rootObject;\n\n        // Bind attributes\n        attributes.forEach(function (attr) {\n          var pname = attr2prop[attr] || attr;\n          var val = _this17.getAttribute(attr);\n          if (typeof val === \"string\") {\n            qml[pname] = val;\n          }\n          _this17.applyAttribute(attr);\n          Object.defineProperty(_this17, attr, {\n            get: function get() {\n              return this.qml[pname];\n            },\n            set: function set(value) {\n              this.qml[pname] = value;\n              this.applyAttribute(attr);\n            }\n          });\n          qml.$properties[pname].changed.connect(function () {\n            return _this17.applyAttribute(attr);\n          });\n        });\n\n        // Set and update wrapper width/height\n        this.style.width = qml.width + \"px\";\n        this.style.height = qml.height + \"px\";\n        qml.$properties.width.changed.connect(function (width) {\n          _this17.style.width = width + \"px\";\n        });\n        qml.$properties.height.changed.connect(function (height) {\n          _this17.style.height = height + \"px\";\n        });\n      }\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(attr, oldValue, newValue) {\n        if (!this.qml) return;\n        var pname = attr2prop[attr] || attr;\n        var prop = this.qml.$properties[pname];\n        if (!prop) return;\n        switch (prop.type) {\n          case \"bool\":\n            this.qml[pname] = typeof newValue === \"string\";\n            break;\n          default:\n            this.qml[pname] = newValue;\n        }\n      }\n    }, {\n      key: \"applyAttribute\",\n      value: function applyAttribute(attr) {\n        var pname = attr2prop[attr] || attr;\n        var prop = this.qml.$properties[pname];\n        if (!prop) {\n          this.deleteAttribute(attr);\n          return;\n        }\n        var value = this.qml[pname];\n        switch (prop.type) {\n          case \"bool\":\n            if (value) {\n              this.setAttribute(attr, \"\");\n            } else {\n              this.removeAttribute(attr);\n            }\n            break;\n          default:\n            this.setAttribute(attr, this.qml[pname]);\n        }\n      }\n    }], [{\n      key: \"observedAttributes\",\n      get: function get() {\n        return attributes;\n      }\n    }]);\n\n    return QmlElement;\n  }(HTMLElement);\n\n  window.customElements.define(name, QmlElement);\n}\n\nQmlWeb.registerElement = registerElement;\n\nvar Easing = {\n  Linear: 1,\n  InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,\n  InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,\n  InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,\n  InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,\n  InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,\n  InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,\n  InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,\n  InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,\n  InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,\n  InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41\n};\n\n// eslint-disable-next-line complexity\nQmlWeb.$ease = function (type, period, amplitude, overshoot, t) {\n  switch (type) {\n    // Linear\n    case Easing.Linear:\n      return t;\n\n    // Quad\n    case Easing.InQuad:\n      return Math.pow(t, 2);\n    case Easing.OutQuad:\n      return -Math.pow(t - 1, 2) + 1;\n    case Easing.InOutQuad:\n      if (t < 0.5) {\n        return 2 * Math.pow(t, 2);\n      }\n      return -2 * Math.pow(t - 1, 2) + 1;\n    case Easing.OutInQuad:\n      if (t < 0.5) {\n        return -2 * Math.pow(t - 0.5, 2) + 0.5;\n      }\n      return 2 * Math.pow(t - 0.5, 2) + 0.5;\n\n    // Cubic\n    case Easing.InCubic:\n      return Math.pow(t, 3);\n    case Easing.OutCubic:\n      return Math.pow(t - 1, 3) + 1;\n    case Easing.InOutCubic:\n      if (t < 0.5) {\n        return 4 * Math.pow(t, 3);\n      }\n      return 4 * Math.pow(t - 1, 3) + 1;\n    case Easing.OutInCubic:\n      return 4 * Math.pow(t - 0.5, 3) + 0.5;\n\n    // Quart\n    case Easing.InQuart:\n      return Math.pow(t, 4);\n    case Easing.OutQuart:\n      return -Math.pow(t - 1, 4) + 1;\n    case Easing.InOutQuart:\n      if (t < 0.5) {\n        return 8 * Math.pow(t, 4);\n      }\n      return -8 * Math.pow(t - 1, 4) + 1;\n    case Easing.OutInQuart:\n      if (t < 0.5) {\n        return -8 * Math.pow(t - 0.5, 4) + 0.5;\n      }\n      return 8 * Math.pow(t - 0.5, 4) + 0.5;\n\n    // Quint\n    case Easing.InQuint:\n      return Math.pow(t, 5);\n    case Easing.OutQuint:\n      return Math.pow(t - 1, 5) + 1;\n    case Easing.InOutQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t, 5);\n      }\n      return 16 * Math.pow(t - 1, 5) + 1;\n    case Easing.OutInQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t - 0.5, 5) + 0.5;\n      }\n      return 16 * Math.pow(t - 0.5, 5) + 0.5;\n\n    // Sine\n    case Easing.InSine:\n      return -Math.cos(0.5 * Math.PI * t) + 1;\n    case Easing.OutSine:\n      return Math.sin(0.5 * Math.PI * t);\n    case Easing.InOutSine:\n      return -0.5 * Math.cos(Math.PI * t) + 0.5;\n    case Easing.OutInSine:\n      if (t < 0.5) {\n        return 0.5 * Math.sin(Math.PI * t);\n      }\n      return -0.5 * Math.sin(Math.PI * t) + 1;\n\n    // Expo\n    case Easing.InExpo:\n      return 1 / 1023 * (Math.pow(2, 10 * t) - 1);\n    case Easing.OutExpo:\n      return -1024 / 1023 * (Math.pow(2, -10 * t) - 1);\n    case Easing.InOutExpo:\n      if (t < 0.5) {\n        return 1 / 62 * (Math.pow(2, 10 * t) - 1);\n      }\n      return -512 / 31 * Math.pow(2, -10 * t) + 63 / 62;\n    case Easing.OutInExpo:\n      if (t < 0.5) {\n        return -16 / 31 * (Math.pow(2, -10 * t) - 1);\n      }\n      return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;\n\n    // Circ\n    case Easing.InCirc:\n      return 1 - Math.sqrt(1 - t * t);\n    case Easing.OutCirc:\n      return Math.sqrt(1 - Math.pow(t - 1, 2));\n    case Easing.InOutCirc:\n      if (t < 0.5) {\n        return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));\n      }\n      return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n    case Easing.OutInCirc:\n      if (t < 0.5) {\n        return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n      }\n      return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n\n    // Elastic\n    case Easing.InElastic:\n      return -amplitude * Math.pow(2, 10 * t - 10) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude));\n    case Easing.OutElastic:\n      return amplitude * Math.pow(2, -10 * t) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude)) + 1;\n    case Easing.InOutElastic:\n      if (t < 0.5) {\n        return -0.5 * amplitude * Math.pow(2, 20 * t - 10) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude));\n      }\n      return -0.5 * amplitude * Math.pow(2, -20 * t + 10) * Math.sin(4 * t * Math.PI / period + Math.asin(1 / amplitude)) + 1;\n    case Easing.OutInElastic:\n      if (t < 0.5) {\n        return 0.5 * amplitude * Math.pow(2, -20 * t) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n      }\n      return -0.5 * amplitude * Math.pow(2, 20 * t - 20) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n\n    // Back\n    case Easing.InBack:\n      return (overshoot + 1) * Math.pow(t, 3) - overshoot * Math.pow(t, 2);\n    case Easing.OutBack:\n      return (overshoot + 1) * Math.pow(t - 1, 3) + overshoot * Math.pow(t - 1, 2) + 1;\n    case Easing.InOutBack:\n      if (t < 0.5) {\n        return 4 * (overshoot + 1) * Math.pow(t, 3) - 2 * overshoot * Math.pow(t, 2);\n      }\n      return 0.5 * (overshoot + 1) * Math.pow(2 * t - 2, 3) + overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;\n    case Easing.OutInBack:\n      if (t < 0.5) {\n        return 0.5 * ((overshoot + 1) * Math.pow(2 * t - 1, 3) + overshoot * Math.pow(2 * t - 1, 2) + 1);\n      }\n      return 4 * (overshoot + 1) * Math.pow(t - 0.5, 3) - 2 * overshoot * Math.pow(t - 0.5, 2) + 0.5;\n    // Bounce\n    case Easing.InBounce:\n      if (t < 1 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 1 / 11 * t);\n      } else if (t < 3 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 4 / 11 * t + 3 / 121);\n      } else if (t < 7 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 10 / 11 * t + 21 / 121);\n      }\n      return -(121 / 16) * (t * t - 2 * t + 1) + 1;\n    case Easing.OutBounce:\n      if (t < 4 / 11) {\n        return 121 / 16 * t * t;\n      } else if (t < 8 / 11) {\n        return amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;\n      } else if (t < 10 / 11) {\n        return amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;\n      }\n      return amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;\n    case Easing.InOutBounce:\n      if (t < 1 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 1 / 22 * t);\n      } else if (t < 3 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 2 / 11 * t + 3 / 484);\n      } else if (t < 7 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 5 / 11 * t + 21 / 484);\n      } else if (t < 11 / 22) {\n        return -121 / 8 * (t * t - t + 0.25) + 0.5;\n      } else if (t < 15 / 22) {\n        return 121 / 8 * (t * t - t) + 137 / 32;\n      } else if (t < 19 / 22) {\n        return amplitude * 121 / 8 * (t * t - 17 / 11 * t + 285 / 484) + 1;\n      } else if (t < 21 / 22) {\n        return amplitude * 121 / 8 * (t * t - 20 / 11 * t + 399 / 484) + 1;\n      }\n      return amplitude * 121 / 8 * (t * t - 43 / 22 * t + 21 / 22) + 1;\n    case Easing.OutInBounce:\n      if (t < 4 / 22) {\n        return 121 / 8 * t * t;\n      } else if (t < 8 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 6 / 11 * t + 8 / 121) + 0.5;\n      } else if (t < 10 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 9 / 11 * t + 20 / 121) + 0.5;\n      } else if (t < 11 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 21 / 22 * t + 5 / 22) + 0.5;\n      } else if (t < 12 / 22) {\n        return amplitude * 121 / 8 * (t * t - 23 / 22 * t + 3 / 11) + 0.5;\n      } else if (t < 14 / 22) {\n        return amplitude * 121 / 8 * (t * t - 13 / 11 * t + 42 / 121) + 0.5;\n      } else if (t < 18 / 22) {\n        return amplitude * 121 / 8 * (t * t - 16 / 11 * t + 63 / 121) + 0.5;\n      }\n      return -121 / 8 * (t * t - 2 * t + 117 / 121) + 0.5;\n\n    // Default\n    default:\n      console.error(\"Unsupported animation type: \", type);\n      return t;\n  }\n};\n\nQmlWeb.Easing = Easing;\n\n/* eslint accessor-pairs: 0 */\n\nfunction setupGetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    get: func,\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction setupSetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    set: func,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n  Object.defineProperty(obj, propName, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nQmlWeb.setupGetter = setupGetter;\nQmlWeb.setupSetter = setupSetter;\nQmlWeb.setupGetterSetter = setupGetterSetter;\n\nvar QmlWebHelpers = function () {\n  function QmlWebHelpers() {\n    _classCallCheck(this, QmlWebHelpers);\n  }\n\n  _createClass(QmlWebHelpers, null, [{\n    key: \"arrayFindIndex\",\n    value: function arrayFindIndex(array, callback) {\n      // Note: does not support thisArg, we don't need that\n      if (!Array.prototype.findIndex) {\n        for (var key in array) {\n          if (callback(array[key], key, array)) {\n            return key;\n          }\n        }\n        return -1;\n      }\n      return Array.prototype.findIndex.call(array, callback);\n    }\n  }, {\n    key: \"mergeObjects\",\n    value: function mergeObjects() {\n      var merged = {};\n\n      for (var _len23 = arguments.length, args = Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n\n      for (var i in args) {\n        var arg = args[i];\n        if (!arg) {\n          continue;\n        }\n        for (var key in arg) {\n          merged[key] = arg[key];\n        }\n      }\n      return merged;\n    }\n  }]);\n\n  return QmlWebHelpers;\n}();\n\nQmlWeb.helpers = QmlWebHelpers;\n\n/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\r\n                                                         import implementation.\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\n/**\r\n * Get URL contents.\r\n * @param url {String} Url to fetch.\r\n * @param skipExceptions {bool} when turned on, ignore exeptions and return\r\n *        false. This feature is used by readQmlDir.\r\n * @private\r\n * @return {mixed} String of contents or false in errors.\r\n */\nfunction getUrlContents(url, skipExceptions) {\n  if (typeof QmlWeb.urlContentCache[url] === \"undefined\") {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n\n    if (skipExceptions) {\n      try {\n        xhr.send(null);\n      } catch (e) {\n        return false;\n      }\n      // it is OK to not have logging here, because DeveloperTools already will\n      // have red log record\n    } else {\n      xhr.send(null);\n    }\n\n    if (xhr.status !== 200 && xhr.status !== 0) {\n      // 0 if accessing with file://\n      console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\n      return false;\n    }\n    QmlWeb.urlContentCache[url] = xhr.responseText;\n  }\n  return QmlWeb.urlContentCache[url];\n}\nif (typeof QmlWeb.urlContentCache === \"undefined\") {\n  QmlWeb.urlContentCache = {};\n}\n\n/**\r\n * Read qmldir spec file at directory.\r\n * @param url Url of the directory\r\n * @return {Object} Object, where .internals lists qmldir internal references\r\n *                          and .externals lists qmldir external references.\r\n */\n\n/*  Note on how importing works.\r\n\r\nparseQML gives us `tree.$imports` variable, which contains information from\r\n`import` statements.\r\n\r\nAfter each call to parseQML, we call engine.loadImports(tree.$imports).\r\nIt in turn invokes readQmlDir() calls for each import, with respect to current\r\ncomponent base path and engine.importPathList().\r\n\r\nWe keep all component names from all qmldir files in global variable\r\n`engine.qmldir`.\r\n\r\nIn construct() function, we use `engine.qmldir` for component url lookup.\r\n\r\nReference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html\r\nAlso please look at notes and TODO's in qtcore.js::loadImports() and\r\nqtcore.js::construct() methods.\r\n*/\n\nfunction readQmlDir(url) {\n  // in case 'url' is empty, do not attach \"/\"\n  // Q1: when this happen?\n  var qmldirFileUrl = url.length > 0 ? url + \"/qmldir\" : \"qmldir\";\n\n  var parsedUrl = QmlWeb.engine.$parseURI(qmldirFileUrl);\n\n  var qmldir = void 0;\n  if (parsedUrl.scheme === \"qrc://\") {\n    qmldir = QmlWeb.qrc[parsedUrl.path];\n  } else {\n    qmldir = getUrlContents(qmldirFileUrl, true) || undefined;\n  }\n\n  var internals = {};\n  var externals = {};\n\n  if (qmldir === undefined) {\n    return false;\n  }\n\n  // we have to check for \"://\"\n  // In that case, item path is meant to be absolute, and we have no need to\n  // prefix it with base url\n  function makeurl(path) {\n    if (path.indexOf(\"://\") > 0) {\n      return path;\n    }\n    return url + \"/\" + path;\n  }\n\n  var lines = qmldir.split(/\\r?\\n/);\n  for (var i = 0; i < lines.length; i++) {\n    // trim\n    var line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n    if (!line.length || line[0] === \"#\") {\n      // Empty line or comment\n      continue;\n    }\n    var match = line.split(/\\s+/);\n    if (match.length === 2 || match.length === 3) {\n      if (match[0] === \"plugin\") {\n        console.log(url + \": qmldir plugins are not supported!\");\n      } else if (match[0] === \"internal\") {\n        internals[match[1]] = { url: makeurl(match[2]) };\n      } else if (match.length === 2) {\n        externals[match[0]] = { url: makeurl(match[1]) };\n      } else {\n        externals[match[0]] = { url: makeurl(match[2]), version: match[1] };\n      }\n    } else {\n      console.log(url + \": unmatched: \" + line);\n    }\n  }\n  return { internals: internals, externals: externals };\n}\n\nQmlWeb.getUrlContents = getUrlContents;\nQmlWeb.readQmlDir = readQmlDir;\n\nfunction importJavascriptInContext(contextSetter, $context) {\n  /* Set the QmlWeb.executionContext so that any internal calls to Qt.include\r\n   * will have the proper context */\n  var oldExecutionContext = QmlWeb.executionContext;\n  QmlWeb.executionContext = $context;\n  contextSetter($context);\n  QmlWeb.executionContext = oldExecutionContext;\n}\n\nQmlWeb.importJavascriptInContext = importJavascriptInContext;\n\nQmlWeb.keyCodeToQt = function (e) {\n  var Qt = QmlWeb.Qt;\n  e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n  if (e.keyCode === Qt.Key_Tab && e.shiftKey) {\n    return Qt.Key_Backtab;\n  }\n  if (e.keyCode >= 97 && e.keyCode <= 122) {\n    return e.keyCode - (97 - Qt.Key_A);\n  }\n  return e.keyCode;\n};\n\nQmlWeb.eventToKeyboard = function (e) {\n  return {\n    accepted: false,\n    count: 1,\n    isAutoRepeat: false,\n    key: QmlWeb.keyCodeToQt(e),\n    modifiers: e.ctrlKey * QmlWeb.Qt.CtrlModifier | e.altKey * QmlWeb.Qt.AltModifier | e.shiftKey * QmlWeb.Qt.ShiftModifier | e.metaKey * QmlWeb.Qt.MetaModifier | e.keypad * QmlWeb.Qt.KeypadModifier,\n    text: String.fromCharCode(e.charCode)\n  };\n};\n\nQmlWeb.keyboardSignals = {};\n[\"asterisk\", \"back\", \"backtab\", \"call\", \"cancel\", \"delete\", \"escape\", \"flip\", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"hangup\", \"menu\", \"no\", \"return\", \"select\", \"space\", \"tab\", \"volumeDown\", \"volumeUp\", \"yes\", \"up\", \"right\", \"down\", \"left\"].forEach(function (key) {\n  var name = key.toString();\n  var qtName = \"Key_\" + name[0].toUpperCase() + name.slice(1);\n  var prefix = typeof key === \"number\" ? \"digit\" : \"\";\n  QmlWeb.keyboardSignals[QmlWeb.Qt[qtName]] = \"\" + prefix + name + \"Pressed\";\n});\n\nQmlWeb.executionContext = null;\n\nvar modules = {\n  Main: {\n    int: QmlWeb.qmlInteger,\n    real: QmlWeb.qmlNumber,\n    double: QmlWeb.qmlNumber,\n    string: QmlWeb.qmlString,\n    bool: QmlWeb.qmlBoolean,\n    list: QmlWeb.qmlList,\n    color: QmlWeb.QColor,\n    font: QmlWeb.QFont,\n    size: QmlWeb.QSizeF,\n    point: QmlWeb.QPointF,\n    rect: QmlWeb.QRectF,\n    vector2d: QmlWeb.QVector2D,\n    vector3d: QmlWeb.QVector3D,\n    vector4d: QmlWeb.QVector4D,\n    quaternion: QmlWeb.QQuaternion,\n    matrix4x4: QmlWeb.QMatrix4x4,\n    enum: QmlWeb.qmlNumber,\n    url: QmlWeb.qmlUrl,\n    variant: QmlWeb.qmlVariant,\n    var: QmlWeb.qmlVariant\n  }\n};\n\n// All object constructors\nQmlWeb.constructors = modules.Main;\n\nvar dependants = {};\n\nvar perImportContextConstructors = {};\nvar importContextIds = 0;\n\n// Helper. Adds a type to the constructor list\nfunction registerGlobalQmlType(name, type) {\n  QmlWeb[type.name] = type;\n  QmlWeb.constructors[name] = type;\n  modules.Main[name] = type;\n}\n\n// Helper. Register a type to a module\nfunction registerQmlType(options, constructor) {\n  if (constructor !== undefined) {\n    options.constructor = constructor;\n  }\n\n  if (typeof options.baseClass === \"string\") {\n    // TODO: Does not support version specification (yet?)\n    var baseModule = void 0;\n    var baseName = void 0;\n    var dot = options.baseClass.lastIndexOf(\".\");\n    if (dot === -1) {\n      baseModule = options.module;\n      baseName = options.baseClass;\n    } else {\n      baseModule = options.baseClass.substring(0, dot);\n      baseName = options.baseClass.substring(dot + 1);\n    }\n    var found = (modules[baseModule] || []).filter(function (descr) {\n      return descr.name === baseName;\n    });\n    if (found.length > 0) {\n      // Ok, we found our base class\n      options.baseClass = found[0].constructor;\n    } else {\n      // Base class not found, delay the loading\n      var baseId = [baseModule, baseName].join(\".\");\n      if (!dependants.hasOwnProperty(baseId)) {\n        dependants[baseId] = [];\n      }\n      dependants[baseId].push(options);\n      return;\n    }\n  }\n\n  var descriptor = typeof options === \"function\" ? {\n    module: options.module,\n    name: options.element,\n    versions: options.versions,\n    baseClass: options.baseClass,\n    enums: options.enums,\n    signals: options.signals,\n    defaultProperty: options.defaultProperty,\n    properties: options.properties,\n    constructor: options\n  } : options;\n\n  descriptor.constructor.$qmlTypeInfo = {\n    enums: descriptor.enums,\n    signals: descriptor.signals,\n    defaultProperty: descriptor.defaultProperty,\n    properties: descriptor.properties\n  };\n\n  if (descriptor.global) {\n    registerGlobalQmlType(descriptor.name, descriptor.constructor);\n  }\n\n  var moduleDescriptor = {\n    name: descriptor.name,\n    versions: descriptor.versions,\n    constructor: descriptor.constructor\n  };\n\n  if (typeof modules[descriptor.module] === \"undefined\") {\n    modules[descriptor.module] = [];\n  }\n  modules[descriptor.module].push(moduleDescriptor);\n\n  if (typeof descriptor.baseClass !== \"undefined\") {\n    inherit(descriptor.constructor, descriptor.baseClass);\n  }\n\n  var id = [descriptor.module, descriptor.name].join(\".\");\n  if (dependants.hasOwnProperty(id)) {\n    dependants[id].forEach(function (opt) {\n      return registerQmlType(opt);\n    });\n    dependants[id].length = 0;\n  }\n\n  // TODO: Move to module initialization?\n  /*\r\n    http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers\r\n      Some object treated as Attached. For example, Component.\r\n    Here, we set property to object `QMLBaseObject.prototype` with name of that\r\n    object, and with specific getter func.\r\n    E.g., we create \"someitem.Component\" here.\r\n    Later, if somebody will read that property, the getter will be invoked.\r\n    Here all getters are set to `getAttachedObject` only, which is actually\r\n    dedicated for Component attached object.\r\n    The code of `getAttachedObject` checks whether $Component internal\r\n    variable exist, and creates it if it absent.\r\n    Then, `getAttachedObject` adds self \"completed\" signal to global\r\n    `engine.completedSignals`.\r\n    That is how completed handlers gathered into global list. This list then\r\n    is called by `engine.callCompletedSignals`.\r\n      p.s. At the moment, Repeater and Loader manually call\r\n    `Component.completed` signals on objects they create.\r\n    At the same time, those signals are still pushed to\r\n    `engine.completedSignals` by getAttachedObject.\r\n  */\n  if (descriptor.constructor.getAttachedObject) {\n    var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n    QmlWeb.setupGetter(QMLBaseObject.prototype, descriptor.name, descriptor.constructor.getAttachedObject);\n  }\n}\n\nfunction getConstructor(moduleName, version, name) {\n  if (typeof modules[moduleName] !== \"undefined\") {\n    for (var i = 0; i < modules[moduleName].length; ++i) {\n      var type = modules[moduleName][i];\n      if (type.name === name && type.versions.test(version)) {\n        return type.constructor;\n      }\n    }\n  }\n  return null;\n}\n\nfunction getModuleConstructors(moduleName, version) {\n  var constructors = {};\n  if (typeof modules[moduleName] === \"undefined\") {\n    console.warn(\"module \\\"\" + moduleName + \"\\\" not found\");\n    return constructors;\n  }\n  for (var i = 0; i < modules[moduleName].length; ++i) {\n    var module = modules[moduleName][i];\n    if (module.versions.test(version)) {\n      constructors[module.name] = module.constructor;\n    }\n  }\n  return constructors;\n}\n\nfunction loadImports(self, imports) {\n  var mergeObjects = QmlWeb.helpers.mergeObjects;\n  var constructors = mergeObjects(modules.Main);\n  if (imports.filter(function (row) {\n    return row[1] === \"QtQml\";\n  }).length === 0 && imports.filter(function (row) {\n    return row[1] === \"QtQuick\";\n  }).length === 1) {\n    imports.push([\"qmlimport\", \"QtQml\", 2, \"\", true]);\n  }\n  for (var i = 0; i < imports.length; ++i) {\n    var _imports$i = _slicedToArray(imports[i], 4),\n        moduleName = _imports$i[1],\n        moduleVersion = _imports$i[2],\n        moduleAlias = _imports$i[3];\n\n    if (typeof moduleVersion !== \"number\") continue;\n    var versionString = moduleVersion % 1 === 0 ? moduleVersion.toFixed(1) : moduleVersion.toString();\n    var moduleConstructors = getModuleConstructors(moduleName, versionString);\n\n    if (moduleAlias !== \"\") {\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\n    } else {\n      constructors = mergeObjects(constructors, moduleConstructors);\n    }\n  }\n  self.importContextId = importContextIds++;\n  perImportContextConstructors[self.importContextId] = constructors;\n  QmlWeb.constructors = constructors; // TODO: why do we need this?\n}\n\nfunction inherit(constructor, baseClass) {\n  var oldProto = constructor.prototype;\n  constructor.prototype = Object.create(baseClass.prototype);\n  Object.getOwnPropertyNames(oldProto).forEach(function (prop) {\n    constructor.prototype[prop] = oldProto[prop];\n  });\n  constructor.prototype.constructor = baseClass;\n}\n\nfunction callSuper(self, meta) {\n  var info = meta.super.$qmlTypeInfo || {};\n  meta.super = meta.super.prototype.constructor;\n  meta.super.call(self, meta);\n\n  if (info.enums) {\n    // TODO: not exported to the whole file scope yet\n    Object.keys(info.enums).forEach(function (name) {\n      self[name] = info.enums[name];\n\n      if (!global[name]) {\n        global[name] = self[name]; // HACK\n      }\n    });\n  }\n  if (info.properties) {\n    QmlWeb.createProperties(self, info.properties);\n  }\n  if (info.signals) {\n    Object.keys(info.signals).forEach(function (name) {\n      var params = info.signals[name];\n      self[name] = QmlWeb.Signal.signal(params);\n    });\n  }\n  if (info.defaultProperty) {\n    self.$defaultProperty = info.defaultProperty;\n  }\n}\n\n/**\r\n * QML Object constructor.\r\n * @param {Object} meta Meta information about the object and the creation\r\n *                      context\r\n * @return {Object} New qml object\r\n */\nfunction construct(meta) {\n  var item = void 0;\n\n  var constructors = perImportContextConstructors[meta.context.importContextId];\n\n  var classComponents = meta.object.$class.split(\".\");\n  for (var ci = 0; ci < classComponents.length; ++ci) {\n    var c = classComponents[ci];\n    constructors = constructors[c];\n    if (constructors === undefined) {\n      break;\n    }\n  }\n\n  if (constructors !== undefined) {\n    var _constructor = constructors;\n    meta.super = _constructor;\n    item = new _constructor(meta);\n    meta.super = undefined;\n  } else {\n    // Load component from file. Please look at import.js for main notes.\n    // Actually, we have to use that order:\n    // 1) try to load component from current basePath\n    // 2) from importPathList\n    // 3) from directories in imports statements and then\n    // 4) from qmldir files\n    // Currently we support only 1,2 and 4 and use order: 4,1,2\n    // TODO: engine.qmldirs is global for all loaded components.\n    //       That's not qml's original behaviour.\n    var qdirInfo = QmlWeb.engine.qmldirs[meta.object.$class];\n    // Are we have info on that component in some imported qmldir files?\n\n    /* This will also be set in applyProperties, but needs to be set here\r\n     * for Qt.createComponent to have the correct context. */\n    QmlWeb.executionContext = meta.context;\n\n    var filePath = void 0;\n    if (qdirInfo) {\n      filePath = qdirInfo.url;\n    } else if (classComponents.length === 2) {\n      var qualified = QmlWeb.engine.qualifiedImportPath(meta.context.importContextId, classComponents[0]);\n      filePath = \"\" + qualified + classComponents[1] + \".qml\";\n    } else {\n      filePath = classComponents[0] + \".qml\";\n    }\n\n    var component = QmlWeb.Qt.createComponent(filePath);\n\n    if (!component) {\n      throw new Error(\"No constructor found for \" + meta.object.$class);\n    }\n\n    item = component.$createObject(meta.parent);\n    if (typeof item.dom !== \"undefined\") {\n      item.dom.className += \" \" + classComponents[classComponents.length - 1];\n      if (meta.object.id) {\n        item.dom.className += \"  \" + meta.object.id;\n      }\n    }\n    // Handle default properties\n  }\n\n  // id\n  if (meta.object.id) {\n    QmlWeb.setupGetterSetter(meta.context, meta.object.id, function () {\n      return item;\n    }, function () {});\n  }\n\n  // keep path in item for probale use it later in Qt.resolvedUrl\n  item.$context.$basePath = QmlWeb.engine.$basePath; //gut\n\n  // We want to use the item's scope, but this Component's imports\n  item.$context.importContextId = meta.context.importContextId;\n\n  // Apply properties (Bindings won't get evaluated, yet)\n  QmlWeb.applyProperties(meta.object, item, item, item.$context);\n\n  return item;\n}\n\nQmlWeb.modules = modules;\nQmlWeb.registerGlobalQmlType = registerGlobalQmlType;\nQmlWeb.registerQmlType = registerQmlType;\nQmlWeb.getConstructor = getConstructor;\nQmlWeb.loadImports = loadImports;\nQmlWeb.callSuper = callSuper;\nQmlWeb.construct = construct;\n\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {String} propName Property name\r\n * @param {Object} [options] Options that allow finetuning of the property\r\n */\nfunction createProperty(type, obj, propName) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var QMLProperty = QmlWeb.QMLProperty;\n  var prop = new QMLProperty(type, obj, propName);\n  obj[propName + \"Changed\"] = prop.changed;\n  obj.$properties[propName] = prop;\n  obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n\n  var getter = function getter() {\n    return obj.$properties[propName].get();\n  };\n  var setter = void 0;\n  if (options.readOnly) {\n    setter = function setter(newVal) {\n      if (!obj.$canEditReadOnlyProperties) {\n        throw new Error(\"property '\" + propName + \"' has read only access\");\n      }\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  } else {\n    setter = function setter(newVal) {\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  }\n  QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n  if (obj.$isComponentRoot) {\n    var skip = false;\n    if (options.noContextOverride) {\n      // Don't override context properties if options.noContextOverride is on\n      var descr = Object.getOwnPropertyDescriptor(obj.$context, propName);\n      skip = descr && (descr.get || descr.set);\n    }\n    if (!skip) {\n      QmlWeb.setupGetterSetter(obj.$context, propName, getter, setter);\n    }\n  }\n}\n\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {Object} properties An object containing properties descriptors\r\n */\nfunction createProperties(obj, properties) {\n  Object.keys(properties).forEach(function (name) {\n    var desc = properties[name];\n    if (typeof desc === \"string\") {\n      desc = { type: desc };\n    }\n    createProperty(desc.type, obj, name, desc);\n  });\n}\n\n/**\r\n * Apply properties from metaObject to item.\r\n * @param {Object} metaObject Source of properties\r\n * @param {Object} item Target of property apply\r\n * @param {Object} objectScope Scope in which properties should be evaluated\r\n * @param {Object} componentScope Component scope in which properties should be\r\n *                 evaluated\r\n */\nfunction applyProperties(metaObject, item, objectScopeIn, componentScope) {\n  var QMLProperty = QmlWeb.QMLProperty;\n  var objectScope = objectScopeIn || item;\n  QmlWeb.executionContext = componentScope;\n\n  if (metaObject.$children && metaObject.$children.length !== 0) {\n    if (item.$defaultProperty) {\n      item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);\n    } else {\n      throw new Error(\"Cannot assign to unexistant default property\");\n    }\n  }\n  // We purposefully set the default property AFTER using it, in order to only\n  // have it applied for instanciations of this component, but not for its\n  // internal children\n  if (metaObject.$defaultProperty) {\n    item.$defaultProperty = metaObject.$defaultProperty;\n  }\n\n  for (var i in metaObject) {\n    var value = metaObject[i];\n    if (i === \"id\" || i === \"$class\") {\n      // keep them\n      item[i] = value;\n      continue;\n    }\n\n    // skip global id's and internal values\n    if (i === \"id\" || i[0] === \"$\") {\n      // TODO: what? See above.\n      continue;\n    }\n\n    // slots\n    if (i.indexOf(\"on\") === 0 && i.length > 2 && /[A-Z]/.test(i[2])) {\n      var signalName = i[2].toLowerCase() + i.slice(3);\n      if (connectSignal(item, signalName, value, objectScope, componentScope)) {\n        continue;\n      }\n      if (item.$setCustomSlot) {\n        item.$setCustomSlot(signalName, value, objectScope, componentScope);\n        continue;\n      }\n    }\n\n    if (value instanceof Object) {\n      if (applyProperty(item, i, value, objectScope, componentScope)) {\n        continue;\n      }\n    }\n\n    if (item.$properties && i in item.$properties) {\n      item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);\n    } else if (i in item) {\n      item[i] = value;\n    } else if (item.$setCustomData) {\n      item.$setCustomData(i, value);\n    } else {\n      console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\n    }\n  }\n}\n\nfunction applyProperty(item, i, value, objectScope, componentScope) {\n  var QMLProperty = QmlWeb.QMLProperty;\n\n  if (value instanceof QmlWeb.QMLSignalDefinition) {\n    item[i] = QmlWeb.Signal.signal(value.parameters);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLMethod) {\n    value.compile();\n    item[i] = value.eval(objectScope, componentScope, componentScope.$basePath);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLAliasDefinition) {\n    // TODO\n    // 1. Alias must be able to point to prop or id of local object,\n    //    eg: property alias q: t\n    // 2. Alias may have same name as id it points to: property alias\n    //    someid: someid\n    // 3. Alias proxy (or property proxy) to proxy prop access to selected\n    //    incapsulated object. (think twice).\n    createProperty(\"alias\", item, i, { noContextOverride: true });\n    item.$properties[i].componentScope = componentScope;\n    item.$properties[i].componentScopeBasePath = componentScope.$basePath;\n    item.$properties[i].val = value;\n    item.$properties[i].get = function () {\n      var obj = this.componentScope[this.val.objectName];\n      var propertyName = this.val.propertyName;\n      return propertyName ? obj.$properties[propertyName].get() : obj;\n    };\n    item.$properties[i].set = function (newVal, reason, _objectScope, _componentScope) {\n      if (!this.val.propertyName) {\n        throw new Error(\"Cannot set alias property pointing to an QML object.\");\n      }\n      var obj = this.componentScope[this.val.objectName];\n      var prop = obj.$properties[this.val.propertyName];\n      prop.set(newVal, reason, _objectScope, _componentScope);\n    };\n\n    if (value.propertyName) {\n      var con = function con(prop) {\n        var obj = prop.componentScope[prop.val.objectName];\n        if (!obj) {\n          console.error(\"qtcore: target object \", prop.val.objectName, \" not found for alias \", prop);\n          return;\n        }\n        var targetProp = obj.$properties[prop.val.propertyName];\n        if (!targetProp) {\n          console.error(\"qtcore: target property [\", prop.val.objectName, \"].\", prop.val.propertyName, \" not found for alias \", prop.name);\n          return;\n        }\n        // targetProp.changed.connect( prop.changed );\n        // it is not sufficient to connect to `changed` of source property\n        // we have to propagate own changed to it too\n        // seems the best way to do this is to make them identical?..\n        // prop.changed = targetProp.changed;\n        // obj[`${i}Changed`] = prop.changed;\n        // no. because those object might be destroyed later.\n        var loopWatchdog = false;\n        targetProp.changed.connect(item, function () {\n          for (var _len24 = arguments.length, args = Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n            args[_key24] = arguments[_key24];\n          }\n\n          if (loopWatchdog) return;\n          loopWatchdog = true;\n          prop.changed.apply(item, args);\n          loopWatchdog = false;\n        });\n        prop.changed.connect(obj, function () {\n          for (var _len25 = arguments.length, args = Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n            args[_key25] = arguments[_key25];\n          }\n\n          if (loopWatchdog) return;\n          loopWatchdog = true;\n          targetProp.changed.apply(obj, args);\n          loopWatchdog = false;\n        });\n      };\n      QmlWeb.engine.pendingOperations.push([con, item.$properties[i]]);\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLPropertyDefinition) {\n    createProperty(value.type, item, i);\n    item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);\n    return true;\n  }\n\n  if (item[i] && value instanceof QmlWeb.QMLMetaPropertyGroup) {\n    // Apply properties one by one, otherwise apply at once\n    applyProperties(value, item[i], objectScope, componentScope);\n    return true;\n  }\n\n  return false;\n}\n\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\n  if (!item[signalName]) {\n    console.warn(\"No signal called \" + signalName + \" found!\");\n    return undefined;\n  } else if (typeof item[signalName].connect !== \"function\") {\n    console.warn(signalName + \" is not a signal!\");\n    return undefined;\n  }\n\n  if (!value.compiled) {\n    var params = [];\n    for (var j in item[signalName].parameters) {\n      params.push(item[signalName].parameters[j].name);\n    }\n    // Wrap value.src in IIFE in case it includes a \"return\"\n    value.src = \"(\\n      function(\" + params.join(\", \") + \") {\\n        QmlWeb.executionContext = __executionContext;\\n        const bp = QmlWeb.engine.$basePath;\\n        QmlWeb.engine.$basePath = \\\"\" + componentScope.$basePath + \"\\\";\\n        try {\\n          (function() {\\n            \" + value.src + \"\\n          })();\\n        } finally {\\n          QmlWeb.engine.$basePath = bp;\\n        }\\n      }\\n    )\";\n    value.isFunction = false;\n    value.compile();\n  }\n  // Don't pass in __basePath argument, as QMLEngine.$basePath is set in the\n  // value.src, as we need it set at the time the slot is called.\n  var slot = value.eval(objectScope, componentScope);\n  item[signalName].connect(item, slot);\n  return slot;\n}\n\nQmlWeb.createProperty = createProperty;\nQmlWeb.createProperties = createProperties;\nQmlWeb.applyProperties = applyProperties;\nQmlWeb.connectSignal = connectSignal;\n\n/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\nvar QMLMethod = function (_QmlWeb$QMLBinding) {\n  _inherits(QMLMethod, _QmlWeb$QMLBinding);\n\n  function QMLMethod() {\n    _classCallCheck(this, QMLMethod);\n\n    return _possibleConstructorReturn(this, (QMLMethod.__proto__ || Object.getPrototypeOf(QMLMethod)).apply(this, arguments));\n  }\n\n  return QMLMethod;\n}(QmlWeb.QMLBinding);\n\n/**\r\n * Create an object representing a QML property definition.\r\n * @param {String} type The type of the property\r\n * @param {Array} value The default value of the property\r\n * @return {Object} Object representing the defintion\r\n */\n\n\nvar QMLPropertyDefinition = function QMLPropertyDefinition(type, value) {\n  _classCallCheck(this, QMLPropertyDefinition);\n\n  this.type = type;\n  this.value = value;\n};\n\nvar QMLAliasDefinition = function QMLAliasDefinition(objName, propName) {\n  _classCallCheck(this, QMLAliasDefinition);\n\n  this.objectName = objName;\n  this.propertyName = propName;\n};\n\n/**\r\n * Create an object representing a QML signal definition.\r\n * @param {Array} params The parameters the signal ships\r\n * @return {Object} Object representing the defintion\r\n */\n\n\nvar QMLSignalDefinition = function QMLSignalDefinition(params) {\n  _classCallCheck(this, QMLSignalDefinition);\n\n  this.parameters = params;\n};\n\n/**\r\n * Create an object representing a group of QML properties (like anchors).\r\n * @return {Object} Object representing the group\r\n */\n\n\nvar QMLMetaPropertyGroup = function QMLMetaPropertyGroup() {\n  _classCallCheck(this, QMLMetaPropertyGroup);\n};\n\n/**\r\n * Create an object representing a QML element.\r\n * @param {String} type Type of the element\r\n * @param {String} onProp Name of the property specified with the \"on\" keyword\r\n */\n\n\nvar QMLMetaElement = function QMLMetaElement(type, onProp) {\n  _classCallCheck(this, QMLMetaElement);\n\n  this.$class = type;\n  this.$children = [];\n  this.$on = onProp;\n};\n\n// Convert parser tree to the format understood by engine\n\n\nfunction convertToEngine(tree) {\n  return convertToEngine.walk(tree);\n}\n\nfunction stringifyDots(elem) {\n  var sub = elem;\n  var path = [];\n  while (sub[0] === \"dot\") {\n    path.push(sub[1]);\n    sub = sub[2];\n  }\n  path.push(sub);\n  return path.join(\".\");\n}\n\nfunction applyProp(item, name, val) {\n  var curr = item; // output structure\n  var sub = name; // input structure\n  while (sub[0] === \"dot\") {\n    if (!curr[sub[1]]) {\n      curr[sub[1]] = new QMLMetaPropertyGroup();\n    }\n    curr = curr[sub[1]];\n    sub = sub[2];\n  }\n  curr[sub] = val;\n}\n\nconvertToEngine.walkers = {\n  toplevel: function toplevel(imports, statement) {\n    var item = { $class: \"Component\" };\n    item.$imports = imports;\n    item.$children = [convertToEngine.walk(statement)];\n    return item;\n  },\n  qmlelem: function qmlelem(elem, onProp, statements) {\n    var item = new QMLMetaElement(stringifyDots(elem), onProp);\n\n    for (var i in statements) {\n      var statement = statements[i];\n      var name = statement[1];\n      var val = convertToEngine.walk(statement);\n      switch (statement[0]) {\n        case \"qmldefaultprop\":\n          item.$defaultProperty = name;\n          item[name] = val;\n          break;\n        case \"qmlprop\":\n        case \"qmlpropdef\":\n        case \"qmlaliasdef\":\n        case \"qmlmethod\":\n        case \"qmlsignaldef\":\n          applyProp(item, name, val);\n          break;\n        case \"qmlelem\":\n          item.$children.push(val);\n          break;\n        case \"qmlobjdef\":\n          throw new Error(\"qmlobjdef support was removed, update qmlweb-parser to ^0.3.0.\");\n        case \"qmlobj\":\n          // Create object to item\n          item[name] = item[name] || new QMLMetaPropertyGroup();\n          for (var j in val) {\n            item[name][j] = val[j];\n          }\n          break;\n        default:\n          console.log(\"Unknown statement\", statement);\n      }\n    }\n    // Make $children be either a single item or an array, if it's more than one\n    if (item.$children.length === 1) {\n      item.$children = item.$children[0];\n    }\n\n    return item;\n  },\n  qmlprop: function qmlprop(name, tree, src) {\n    if (name === \"id\") {\n      // id property\n      return tree[1][1];\n    }\n    return convertToEngine.bindout(tree, src);\n  },\n  qmlobjdef: function qmlobjdef(name, property, tree, src) {\n    return convertToEngine.bindout(tree, src);\n  },\n  qmlobj: function qmlobj(elem, statements) {\n    var item = {};\n    for (var i in statements) {\n      var statement = statements[i];\n      var name = statement[1];\n      var val = convertToEngine.walk(statement);\n      if (statement[0] === \"qmlprop\") {\n        applyProp(item, name, val);\n      }\n    }\n    return item;\n  },\n  qmlmethod: function qmlmethod(name, tree, src) {\n    return new QMLMethod(src);\n  },\n  qmlpropdef: function qmlpropdef(name, type, tree, src) {\n    return new QMLPropertyDefinition(type, tree ? convertToEngine.bindout(tree, src) : undefined);\n  },\n  qmlaliasdef: function qmlaliasdef(name, objName, propName) {\n    return new QMLAliasDefinition(objName, propName);\n  },\n  qmlsignaldef: function qmlsignaldef(name, params) {\n    return new QMLSignalDefinition(params);\n  },\n  qmldefaultprop: function qmldefaultprop(tree) {\n    return convertToEngine.walk(tree);\n  },\n  name: function name(src) {\n    if (src === \"true\" || src === \"false\") {\n      return src === \"true\";\n    } else if (typeof src === \"boolean\") {\n      // TODO: is this needed? kept for compat with ==\n      return src;\n    }\n    return new QmlWeb.QMLBinding(src, [\"name\", src]);\n  },\n  num: function num(src) {\n    return +src;\n  },\n  string: function string(src) {\n    return String(src);\n  },\n  array: function array(tree, src) {\n    var a = [];\n    var isList = false;\n    var hasBinding = false;\n    for (var i in tree) {\n      var val = convertToEngine.bindout(tree[i]);\n      a.push(val);\n\n      if (val instanceof QMLMetaElement) {\n        isList = true;\n      } else if (val instanceof QmlWeb.QMLBinding) {\n        hasBinding = true;\n      }\n    }\n\n    if (hasBinding) {\n      if (isList) {\n        throw new TypeError(\"An array may either contain bindings or Element definitions.\");\n      }\n      return new QmlWeb.QMLBinding(src, tree);\n    }\n\n    return a;\n  }\n};\n\nconvertToEngine.walk = function (tree) {\n  var type = tree[0];\n  var walker = convertToEngine.walkers[type];\n  if (!walker) {\n    console.log(\"No walker for \" + type);\n    return undefined;\n  }\n  return walker.apply(type, tree.slice(1));\n};\n\n// Try to bind out tree and return static variable instead of binding\nconvertToEngine.bindout = function (statement, binding) {\n  // We want to process the content of the statement\n  // (but still handle the case, we get the content directly)\n  var tree = statement[0] === \"stat\" ? statement[1] : statement;\n\n  var type = tree[0];\n  var walker = convertToEngine.walkers[type];\n  if (walker) {\n    return walker.apply(type, tree.slice(1));\n  }\n  return new QmlWeb.QMLBinding(binding, tree);\n};\n\n// Help logger\nconvertToEngine.amIn = function (str, tree) {\n  console.log(str);\n  if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n};\n\nfunction loadParser() {\n  if (typeof QmlWeb.parse !== \"undefined\") {\n    return;\n  }\n\n  console.log(\"Loading parser...\");\n  var tags = document.getElementsByTagName(\"script\");\n  for (var i in tags) {\n    if (tags[i].src && tags[i].src.match(/\\/(qt|qmlweb)\\./)) {\n      var src = tags[i].src.replace(/\\/(qt|qmlweb)\\.(es201.\\.)?/, \"/qmlweb.parser.\");\n      // TODO: rewrite to async loading\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", src, false);\n      xhr.send(null);\n      if (xhr.status !== 200 && xhr.status !== 0) {\n        // xhr.status === 0 if accessing with file://\n        throw new Error(\"Could not load QmlWeb parser!\");\n      }\n      new Function(xhr.responseText)();\n      QmlWeb.parse = QmlWeb.parse;\n      QmlWeb.jsparse = QmlWeb.jsparse;\n      return;\n    }\n  }\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n  loadParser();\n  QmlWeb.parse.nowParsingFile = file;\n  var parsetree = QmlWeb.parse(src, QmlWeb.parse.QmlDocument);\n  return convertToEngine(parsetree);\n}\n\nQmlWeb.QMLMethod = QMLMethod;\nQmlWeb.QMLPropertyDefinition = QMLPropertyDefinition;\nQmlWeb.QMLAliasDefinition = QMLAliasDefinition;\nQmlWeb.QMLSignalDefinition = QMLSignalDefinition;\nQmlWeb.QMLMetaPropertyGroup = QMLMetaPropertyGroup;\nQmlWeb.QMLMetaElement = QMLMetaElement;\nQmlWeb.convertToEngine = convertToEngine;\nQmlWeb.loadParser = loadParser;\nQmlWeb.parseQML = parseQML;\n\n/*\r\n\r\nQmlWeb.qrc is analogous to the Qt Resource System. It is expected to map a path\r\nwithin the resource system to the following pieces of data:\r\n\r\n1) For a QML Component, it is the return value of QmlWeb.parse\r\n2) For a JavaScript file, it is the return value of QmlWeb.jsparse\r\n2) For an image, it is any URL that an <img> tag can accept (e.g. a standard\r\n   URL to an image resource, or a \"data:\" URI). If there is no entry for a\r\n   given qrc image path, it will fall back to passing the path right through to\r\n   the DOM. This is mainly a convenience until support for images is added to\r\n   gulp-qmlweb.\r\n\r\nThe \"data-qml\" tag on <body> can be set to a \"qrc://\" URL like\r\n\"qrc:///root.qml\" to use a pre-parsed \"/root.qml\" from QmlWeb.qrc.\r\n\r\nSince relative URLs are resolved relative to the URL of the containing\r\ncomponent, any relative URL set within a file in the resource system will also\r\nresolve within the resource system. To access a Component, JavaScript or image\r\nfile that is stored outside of the resources system from within the resource\r\nsystem, a full URL must be used (e.g. \"http://www.example.com/images/foo.png\").\r\n\r\nVice-versa, in order to access a Component, JavaScript or image file that is\r\nstored within the resource system from outside of the resource system, a full\r\n\"qrc://\" URL must be used (e.g. \"qrc:///images/foo.png\").\r\n\r\nMore details here: http://doc.qt.io/qt-5/qml-url.html\r\n\r\n*/\nQmlWeb.qrc = {};\n\nQmlWeb.registerQmlType({\n  module: \"QmlWeb.Dom\",\n  name: \"DomElement\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    tagName: { type: \"string\", initialValue: \"div\" }\n  }\n}, function () {\n  function _class(meta) {\n    _classCallCheck(this, _class);\n\n    meta.tagName = meta.object.tagName;\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: support properties, styles, perhaps changing the tagName\n  }\n\n  return _class;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QmlWeb\",\n  name: \"RestModel\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    url: \"string\",\n    isLoading: \"bool\",\n    mimeType: { type: \"string\", initialValue: \"application/json\" },\n    queryMimeType: {\n      type: \"string\",\n      initialValue: \"application/x-www-urlencoded\"\n    }\n  },\n  signals: {\n    fetched: [],\n    saved: []\n  }\n}, function () {\n  function _class2(meta) {\n    _classCallCheck(this, _class2);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.attributes = this.getAttributes();\n    this.runningRequests = 0;\n  }\n\n  _createClass(_class2, [{\n    key: \"fetch\",\n    value: function fetch() {\n      var _this19 = this;\n\n      this.$ajax({\n        method: \"GET\",\n        mimeType: this.mimetype,\n        success: function success(xhr) {\n          _this19.$xhrReadResponse(xhr);\n          _this19.fetched();\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this20 = this;\n\n      this.$ajax({\n        method: \"DELETE\",\n        success: function success() {\n          _this20.destroy();\n        }\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      this.$sendToServer(\"POST\");\n    }\n  }, {\n    key: \"save\",\n    value: function save() {\n      this.$sendToServer(\"PUT\");\n    }\n  }, {\n    key: \"$sendToServer\",\n    value: function $sendToServer(method) {\n      var _this21 = this;\n\n      this.$ajax({\n        method: method,\n        mimeType: this.queryMimeType,\n        body: this.$generateBodyForPostQuery(),\n        success: function success(xhr) {\n          _this21.$xhrReadResponse(xhr);\n          _this21.saved();\n        }\n      });\n    }\n  }, {\n    key: \"$generateBodyForPostQuery\",\n    value: function $generateBodyForPostQuery() {\n      var object = {};\n      for (var i = 0; i < this.attributes.length; ++i) {\n        object[this.attributes[i]] = this.$properties[this.attributes[i]].get();\n      }\n      console.log(object);\n      switch (this.queryMimeType) {\n        case \"application/json\":\n        case \"text/json\":\n          return JSON.stringify(object);\n        case \"application/x-www-urlencoded\":\n          return this.$objectToUrlEncoded(object);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"$objectToUrlEncoded\",\n    value: function $objectToUrlEncoded(object, prefix) {\n      var parts = [];\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = object[key];\n          if (typeof prefix !== \"undefined\") {\n            key = prefix + \"[\" + key + \"]\";\n          }\n          if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\") {\n            parts.push(this.$objectToUrlEncoded(value, key));\n          } else {\n            var ekey = this.$myEncodeURIComponent(key);\n            var evalue = this.$myEncodeURIComponent(value);\n            parts.push(ekey + \"=\" + evalue);\n          }\n        }\n      }\n      return parts.join(\"&\");\n    }\n  }, {\n    key: \"$myEncodeURIComponent\",\n    value: function $myEncodeURIComponent(str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return \"%\" + c.charCodeAt(0).toString(16);\n      });\n    }\n  }, {\n    key: \"$ajax\",\n    value: function $ajax(options) {\n      var _this22 = this;\n\n      var xhr = new XMLHttpRequest();\n      xhr.overrideMimeType(this.mimeType);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          if (xhr.status === 200) {\n            options.success(xhr);\n          } else {\n            options.failure(xhr);\n          }\n          _this22.runningRequests -= 1;\n          if (_this22.runningRequests <= 0) {\n            _this22.isLoading = false;\n          }\n        }\n      };\n      xhr.open(options.method, this.url, true);\n      if (typeof options.body !== \"undefined\") {\n        xhr.setRequestHeader(\"Content-Type\", this.queryMimeType);\n        xhr.send(options.body);\n      } else {\n        xhr.send(null);\n      }\n      this.runningRequests += 1;\n      this.isLoading = true;\n    }\n  }, {\n    key: \"$xhrReadResponse\",\n    value: function $xhrReadResponse(xhr) {\n      var responseObject = void 0;\n      if (this.mimeType === \"application/json\" || this.mimeType === \"text/json\") {\n        responseObject = JSON.parse(xhr.responseText);\n      }\n      this.$updatePropertiesFromResponseObject(responseObject);\n    }\n  }, {\n    key: \"$updatePropertiesFromResponseObject\",\n    value: function $updatePropertiesFromResponseObject(responseObject) {\n      var QMLProperty = QmlWeb.QMLProperty;\n      for (var key in responseObject) {\n        if (responseObject.hasOwnProperty(key) && this.$hasProperty(key)) {\n          this.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n        }\n      }\n    }\n  }, {\n    key: \"$hasProperty\",\n    value: function $hasProperty(name) {\n      return typeof this.$properties[name] !== \"undefined\";\n    }\n  }]);\n\n  return _class2;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"Qt.labs.settings\",\n  name: \"Settings\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    category: \"string\"\n  }\n}, function () {\n  function _class3(meta) {\n    _classCallCheck(this, _class3);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (typeof window.localStorage === \"undefined\") {\n      return;\n    }\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class3, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$loadProperties();\n      this.$initializeProperties();\n    }\n  }, {\n    key: \"$getKey\",\n    value: function $getKey(attrName) {\n      return this.category + \"/\" + attrName;\n    }\n  }, {\n    key: \"$loadProperties\",\n    value: function $loadProperties() {\n      var _this23 = this;\n\n      this.$attributes.forEach(function (attrName) {\n        if (!_this23.$properties[attrName]) return;\n\n        var key = _this23.$getKey(attrName);\n        _this23[attrName] = localStorage.getItem(key);\n      });\n    }\n  }, {\n    key: \"$initializeProperties\",\n    value: function $initializeProperties() {\n      var _this24 = this;\n\n      this.$attributes.forEach(function (attrName) {\n        if (!_this24.$properties[attrName]) return;\n\n        var emitter = _this24;\n        var signalName = attrName + \"Changed\";\n\n        if (_this24.$properties[attrName].type === \"alias\") {\n          emitter = _this24.$context[_this24.$properties[attrName].val.objectName];\n          signalName = _this24.$properties[attrName].val.propertyName + \"Changed\";\n        }\n\n        emitter[signalName].connect(_this24, function () {\n          localStorage.setItem(_this24.$getKey(attrName), _this24[attrName]);\n        });\n      });\n    }\n  }]);\n\n  return _class3;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtBluetooth\",\n  name: \"BluetoothDiscoveryModel\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    BluetoothDiscoveryModel: {\n      FullServiceDiscovery: 1, MinimalServiceDiscovery: 0, DeviceDiscovery: 2,\n      NoError: 0, InputOutputError: 1, PoweredOffError: 2,\n      InvalidBluetoothAdapterError: 4, UnknownError: 3\n    }\n  },\n  properties: {\n    discoveryMode: { type: \"enum\", initialValue: 3 }, // MinimalServiceDiscovery\n    error: { type: \"enum\", initialValue: 0 }, // NoError\n    remoteAddress: \"string\",\n    running: \"bool\",\n    uuidFilter: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    deviceDiscovered: [{ type: \"string\", name: \"device\" }],\n    serviceDiscovered: [{ type: \"string\", name: \"device\" }]\n  }\n}, function () {\n  function _class4(meta) {\n    _classCallCheck(this, _class4);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implementation based on navigator.bluetooth\n  }\n\n  return _class4;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtGraphicalEffects\",\n  name: \"FastBlur\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    radius: \"real\",\n    source: { type: \"var\", initialValue: null }\n  }\n}, function () {\n  function _class5(meta) {\n    _classCallCheck(this, _class5);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$previousSource = null;\n    this.$filterObject = undefined;\n\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n  }\n\n  _createClass(_class5, [{\n    key: \"$onRadiusChanged\",\n    value: function $onRadiusChanged() {\n      this.$updateEffect(this.source);\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged() {\n      this.$updateEffect(this.source);\n    }\n  }, {\n    key: \"$updateFilterObject\",\n    value: function $updateFilterObject() {\n      this.$filterObject = {\n        transformType: \"filter\",\n        operation: \"blur\",\n        parameters: this.radius + \"px\"\n      };\n    }\n  }, {\n    key: \"$updateEffect\",\n    value: function $updateEffect(source) {\n      console.log(\"updating effect\");\n      if (this.$previousSource) {\n        var index = this.$previousSource.transform.indexOf(this.$filterObject);\n        this.$previousSource.transform.splice(index, 1);\n        this.$previousSource.$updateTransform();\n      }\n      if (source && source.transform) {\n        this.$updateFilterObject();\n        console.log(\"updating effect:\", this.$filterObject, source);\n        source.transform.push(this.$filterObject);\n        source.$updateTransform();\n        this.$previousSource = source;\n      } else {\n        this.$previousSource = null;\n      }\n    }\n  }]);\n\n  return _class5;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtGraphicalEffects\",\n  name: \"RectangularGlow\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    cached: \"bool\",\n    color: { type: \"color\", initialValue: \"white\" },\n    cornerRadius: \"real\",\n    glowRadius: \"real\",\n    spread: \"real\"\n  }\n}, function () {\n  function _class6(meta) {\n    _classCallCheck(this, _class6);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.impl = document.createElement(\"div\");\n    var style = this.impl.style;\n    style.pointerEvents = \"none\";\n    style.position = \"absolute\";\n    style.left = style.right = style.top = style.bottom = \"0px\";\n    style.border = \"none\";\n    style.backgroundColor = this.color.$css;\n    this.dom.appendChild(this.impl);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.glowRadiusChanged.connect(this, this.$updateBoxShadow);\n    this.cornerRadiusChanged.connect(this, this.$updateBoxShadow);\n    this.widthChanged.connect(this, this.$updateBoxShadow);\n    this.heightChanged.connect(this, this.$updateBoxShadow);\n    this.spreadChanged.connect(this, this.$onSpreadChanged);\n  }\n\n  _createClass(_class6, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.backgroundColor = newVal.$css;\n      this.$updateBoxShadow();\n    }\n  }, {\n    key: \"$onSpreadChanged\",\n    value: function $onSpreadChanged(newVal) {\n      if (newVal > 1) {\n        this.spread = 1;\n      } else if (newVal < 0) {\n        this.spread = 0;\n      }\n      this.$updateBoxShadow();\n    }\n  }, {\n    key: \"$updateBoxShadow\",\n    value: function $updateBoxShadow() {\n      var color = this.color,\n          glowRadius = this.glowRadius,\n          cornerRadius = this.cornerRadius,\n          spread = this.spread,\n          width = this.width,\n          height = this.height;\n\n      var style = this.impl.style;\n\n      // Calculate boxShadow\n      var totle = glowRadius + cornerRadius * (1 - spread);\n      var glow = (1 - spread) * totle;\n      var blur_radius = glow * 0.64;\n      var spread_radius = totle - blur_radius;\n      var glow2 = glowRadius / 5;\n      var blur_radius_2 = glow2 * 0.8;\n      var spread_radius_2 = glow2 - blur_radius_2;\n\n      style.boxShadow = color + \" 0px 0px \" + blur_radius + \"px \" + spread_radius + \"px,\" + (color + \" 0px 0px \" + blur_radius_2 + \"px \" + spread_radius_2 + \"px\");\n\n      // Calculate glow css\n      var spread_cornerR = cornerRadius * (1 - spread);\n      var rest_cornerR = cornerRadius - spread_cornerR;\n      var xScale = (width - spread_cornerR / 4) / width;\n      var yScale = (height - spread_cornerR / 4) / height;\n\n      style.width = width - spread_cornerR + \"px\";\n      style.height = height - spread_cornerR + \"px\";\n      style.top = spread_cornerR / 2 + \"px\";\n      style.left = spread_cornerR / 2 + \"px\";\n      style.filter = \"blur(\" + spread_cornerR / 2 + \"px)\";\n      style.borderRadius = rest_cornerR / 2 + \"px\";\n      style.transform = \"scale(\" + xScale + \",\" + yScale + \")\";\n    }\n  }]);\n\n  return _class6;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMobility\",\n  name: \"GeoLocation\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    accuracy: \"double\",\n    altitude: \"double\",\n    altitudeAccuracy: \"double\",\n    heading: \"double\",\n    latitude: \"double\",\n    longitude: \"double\",\n    speed: \"double\",\n    timestamp: \"date\",\n    label: \"string\"\n  }\n}, function () {\n  function _class7(meta) {\n    var _this25 = this;\n\n    _classCallCheck(this, _class7);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (!navigator.geolocation) {\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(function (pos) {\n      return _this25.$updatePosition(pos);\n    });\n    navigator.geolocation.watchPosition(function (pos) {\n      return _this25.$updatePosition(pos);\n    });\n  }\n\n  _createClass(_class7, [{\n    key: \"$updatePosition\",\n    value: function $updatePosition(position) {\n      this.accuracy = position.coords.accuracy;\n      this.altitude = position.coords.altitude;\n      this.altitudeAccuracy = position.coords.altitudeAccuracy;\n      this.heading = position.coords.heading;\n      this.latitude = position.coords.latitude;\n      this.longitude = position.coords.longitude;\n      this.speed = position.coords.speed;\n      this.timestamp = position.timestamp;\n    }\n  }]);\n\n  return _class7;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Audio\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Audio: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // Audio.Available\n    duration: \"int\",\n    error: \"enum\", // Audio.NoError\n    errorString: \"string\",\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    loops: { type: \"int\", initialValue: 1 },\n    mediaObject: \"var\",\n    // TODO: metaData\n    muted: \"bool\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // Audio.StoppedState\n    playlinst: \"Playlist\",\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // Audio.NoMedia\n    volume: { type: \"real\", initialValue: 1 }\n  },\n  signals: {\n    error: [{ type: \"enum\", name: \"error\" }, { type: \"string\", name: \"errorString\" }],\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class8(meta) {\n    _classCallCheck(this, _class8);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class8, [{\n    key: \"pause\",\n    value: function pause() {\n      // TODO\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      // TODO\n    }\n  }, {\n    key: \"seek\",\n    value: function seek() /* offset */{\n      // TODO\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // TODO\n    }\n  }, {\n    key: \"supportedAudioRoles\",\n    value: function supportedAudioRoles() {\n      // TODO\n    }\n  }]);\n\n  return _class8;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Camera\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Camera: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      UnloadedState: 0, LoadedState: 1, ActiveState: 2\n    }\n  },\n  properties: {\n    availability: \"enum\", // Camera.Available\n    cameraState: { type: \"enum\", initialValue: 2 }, // Camera.ActiveState\n    cameraStatus: \"enum\", // TODO\n    captureMode: \"enum\", // TODO\n    deviceId: \"string\",\n    digitalZoom: { type: \"real\", initialValue: 1 },\n    displayName: \"string\",\n    errorCode: \"enum\", // TODO\n    errorString: \"string\",\n    lockStatus: \"enum\", // TODO\n    maximumDigitalZoom: \"real\",\n    maximumOpticalZoom: \"real\",\n    opticalZoom: { type: \"real\", initialValue: 1 },\n    orientation: \"int\",\n    position: \"enum\" },\n  signals: {\n    error: [{ type: \"enum\", name: \"errorCode\" }, { type: \"string\", name: \"errorString\" }]\n  }\n}, function () {\n  function _class9(meta) {\n    _classCallCheck(this, _class9);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class9;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"MediaPlayer\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    MediaPlayer: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // MediaPlayer.Available\n    bufferProgress: \"real\",\n    duration: \"int\",\n    error: \"enum\", // MediaPlayer.NoError\n    errorString: \"string\",\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    loops: \"int\",\n    muted: \"bool\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // MediaPlayer.StoppedState\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // MediaPlayer.NoMedia\n    volume: \"real\"\n  },\n  signals: {\n    error: [{ type: \"enum\", name: \"error\" }, { type: \"string\", name: \"errorString\" }],\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class10(meta) {\n    _classCallCheck(this, _class10);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class10;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Video\",\n  versions: /^5\\./,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    MediaPlayer: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    },\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // MediaPlayer.Available\n    bufferProgress: \"real\",\n    duration: \"int\",\n    error: \"enum\", // MediaPlayer.NoError\n    errorString: \"string\",\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    muted: \"bool\",\n    orientation: \"int\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // MediaPlayer.StoppedState\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // MediaPlayer.NoMedia\n    volume: \"real\"\n  },\n  signals: {\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class11(meta) {\n    var _this26 = this;\n\n    _classCallCheck(this, _class11);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningEventListener = 0;\n\n    this.impl = document.createElement(\"video\");\n    this.impl.style.width = this.impl.style.height = \"100%\";\n    this.impl.style.margin = \"0\";\n    this.dom.appendChild(this.impl);\n\n    this.volume = this.impl.volume;\n    this.duration = this.impl.duration;\n\n    this.impl.addEventListener(\"play\", function () {\n      _this26.playing();\n      _this26.playbackState = _this26.MediaPlayer.PlayingState;\n    });\n\n    this.impl.addEventListener(\"pause\", function () {\n      _this26.paused();\n      _this26.playbackState = _this26.MediaPlayer.PausedState;\n    });\n\n    this.impl.addEventListener(\"timeupdate\", function () {\n      _this26.$runningEventListener++;\n      _this26.position = _this26.impl.currentTime * 1000;\n      _this26.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"ended\", function () {\n      _this26.stopped();\n      _this26.playbackState = _this26.MediaPlayer.StoppedState;\n    });\n\n    this.impl.addEventListener(\"progress\", function () {\n      if (_this26.impl.buffered.length > 0) {\n        _this26.progress = _this26.impl.buffered.end(0) / _this26.impl.duration;\n        _this26.status = _this26.progress < 1 ? _this26.MediaPlayer.Buffering : _this26.MediaPlayer.Buffered;\n      }\n    });\n\n    this.impl.addEventListener(\"stalled\", function () {\n      _this26.status = _this26.MediaPlayer.Stalled;\n    });\n\n    this.impl.addEventListener(\"canplaythrough\", function () {\n      _this26.status = _this26.MediaPlayer.Buffered;\n    });\n\n    this.impl.addEventListener(\"loadstart\", function () {\n      _this26.status = _this26.MediaPlayer.Loading;\n    });\n\n    this.impl.addEventListener(\"durationchanged\", function () {\n      _this26.duration = _this26.impl.duration;\n    });\n\n    this.impl.addEventListener(\"volumechanged\", function () {\n      _this26.$runningEventListener++;\n      _this26.volume = _this26.impl.volume;\n      _this26.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"suspend\", function () {\n      _this26.error |= _this26.MediaPlayer.NetworkError;\n    });\n\n    this.impl.addEventListener(\"error\", function () {\n      _this26.error |= _this26.MediaPlayer.ResourceError;\n    });\n\n    this.impl.addEventListener(\"ratechange\", function () {\n      _this26.$runningEventListener++;\n      _this26.playbackRate = _this26.impl.playbackRate;\n      _this26.$runningEventListener--;\n    });\n\n    this.autoPlayChanged.connect(this, this.$onAutoPlayChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.positionChanged.connect(this, this.$onPositionChanged);\n    this.volumeChanged.connect(this, this.$onVolumeChanged);\n    this.playbackRateChanged.connect(this, this.$onPlaybackRateChanged);\n    this.mutedChanged.connect(this, this.$onMutedChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n  }\n\n  _createClass(_class11, [{\n    key: \"$onAutoPlayChanged\",\n    value: function $onAutoPlayChanged(newVal) {\n      this.impl.autoplay = newVal;\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      var parts = source.split(\".\");\n      var extension = parts[parts.length - 1].toLowerCase();\n      var mime = this.mimetypeFromExtension(extension);\n      this.impl.src = source;\n      if (!this.impl.canPlayType(mime)) {\n        this.error |= this.MediaPlayer.FormatError;\n      }\n    }\n  }, {\n    key: \"$onPositionChanged\",\n    value: function $onPositionChanged(currentTime) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.currentTime = currentTime / 1000;\n    }\n  }, {\n    key: \"$onVolumeChanged\",\n    value: function $onVolumeChanged(volume) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.volume = volume;\n    }\n  }, {\n    key: \"$onPlaybackRateChanged\",\n    value: function $onPlaybackRateChanged(playbackRate) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.playbackRate = playbackRate;\n    }\n  }, {\n    key: \"$onMutedChanged\",\n    value: function $onMutedChanged(newValue) {\n      if (newValue) {\n        this.$volulmeBackup = this.impl.volume;\n        this.volume = 0;\n      } else {\n        this.volume = this.$volumeBackup;\n      }\n    }\n  }, {\n    key: \"$onFillModeChanged\",\n    value: function $onFillModeChanged(newValue) {\n      switch (newValue) {\n        case this.VideoOutput.Stretch:\n          this.impl.style.objectFit = \"fill\";\n          break;\n        case this.VideoOutput.PreserveAspectFit:\n          this.impl.style.objectFit = \"\";\n          break;\n        case this.VideoOutput.PreserveAspectCrop:\n          this.impl.style.objectFit = \"cover\";\n          break;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.impl.pause();\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this.impl.play();\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(offset) {\n      this.impl.currentTime = offset * 1000;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"mimetypeFromExtension\",\n    value: function mimetypeFromExtension(extension) {\n      var mimetypes = {\n        ogg: \"video/ogg\",\n        ogv: \"video/ogg\",\n        ogm: \"video/ogg\",\n        mp4: \"video/mp4\",\n        webm: \"video/webm\"\n      };\n      return mimetypes[extension] || \"\";\n    }\n  }]);\n\n  return _class11;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"VideoOutput\",\n  versions: /^5\\./,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\n  },\n  properties: {\n    autoOrientation: \"bool\",\n    contentRect: \"rect\",\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\n    filters: \"list\",\n    orientation: \"int\",\n    source: \"variant\",\n    sourceRect: \"rect\"\n  }\n}, function () {\n  function _class12(meta) {\n    _classCallCheck(this, _class12);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class12;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtNfc\",\n  name: \"NearField\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    filter: \"list\",\n    messageRecords: \"list\",\n    orderMatch: \"bool\",\n    polling: \"bool\"\n  },\n  signals: {\n    tagFound: [],\n    tagRemoved: []\n  }\n}, function () {\n  function _class13(meta) {\n    _classCallCheck(this, _class13);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implementation based on Web NFC API\n  }\n\n  return _class13;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml.Modules\",\n  name: \"ListElement\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.ListElement\"\n}, function () {\n  function _class14(meta) {\n    _classCallCheck(this, _class14);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class14;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml.Modules\",\n  name: \"ListModel\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.ListModel\",\n  defaultProperty: \"$items\"\n}, function () {\n  function _class15(meta) {\n    _classCallCheck(this, _class15);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class15;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Binding\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: { type: \"QtObject\", initialValue: null },\n    property: { type: \"string\", initialValue: \"\" },\n    value: { type: \"var\", initialValue: undefined },\n    when: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class16(meta) {\n    _classCallCheck(this, _class16);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$property = undefined;\n\n    this.valueChanged.connect(this, this.$onValueChanged);\n    this.targetChanged.connect(this, this.$updateBinding);\n    this.propertyChanged.connect(this, this.$updateBinding);\n    this.whenChanged.connect(this, this.$updateBinding);\n  }\n\n  _createClass(_class16, [{\n    key: \"$updateBinding\",\n    value: function $updateBinding() {\n      if (!this.when || !this.target || !this.target.hasOwnProperty(this.property) || this.value === undefined) {\n        this.$property = undefined;\n        return;\n      }\n      this.$property = this.target.$properties[this.property];\n      this.$onValueChanged(this.value); // trigger value update\n    }\n  }, {\n    key: \"$onValueChanged\",\n    value: function $onValueChanged(value) {\n      if (value !== undefined && this.$property) {\n        this.$property.set(value);\n      }\n    }\n  }]);\n\n  return _class16;\n}());\n\nvar QMLContext = function () {\n  function QMLContext() {\n    _classCallCheck(this, QMLContext);\n  }\n\n  _createClass(QMLContext, [{\n    key: \"nameForObject\",\n    value: function nameForObject(obj) {\n      for (var name in this) {\n        if (this[name] === obj) {\n          return name;\n        }\n      }\n      return undefined;\n    }\n  }]);\n\n  return QMLContext;\n}();\n\nvar QMLComponent = function () {\n  function QMLComponent(meta) {\n    var _this27 = this;\n\n    _classCallCheck(this, QMLComponent);\n\n    if (QmlWeb.constructors[meta.object.$class] === QMLComponent) {\n      this.$metaObject = meta.object.$children[0];\n    } else {\n      this.$metaObject = meta.object;\n    }\n    this.$context = meta.context;\n\n    this.$jsImports = [];\n\n    if (meta.object.$imports instanceof Array) {\n      var moduleImports = [];\n      var loadImport = function loadImport(importDesc) {\n        if (/\\.js$/.test(importDesc[1])) {\n          _this27.$jsImports.push(importDesc);\n        } else {\n          moduleImports.push(importDesc);\n        }\n      };\n\n      for (var i = 0; i < meta.object.$imports.length; ++i) {\n        loadImport(meta.object.$imports[i]);\n      }\n      QmlWeb.loadImports(this, moduleImports);\n    }\n\n    /* If this Component does not have any imports, it is likely one that was\r\n     * created within another Component file. It should inherit the\r\n     * importContextId of the Component file it was created within. */\n    if (this.importContextId === undefined) {\n      this.importContextId = meta.context.importContextId;\n    }\n  }\n\n  _createClass(QMLComponent, [{\n    key: \"finalizeImports\",\n    value: function finalizeImports($context) {\n      var engine = QmlWeb.engine;\n      for (var i = 0; i < this.$jsImports.length; ++i) {\n        var importDesc = this.$jsImports[i];\n        var js = engine.loadJS(engine.$resolvePath(importDesc[1]));\n\n        if (!js) {\n          console.log(\"Component.finalizeImports: failed to import JavaScript\", importDesc[1]);\n          continue;\n        }\n\n        if (importDesc[3] !== \"\") {\n          $context[importDesc[3]] = {};\n          QmlWeb.importJavascriptInContext(js, $context[importDesc[3]]);\n        } else {\n          QmlWeb.importJavascriptInContext(js, $context);\n        }\n      }\n    }\n  }, {\n    key: \"$createObject\",\n    value: function $createObject(parent) {\n      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.$context;\n\n      var engine = QmlWeb.engine;\n      var oldState = engine.operationState;\n      engine.operationState = QmlWeb.QMLOperationState.Init;\n      // change base path to current component base path\n      var bp = engine.$basePath;\n      engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n      var newContext = context ? Object.create(context) : new QMLContext();\n\n      if (this.importContextId !== undefined) {\n        newContext.importContextId = this.importContextId;\n      }\n\n      var item = QmlWeb.construct({\n        object: this.$metaObject,\n        parent: parent,\n        context: newContext,\n        isComponentRoot: true\n      });\n\n      this.finalizeImports(item.$context);\n\n      Object.keys(properties).forEach(function (propname) {\n        item[propname] = properties.propname;\n      });\n\n      // change base path back\n      // TODO looks a bit hacky\n      engine.$basePath = bp;\n\n      engine.operationState = oldState;\n      return item;\n    }\n  }, {\n    key: \"createObject\",\n    value: function createObject(parent) {\n      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var item = this.$createObject(parent, properties);\n      var QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n\n      if (item instanceof QMLItem) {\n        item.$properties.parent.set(parent, QmlWeb.QMLProperty.ReasonInit);\n      }\n\n      return item;\n    }\n  }], [{\n    key: \"getAttachedObject\",\n    value: function getAttachedObject() {\n      // see QMLEngine.js for explanation how it is used.\n      if (!this.$Component) {\n        this.$Component = new QmlWeb.QObject(this);\n        this.$Component.completed = QmlWeb.Signal.signal([]);\n        QmlWeb.engine.completedSignals.push(this.$Component.completed);\n\n        this.$Component.destruction = QmlWeb.Signal.signal([]);\n      }\n      return this.$Component;\n    }\n  }]);\n\n  return QMLComponent;\n}();\n\nQmlWeb.registerQmlType({\n  global: true,\n  module: \"QtQml\",\n  name: \"Component\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  constructor: QMLComponent\n});\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Connections\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    target: \"QtObject\",\n    ignoreUnknownSignals: \"bool\"\n  }\n}, function () {\n  function _class17(meta) {\n    _classCallCheck(this, _class17);\n\n    QmlWeb.callSuper(this, meta);\n    this.target = this.$parent;\n    this.$connections = {};\n\n    this.$old_target = this.target;\n    this.targetChanged.connect(this, this.$onTargetChanged);\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class17, [{\n    key: \"$onTargetChanged\",\n    value: function $onTargetChanged() {\n      this.$reconnectTarget();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$reconnectTarget();\n    }\n  }, {\n    key: \"$reconnectTarget\",\n    value: function $reconnectTarget() {\n      var old_target = this.$old_target;\n      for (var i in this.$connections) {\n        var c = this.$connections[i];\n        if (c._currentConnection && old_target && old_target[i] && typeof old_target[i].disconnect === \"function\") {\n          old_target[i].disconnect(c._currentConnection);\n        }\n        if (this.target) {\n          c._currentConnection = QmlWeb.connectSignal(this.target, i, c.value, c.objectScope, c.componentScope);\n        }\n      }\n      this.$old_target = this.target;\n    }\n  }, {\n    key: \"$setCustomSlot\",\n    value: function $setCustomSlot(propName, value, objectScope, componentScope) {\n      this.$connections[propName] = { value: value, objectScope: objectScope, componentScope: componentScope };\n    }\n  }]);\n\n  return _class17;\n}());\n\n// Base object for all qml elements\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"QtObject\",\n  versions: /.*/\n}, function (_QmlWeb$QObject10) {\n  _inherits(_class18, _QmlWeb$QObject10);\n\n  function _class18(meta) {\n    _classCallCheck(this, _class18);\n\n    var _this28 = _possibleConstructorReturn(this, (_class18.__proto__ || Object.getPrototypeOf(_class18)).call(this, meta.parent));\n\n    _this28.$isComponentRoot = meta.isComponentRoot;\n    _this28.$context = meta.context;\n\n    // Component get own properties\n    _this28.$attributes = [];\n    for (var key in meta.object) {\n      if (!meta.object.hasOwnProperty(key) || !meta.object[key]) {\n        continue;\n      }\n      var name = meta.object[key].__proto__.constructor.name;\n      if (name === \"QMLPropertyDefinition\" || name === \"QMLAliasDefinition\") {\n        _this28.$attributes.push(key);\n      }\n    }\n\n    var Signal = QmlWeb.Signal;\n\n    _this28.Keys = new QmlWeb.QObject(_this28);\n    _this28.Keys.asteriskPresed = Signal.signal();\n    _this28.Keys.backPressed = Signal.signal();\n    _this28.Keys.backtabPressed = Signal.signal();\n    _this28.Keys.callPressed = Signal.signal();\n    _this28.Keys.cancelPressed = Signal.signal();\n    _this28.Keys.deletePressed = Signal.signal();\n    for (var i = 0; i < 10; ++i) {\n      _this28.Keys[\"digit\" + i + \"Pressed\"] = Signal.signal();\n    }\n    _this28.Keys.escapePressed = Signal.signal();\n    _this28.Keys.flipPressed = Signal.signal();\n    _this28.Keys.hangupPressed = Signal.signal();\n    _this28.Keys.leftPressed = Signal.signal();\n    _this28.Keys.menuPressed = Signal.signal();\n    _this28.Keys.noPressed = Signal.signal();\n    _this28.Keys.pressed = Signal.signal();\n    _this28.Keys.released = Signal.signal();\n    _this28.Keys.returnPressed = Signal.signal();\n    _this28.Keys.rightPressed = Signal.signal();\n    _this28.Keys.selectPressed = Signal.signal();\n    _this28.Keys.spacePressed = Signal.signal();\n    _this28.Keys.tabPressed = Signal.signal();\n    _this28.Keys.upPressed = Signal.signal();\n    _this28.Keys.volumeDownPressed = Signal.signal();\n    _this28.Keys.volumeUpPressed = Signal.signal();\n    _this28.Keys.yesPressed = Signal.signal();\n    return _this28;\n  }\n\n  _createClass(_class18, [{\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.$attributes;\n    }\n  }]);\n\n  return _class18;\n}(QmlWeb.QObject));\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Timer\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    interval: { type: \"int\", initialValue: 1000 },\n    parent: { type: \"QtObject\", readOnly: true },\n    repeat: \"bool\",\n    running: \"bool\",\n    triggeredOnStart: \"bool\"\n  },\n  signals: {\n    triggered: []\n  }\n}, function () {\n  function _class19(meta) {\n    var _this29 = this;\n\n    _classCallCheck(this, _class19);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$properties.parent.set(this.$parent, QmlWeb.QMLProperty.ReasonInit);\n\n    /* This ensures that if the user toggles the \"running\" property manually,\r\n     * the timer will trigger. */\n    this.runningChanged.connect(this, this.$onRunningChanged);\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this29.$ticker.apply(_this29, arguments);\n    });\n\n    QmlWeb.engine.$registerStart(function () {\n      if (_this29.running) {\n        _this29.restart();\n      }\n    });\n\n    QmlWeb.engine.$registerStop(function () {\n      return _this29.stop();\n    });\n  }\n\n  _createClass(_class19, [{\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.stop();\n      this.start();\n    }\n  }, {\n    key: \"$ticker\",\n    value: function $ticker(now) {\n      if (!this.running) return;\n      if (now - this.$prevTrigger >= this.interval) {\n        this.$prevTrigger = now;\n        this.$trigger();\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged() {\n      if (this.running) {\n        this.$prevTrigger = Date.now();\n        if (this.triggeredOnStart) {\n          this.$trigger();\n        }\n      }\n    }\n  }, {\n    key: \"$trigger\",\n    value: function $trigger() {\n      if (!this.repeat) {\n        // We set the value directly in order to be able to emit the\n        // runningChanged signal after triggered, like Qt does it.\n        this.$properties.running.val = false;\n      }\n\n      // Trigger this.\n      this.triggered();\n\n      if (!this.repeat) {\n        // Emit changed signal manually after setting the value manually above.\n        this.runningChanged();\n      }\n    }\n  }]);\n\n  return _class19;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ApplicationWindow\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Window.Window\",\n  properties: {\n    font: \"font\",\n    activeFocusControl: \"Control\",\n    background: \"Item\",\n    contentData: \"list\",\n    //contentItem: \"ContentItem\", // TODO\n    footer: \"Item\",\n    header: \"Item\",\n    overlay: \"Item\"\n  }\n}, function () {\n  function _class20(meta) {\n    _classCallCheck(this, _class20);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class20;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ApplicationWindow\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Window.Window\",\n  properties: {\n    //contentItem: \"ContentItem\", // TODO\n    menuBar: \"MenuBar\",\n    statusBar: \"Item\",\n    style: \"Component\",\n    toolBar: \"Item\"\n  }\n}, function () {\n  function _class21(meta) {\n    _classCallCheck(this, _class21);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class21;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"Button\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  signals: {\n    clicked: []\n  }\n}, function () {\n  function _class22(meta) {\n    var _this30 = this;\n\n    _classCallCheck(this, _class22);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n\n    var button = this.impl = document.createElement(\"button\");\n    button.style.pointerEvents = \"auto\";\n    this.dom.appendChild(button);\n\n    button.onclick = function () {\n      _this30.clicked();\n    };\n  }\n\n  _createClass(_class22, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.textContent = newVal;\n      //TODO: Replace those statically sized borders\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onEnabledChanged\",\n    value: function $onEnabledChanged(newVal) {\n      this.impl.disabled = !newVal;\n    }\n  }]);\n\n  return _class22;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"CheckBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    checked: \"bool\",\n    color: \"color\"\n  }\n}, function () {\n  function _class23(meta) {\n    var _this31 = this;\n\n    _classCallCheck(this, _class23);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.impl = document.createElement(\"label\");\n    this.impl.style.pointerEvents = \"auto\";\n\n    var checkbox = document.createElement(\"input\");\n    checkbox.type = \"checkbox\";\n    checkbox.style.verticalAlign = \"text-bottom\";\n    checkbox.addEventListener(\"change\", function () {\n      _this31.checked = checkbox.checked;\n    });\n    this.impl.appendChild(checkbox);\n\n    var span = document.createElement(\"span\");\n    this.impl.appendChild(span);\n\n    this.dom.appendChild(this.impl);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.checkedChanged.connect(this, this.$onCheckedChanged);\n  }\n\n  _createClass(_class23, [{\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.children[1].innerHTML = newVal;\n      this.implicitHeight = this.impl.offsetHeight;\n      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.children[1].style.color = newVal.$css;\n    }\n  }, {\n    key: \"$onCheckedChanged\",\n    value: function $onCheckedChanged() {\n      this.impl.children[0].checked = this.checked;\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitHeight = this.impl.offsetHeight;\n      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;\n    }\n  }]);\n\n  return _class23;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ComboBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    count: \"int\",\n    currentIndex: \"int\",\n    currentText: \"string\",\n    menu: { type: \"array\", initialValue: [] },\n    model: { type: \"array\", initialValue: [] },\n    pressed: \"bool\"\n  },\n  signals: {\n    accepted: [],\n    activated: [{ type: \"int\", name: \"index\" }]\n  }\n}, function () {\n  function _class24(meta) {\n    var _this32 = this;\n\n    _classCallCheck(this, _class24);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    // TODO change innerHTML to DOM\n    this.dom.innerHTML = \"<select></select>\";\n    this.impl = this.dom.firstChild;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.modelChanged.connect(this, this.$onModelChanged);\n    this.currentIndexChanged.connect(this, this.$onCurrentIndexChanged);\n    this.heightChanged.connect(this, this.$onHeightChanged);\n    this.widthChanged.connect(this, this.$onWidthChanged);\n\n    this.dom.onclick = function () {\n      var index = _this32.dom.firstChild.selectedIndex;\n      _this32.currentIndex = index;\n      _this32.currentText = _this32.model[index];\n      _this32.accepted();\n      _this32.activated(index);\n    };\n  }\n\n  _createClass(_class24, [{\n    key: \"find\",\n    value: function find(text) {\n      return this.model.indexOf(text);\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      // TODO\n    }\n  }, {\n    key: \"textAt\",\n    value: function textAt(index) {\n      return this.model[index];\n    }\n  }, {\n    key: \"$updateImpl\",\n    value: function $updateImpl() {\n      this.count = this.model.length;\n\n      var k = this.count;var m = this.model;\n\n      this.impl.options.length = k;\n      for (var i = 0; i < k; i++) {\n        this.impl.options[i] = new Option(m[i]);\n      }\n\n      // should call this, because width()/heights() invoke updateV(H)Geometry,\n      // which in turn sets valid $useImplicitHeight flag\n      var h = this.height;var w = this.width;\n\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n\n      this.$onHeightChanged(h);\n      this.$onWidthChanged(w);\n\n      this.impl.selectedIndex = this.currentIndex;\n      this.$updateCurrentText();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$updateImpl();\n    }\n  }, {\n    key: \"$onModelChanged\",\n    value: function $onModelChanged() {\n      this.$updateImpl();\n    }\n  }, {\n    key: \"$onCurrentIndexChanged\",\n    value: function $onCurrentIndexChanged() {\n      var i = this.currentIndex;\n      if (this.impl.selectedIndex !== i) {\n        this.impl.selectedIndex = i;\n        this.$updateCurrentText();\n        this.activated(i);\n      }\n    }\n  }, {\n    key: \"$updateCurrentText\",\n    value: function $updateCurrentText() {\n      if (typeof this.currentIndex === \"undefined\" || !this.model) {\n        this.currentText = undefined;\n      } else if (this.currentIndex >= 0 && this.currentIndex < this.model.length) {\n        this.currentText = this.model[this.currentIndex];\n      }\n    }\n  }, {\n    key: \"$onHeightChanged\",\n    value: function $onHeightChanged() {\n      if (this.height > 0 && this.impl && this.height !== this.impl.offsetHeight) {\n        this.impl.style.height = this.height + \"px\";\n      }\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged() {\n      if (this.width > 0 && this.impl && this.width !== this.impl.offsetWidth) {\n        this.impl.style.width = this.width + \"px\";\n      }\n    }\n  }]);\n\n  return _class24;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ScrollView\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    contentItem: \"Item\",\n    flickableItem: \"Item\", // TODO  0) implement it  1) make it read-only\n    viewport: \"Item\", // TODO\n    frameVisible: \"bool\",\n    highlightOnFocus: \"bool\", // TODO test\n    verticalScrollBarPolicy: \"enum\",\n    horizontalScrollBarPolicy: \"enum\",\n    style: \"Component\" // TODO\n  },\n  defaultProperty: \"contentItem\"\n}, function () {\n  function _class25(meta) {\n    _classCallCheck(this, _class25);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    this.contentItemChanged.connect(this, this.$onContentItemChanged);\n    this.flickableItemChanged.connect(this, this.$onFlickableItemChanged);\n    this.viewportChanged.connect(this, this.$onViewportChanged);\n    this.frameVisibleChanged.connect(this, this.$onFrameVisibleChanged);\n    this.highlightOnFocusChanged.connect(this, this.$onHighlightOnFocusChanged);\n    this.horizontalScrollBarPolicyChanged.connect(this, this.$onHorizontalScrollBarPolicyChanged);\n    this.verticalScrollBarPolicyChanged.connect(this, this.$onVerticalScrollBarPolicyChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.focusChanged.connect(this, this.$onFocusChanged);\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    var Qt = QmlWeb.Qt;\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n\n    this.$onVerticalScrollBarPolicyChanged(this.verticalScrollBarPolicy);\n    this.$onHorizontalScrollBarPolicyChanged(this.horizontalScrollBarPolicy);\n  }\n\n  _createClass(_class25, [{\n    key: \"$onContentItemChanged\",\n    value: function $onContentItemChanged(newItem) {\n      if ((typeof newItem === \"undefined\" ? \"undefined\" : _typeof(newItem)) !== undefined) {\n        newItem.parent = this;\n      }\n    }\n  }, {\n    key: \"$onFlickableItemChanged\",\n    value: function $onFlickableItemChanged() {}\n  }, {\n    key: \"$onHighlightOnFocusChanged\",\n    value: function $onHighlightOnFocusChanged() {}\n  }, {\n    key: \"$onViewportChanged\",\n    value: function $onViewportChanged() {}\n  }, {\n    key: \"$onFocusChanged\",\n    value: function $onFocusChanged(focus) {\n      this.css.outline = this.highlight && focus ? \"outline: lightblue solid 2px;\" : \"\";\n    }\n  }, {\n    key: \"$onFrameVisibleChanged\",\n    value: function $onFrameVisibleChanged(visible) {\n      this.css.border = visible ? \"1px solid gray\" : \"hidden\";\n    }\n  }, {\n    key: \"$onHorizontalScrollBarPolicyChanged\",\n    value: function $onHorizontalScrollBarPolicyChanged(newPolicy) {\n      this.css.overflowX = this.$scrollBarPolicyToCssOverflow(newPolicy);\n    }\n  }, {\n    key: \"$onVerticalScrollBarPolicyChanged\",\n    value: function $onVerticalScrollBarPolicyChanged(newPolicy) {\n      this.css.overflowY = this.$scrollBarPolicyToCssOverflow(newPolicy);\n    }\n  }, {\n    key: \"$onStyleChanged\",\n    value: function $onStyleChanged() {}\n  }, {\n    key: \"$onChildrenChanged\",\n    value: function $onChildrenChanged() {\n      if (typeof this.contentItem === \"undefined\" && this.children.length === 1) {\n        this.contentItem = this.children[0];\n      }\n    }\n  }, {\n    key: \"$scrollBarPolicyToCssOverflow\",\n    value: function $scrollBarPolicyToCssOverflow(policy) {\n      var Qt = QmlWeb.Qt;\n      switch (policy) {\n        case Qt.ScrollBarAsNeeded:\n          return \"auto\";\n        case Qt.ScrollBarAlwaysOff:\n          return \"hidden\";\n        case Qt.ScrollBarAlwaysOn:\n          return \"scroll\";\n      }\n      return \"auto\";\n    }\n  }]);\n\n  return _class25;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextArea\",\n  versions: /.*/,\n  baseClass: \"QtQuick.TextEdit\"\n}, function () {\n  function _class26(meta) {\n    _classCallCheck(this, _class26);\n\n    QmlWeb.callSuper(this, meta);\n    var textarea = this.impl;\n    textarea.style.padding = \"5px\";\n    textarea.style.borderWidth = \"1px\";\n    textarea.style.backgroundColor = \"#fff\";\n  }\n\n  return _class26;\n}());\n\n/**\r\n *\r\n * TextField is used to accept a line of text input.\r\n * Input constraints can be placed on a TextField item\r\n * (for example, through a validator or inputMask).\r\n * Setting echoMode to an appropriate value enables TextField\r\n * to be used for a password input field.\r\n *\r\n * Valid entries for echoMode and alignment are defined in TextInput.\r\n *\r\n */\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextField\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, function () {\n  function _class27(meta) {\n    var _this33 = this;\n\n    _classCallCheck(this, _class27);\n\n    QmlWeb.callSuper(this, meta);\n\n    var input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this33.$updateValue();\n    });\n  }\n\n  _createClass(_class27, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      // See TextInput for comments\n      if (this.impl.value !== newVal) {\n        this.impl.value = newVal;\n      }\n    }\n  }, {\n    key: \"$onEchoModeChanged\",\n    value: function $onEchoModeChanged(newVal) {\n      var TextInput = this.TextInput;\n      var input = this.impl;\n      switch (newVal) {\n        case TextInput.Normal:\n          input.type = \"text\";\n          break;\n        case TextInput.Password:\n          input.type = \"password\";\n          break;\n        case TextInput.NoEcho:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n        case TextInput.PasswordEchoOnEdit:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onMaximumLengthChanged\",\n    value: function $onMaximumLengthChanged(newVal) {\n      this.impl.maxLength = newVal < 0 ? null : newVal;\n    }\n  }, {\n    key: \"$onReadOnlyChanged\",\n    value: function $onReadOnlyChanged(newVal) {\n      this.impl.disabled = newVal;\n    }\n  }, {\n    key: \"Keys$onPressed\",\n    value: function Keys$onPressed(e) {\n      var Qt = QmlWeb.Qt;\n      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n      if (submit && this.$testValidator()) {\n        this.accepted();\n        e.accepted = true;\n      }\n    }\n  }, {\n    key: \"$testValidator\",\n    value: function $testValidator() {\n      if (this.validator) {\n        return this.validator.validate(this.text);\n      }\n      return true;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.$canEditReadOnlyProperties = true;\n        this.text = this.impl.value;\n        this.$canEditReadOnlyProperties = false;\n      }\n    }\n  }]);\n\n  return _class27;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"AngleDirection\",\n  versions: /^2\\./,\n  baseClass: \"Direction\",\n  properties: {\n    angle: \"real\",\n    angleVariation: \"real\",\n    magnitude: \"real\",\n    magnitudeVariation: \"real\"\n  }\n}, function () {\n  function _class28(meta) {\n    _classCallCheck(this, _class28);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class28;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"CustomParticle\",\n  versions: /^2\\./,\n  baseClass: \"ParticlePainter\",\n  properties: {\n    fragmentShader: \"string\",\n    vertexShader: \"string\"\n  }\n}, function () {\n  function _class29(meta) {\n    _classCallCheck(this, _class29);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class29;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"Direction\",\n  versions: /^2\\./,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function _class30(meta) {\n    _classCallCheck(this, _class30);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class30;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"Emitter\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    acceleration: \"StochasticDirection\",\n    emitRate: { type: \"real\", initialValue: 10 },\n    enabled: { type: \"bool\", initialValue: true },\n    endSize: { type: \"real\", initialValue: -1 },\n    group: \"string\",\n    lifeSpan: { type: \"int\", initialValue: 1000 },\n    lifeSpanVariation: \"int\",\n    maximumEmitted: { type: \"int\", initialValue: -1 },\n    shape: \"Shape\",\n    size: { type: \"real\", initialValue: 16 },\n    sizeVariation: \"real\",\n    startTime: \"int\",\n    system: \"ParticleSystem\",\n    velocity: \"StochasticDirection\",\n    velocityFromMovement: \"real\"\n  },\n  signals: {\n    emitParticles: [{ type: \"Array\", name: \"particles\" }]\n  }\n}, function () {\n  function _class31(meta) {\n    _classCallCheck(this, _class31);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class31, [{\n    key: \"burst\",\n    value: function burst() /*count, x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"pulse\",\n    value: function pulse(duration) {\n      var _this34 = this;\n\n      if (this.enabled) return;\n      this.enabled = true;\n      setTimeout(function () {\n        _this34.enabled = false;\n      }, duration);\n    }\n  }]);\n\n  return _class31;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"ParticlePainter\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    groups: \"list\",\n    system: \"ParticleSystem\"\n  }\n}, function () {\n  function _class32(meta) {\n    _classCallCheck(this, _class32);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class32;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"ParticleSystem\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    empty: \"bool\",\n    particleStates: \"list\",\n    paused: \"bool\",\n    running: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class33(meta) {\n    _classCallCheck(this, _class33);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class33, [{\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      // TODO\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.running = false;\n      this.running = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }]);\n\n  return _class33;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Window\",\n  name: \"Screen\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function Screen(meta) {\n    _classCallCheck(this, Screen);\n\n    QmlWeb.callSuper(this, meta);\n    throw new Error(\"Screen can only be used via the attached property.\");\n  }\n\n  _createClass(Screen, null, [{\n    key: \"getAttachedObject\",\n    value: function getAttachedObject() {\n      if (!Screen.$Screen) {\n        var screen = Screen.$Screen = new QmlWeb.QObject();\n        // TODO: read-only\n        QmlWeb.createProperties(screen, {\n          name: \"string\",\n          orientation: \"enum\",\n          orientationUpdateMask: \"enum\",\n          primaryOrientation: \"enum\",\n          pixelDensity: \"real\",\n          devicePixelRatio: \"real\",\n          desktopAvailableHeight: \"int\",\n          desktopAvailableWidth: \"int\",\n          height: \"int\",\n          width: \"int\"\n        });\n        screen.name = window.navigator.appName;\n        screen.devicePixelRatio = window.devicePixelRatio;\n        screen.pixelDensity = window.devicePixelRatio * 96 / 25.4; // per mm\n        Screen.$populateScreen();\n        window.addEventListener(\"resize\", function () {\n          return Screen.$populateScreen();\n        });\n\n        // TODO: orientation\n        var _Qt = QmlWeb.Qt;\n        screen.orientationUpdateMask = 0;\n        screen.orientation = _Qt.PrimaryOrientation;\n        screen.primaryOrientation = _Qt.PrimaryOrientation;\n      }\n      return Screen.$Screen;\n    }\n  }, {\n    key: \"$populateScreen\",\n    value: function $populateScreen() {\n      var screen = Screen.$Screen;\n      screen.desktopAvailableHeight = window.outerHeight;\n      screen.desktopAvailableWidth = window.outerWidth;\n      screen.height = window.innerHeight;\n      screen.width = window.innerWidth;\n    }\n  }]);\n\n  return Screen;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Window\",\n  name: \"Window\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    active: \"bool\",\n    activeFocusItem: \"Item\",\n    color: { type: \"color\", initialValue: \"#ffffff\" },\n    //contentItem: \"Item\", // TODO\n    contentOrientation: \"enum\",\n    flags: \"int\",\n    maximumHeight: \"int\",\n    maximumWidth: \"int\",\n    minimumHeight: \"int\",\n    minimumWidth: \"int\",\n    modality: \"enum\",\n    title: \"string\",\n    visibility: \"enum\"\n  },\n  signals: {\n    closing: [{ type: \"CloseEvent\", name: \"close\" }]\n  }\n}, function () {\n  function _class34(meta) {\n    _classCallCheck(this, _class34);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n  }\n\n  _createClass(_class34, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.dom.style.backgroundColor = newVal.$css;\n    }\n  }]);\n\n  return _class34;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"AnimatedImage\",\n  versions: /.*/,\n  baseClass: \"Image\"\n}, function () {\n  function _class35(meta) {\n    _classCallCheck(this, _class35);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class35;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Animation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Animation: { Infinite: -1 },\n    Easing: QmlWeb.Easing\n  },\n  properties: {\n    alwaysRunToEnd: \"bool\",\n    loops: { type: \"int\", initialValue: 1 },\n    paused: \"bool\",\n    running: \"bool\"\n  }\n}, function () {\n  function _class36(meta) {\n    _classCallCheck(this, _class36);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class36, [{\n    key: \"restart\",\n    value: function restart() {\n      this.stop();\n      this.start();\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      // To be overridden\n      console.log(\"Unbound method for\", this);\n    }\n  }]);\n\n  return _class36;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Animator\",\n  versions: /^2\\./,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 },\n    from: \"real\",\n    target: \"Item\",\n    to: \"real\"\n  }\n}, function () {\n  function _class37(meta) {\n    _classCallCheck(this, _class37);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.easing = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.easing, {\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\n      amplitude: { type: \"real\", initialValue: 1 },\n      overshoot: { type: \"real\", initialValue: 1.70158 },\n      period: { type: \"real\", initialValue: 0.3 },\n      bezierCurve: \"list\"\n    });\n  }\n\n  return _class37;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Behavior\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animation: \"Animation\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  defaultProperty: \"animation\"\n}, function () {\n  function _class38(meta) {\n    _classCallCheck(this, _class38);\n\n    QmlWeb.callSuper(this, meta);\n    this.$on = meta.object.$on;\n\n    this.animationChanged.connect(this, this.$onAnimationChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n  }\n\n  _createClass(_class38, [{\n    key: \"$onAnimationChanged\",\n    value: function $onAnimationChanged(newVal) {\n      newVal.target = this.$parent;\n      newVal.property = this.$on;\n      this.$parent.$properties[this.$on].animation = newVal;\n    }\n  }, {\n    key: \"$onEnabledChanged\",\n    value: function $onEnabledChanged(newVal) {\n      this.$parent.$properties[this.$on].animation = newVal ? this.animation : null;\n    }\n  }]);\n\n  return _class38;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"BorderImage\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    BorderImage: {\n      Stretch: \"stretch\", Repeat: \"repeat\", Round: \"round\",\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    source: \"url\",\n    smooth: { type: \"bool\", initialValue: true },\n    // BorderImage.Stretch\n    horizontalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    // BorderImage.Stretch\n    verticalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    progress: \"real\",\n    status: { type: \"enum\", initialValue: 1 } // BorderImage.Null\n  }\n}, function () {\n  function _class39(meta) {\n    var _this35 = this;\n\n    _classCallCheck(this, _class39);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.border = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.border, {\n      left: \"int\",\n      right: \"int\",\n      top: \"int\",\n      bottom: \"int\"\n    });\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    bg.style.boxSizing = \"border-box\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", function () {\n      _this35.progress = 1;\n      _this35.status = _this35.BorderImage.Ready;\n    });\n    this.$img.addEventListener(\"error\", function () {\n      _this35.status = _this35.BorderImage.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.border.leftChanged.connect(this, this.$updateBorder);\n    this.border.rightChanged.connect(this, this.$updateBorder);\n    this.border.topChanged.connect(this, this.$updateBorder);\n    this.border.bottomChanged.connect(this, this.$updateBorder);\n    this.horizontalTileModeChanged.connect(this, this.$updateBorder);\n    this.verticalTileModeChanged.connect(this, this.$updateBorder);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n\n  _createClass(_class39, [{\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      this.progress = 0;\n      this.status = this.BorderImage.Loading;\n      var style = this.impl.style;\n      var imageURL = QmlWeb.engine.$resolveImageURL(source);\n      style.OBorderImageSource = \"url(\\\"\" + imageURL + \"\\\")\";\n      style.borderImageSource = \"url(\\\"\" + imageURL + \"\\\")\";\n      this.$img.src = imageURL;\n      if (this.$img.complete) {\n        this.progress = 1;\n        this.status = this.BorderImage.Ready;\n      }\n    }\n  }, {\n    key: \"$updateBorder\",\n    value: function $updateBorder() {\n      var style = this.impl.style;\n      var _border = this.border,\n          right = _border.right,\n          left = _border.left,\n          top = _border.top,\n          bottom = _border.bottom;\n\n      var slice = top + \" \" + right + \" \" + bottom + \" \" + left + \" fill\";\n      var width = top + \"px \" + right + \"px \" + bottom + \"px \" + left + \"px\";\n      var repeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n      style.OBorderImageSlice = slice;\n      style.OBorderImageRepeat = repeat;\n      style.OBorderImageWidth = width;\n      style.borderImageSlice = slice;\n      style.borderImageRepeat = repeat;\n      style.borderImageWidth = width;\n    }\n  }, {\n    key: \"$onSmoothChanged\",\n    value: function $onSmoothChanged(val) {\n      var style = this.impl.style;\n      if (val) {\n        style.imageRendering = \"auto\";\n      } else {\n        style.imageRendering = \"-webkit-optimize-contrast\";\n        style.imageRendering = \"-moz-crisp-edges\";\n        style.imageRendering = \"crisp-edges\";\n        style.imageRendering = \"pixelated\";\n      }\n    }\n  }]);\n\n  return _class39;\n}());\n\n// TODO\n// Currently only a skeleton implementation\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Canvas\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    available: { type: \"bool\", initialValue: true },\n    canvasSize: { type: \"var\", initialValue: [0, 0] },\n    canvasWindow: { type: \"var\", initialValue: [0, 0, 0, 0] },\n    context: { type: \"var\", initialValue: {} },\n    contextType: { type: \"string\", initialValue: \"contextType\" },\n    renderStrategy: \"enum\",\n    renderTarget: \"enum\",\n    tileSize: { type: \"var\", initialValue: [0, 0] }\n  },\n  signals: {\n    imageLoaded: [],\n    paint: [{ type: \"var\", name: \"region\" }],\n    painted: []\n  }\n}, function () {\n  function _class40(meta) {\n    _classCallCheck(this, _class40);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class40, [{\n    key: \"cancelRequestAnimationFrame\",\n    value: function cancelRequestAnimationFrame() /*handle*/{\n      return false;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() /*context_id, ...args*/{\n      return {};\n    }\n  }, {\n    key: \"isImageError\",\n    value: function isImageError() /*image*/{\n      return true;\n    }\n  }, {\n    key: \"isImageLoaded\",\n    value: function isImageLoaded() /*image*/{\n      return false;\n    }\n  }, {\n    key: \"isImageLoading\",\n    value: function isImageLoading() /*image*/{\n      return false;\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(image) {\n      //loadImageAsync(image);\n      if (this.isImageLoaded(image)) {\n        this.imageLoaded();\n      }\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty(area) {\n      // if dirty\n      this.paint(area);\n    }\n  }, {\n    key: \"requestAnimationFrame\",\n    value: function requestAnimationFrame() /*callback*/{\n      return 0;\n    }\n  }, {\n    key: \"requestPaint\",\n    value: function requestPaint() {}\n  }, {\n    key: \"save\",\n    value: function save() /*file_name*/{\n      return false;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() /*mime_type*/{\n      return \"\";\n    }\n  }, {\n    key: \"unloadImage\",\n    value: function unloadImage() /*image*/{}\n  }]);\n\n  return _class40;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Column\",\n  versions: /.*/,\n  baseClass: \"Positioner\"\n}, function () {\n  function _class41(meta) {\n    _classCallCheck(this, _class41);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class41, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      var curPos = this.padding;\n      var maxWidth = 0;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.visible || !child.width || !child.height) {\n          continue;\n        }\n        maxWidth = child.width > maxWidth ? child.width : maxWidth;\n        child.y = curPos + this.padding;\n        if (this.padding > 0) child.x = this.padding;\n        curPos += child.height + this.spacing;\n      }\n      this.implicitWidth = maxWidth + this.padding * 2;\n      this.implicitHeight = curPos - this.spacing + this.padding;\n      // We want no spacing at the bottom side\n    }\n  }]);\n\n  return _class41;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"DoubleValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    DoubleValidator: { StandardNotation: 1, ScientificNotation: 2 }\n  },\n  properties: {\n    bottom: { type: \"real\", initialValue: -Infinity },\n    top: { type: \"real\", initialValue: Infinity },\n    decimals: { type: \"int\", initialValue: 1000 },\n    // DoubleValidator.ScientificNotation\n    notation: { type: \"enum\", initialValue: 2 }\n  }\n}, function () {\n  function _class42(meta) {\n    _classCallCheck(this, _class42);\n\n    QmlWeb.callSuper(this, meta);\n    this.$standardRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n    this.$scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n  }\n\n  _createClass(_class42, [{\n    key: \"getRegExpForNotation\",\n    value: function getRegExpForNotation(notation) {\n      switch (notation) {\n        case this.DoubleValidator.ScientificNotation:\n          return this.$scientificRegExp;\n        case this.DoubleValidator.StandardNotation:\n          return this.$standardRegExp;\n      }\n      return null;\n    }\n  }, {\n    key: \"$getDecimalsForNumber\",\n    value: function $getDecimalsForNumber(number) {\n      if (Math.round(number) === number) {\n        return 0;\n      }\n      var str = \"\" + number;\n      return (/\\d*$/.exec(str)[0].length\n      );\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(string) {\n      var regExp = this.getRegExpForNotation(this.notation);\n      if (!regExp.test(string.trim())) {\n        return false;\n      }\n      var value = parseFloat(string);\n      return this.bottom <= value && this.top >= value && this.$getDecimalsForNumber(value) <= this.decimals;\n    }\n  }]);\n\n  return _class42;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Flow\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Flow: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    flow: \"enum\", // Flow.LeftToRight\n    layoutDirection: \"enum\" // Flow.LeftToRight\n  }\n}, function () {\n  function _class43(meta) {\n    _classCallCheck(this, _class43);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.heightChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class43, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      if (this.flow === undefined) {\n        // Flow has not been fully initialized yet\n        return;\n      }\n\n      var curHPos = 0;\n      var curVPos = 0;\n      var rowSize = 0;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.visible || !child.width || !child.height) {\n          continue;\n        }\n\n        if (this.flow === this.Flow.LeftToRight) {\n          if (!this.$isUsingImplicitWidth && curHPos + child.width > this.width) {\n            curHPos = 0;\n            curVPos += rowSize + this.spacing;\n            rowSize = 0;\n          }\n          rowSize = child.height > rowSize ? child.height : rowSize;\n          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;\n          child.y = curVPos;\n          curHPos += child.width + this.spacing;\n        } else {\n          // Flow.TopToBottom\n          if (!this.$isUsingImplicitHeight && curVPos + child.height > this.height) {\n            curVPos = 0;\n            curHPos += rowSize + this.spacing;\n            rowSize = 0;\n          }\n          rowSize = child.width > rowSize ? child.width : rowSize;\n          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;\n          child.y = curVPos;\n          curVPos += child.height + this.spacing;\n        }\n      }\n\n      if (this.flow === this.Flow.LeftToRight) {\n        this.implicitWidth = curHPos - this.spacing;\n        this.implicitHeight = curVPos + rowSize;\n      } else {\n        // Flow.TopToBottom\n        this.implicitWidth = curHPos + rowSize;\n        this.implicitHeight = curVPos - this.spacing;\n      }\n    }\n  }]);\n\n  return _class43;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"FocusScope\",\n  versions: /.*/,\n  baseClass: \"Item\"\n}, function () {\n  function _class44(meta) {\n    _classCallCheck(this, _class44);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class44;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"FontLoader\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    FontLoader: { Null: 0, Ready: 1, Loading: 2, Error: 3 }\n  },\n  properties: {\n    name: \"string\",\n    source: \"url\",\n    status: \"enum\" // FontLoader.Null\n  }\n}, function () {\n  function _class45(meta) {\n    _classCallCheck(this, _class45);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$lastName = \"\";\n    this.$inTouchName = false;\n\n    /*\r\n      Maximum timeout is the maximum time for a font to load. If font isn't\r\n      loaded in this time, the status is set to Error.\r\n      For both cases (with and without FontLoader.js) if the font takes more\r\n      than the maximum timeout to load, dimensions recalculations for elements\r\n      that are using this font will not be triggered or will have no effect.\r\n        FontLoader.js uses only the last timeout. The state and name properties\r\n      are set immediately when the font loads. If the font could not be loaded,\r\n      the Error status will be set only when this timeout expires. If the font\r\n      loading takes more than the timeout, the name property is set, but the\r\n      status is set to Error.\r\n        Fallback sets the font name immediately and touches it several times to\r\n      trigger dimensions recalcuations. The status is set to Error and should\r\n      not be used.\r\n    */\n    // 15 seconds maximum\n    this.$timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000];\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.nameChanged.connect(this, this.$onNameChanged);\n  }\n\n  _createClass(_class45, [{\n    key: \"$loadFont\",\n    value: function $loadFont(fontName, fontFace) {\n      var _this36 = this;\n\n      /* global FontLoader */\n      if (this.$lastName === fontName || this.$inTouchName) {\n        return;\n      }\n      this.$lastName = fontName;\n\n      if (!fontName) {\n        this.status = this.FontLoader.Null;\n        return;\n      }\n      this.status = this.FontLoader.Loading;\n\n      var promise = void 0;\n      if (fontFace) {\n        promise = fontFace.loaded;\n      } else if (document.fonts && document.fonts.load) {\n        promise = document.fonts.load(fontName);\n      }\n\n      if (promise) {\n        promise.then(function () {\n          if (_this36.$lastName !== fontName) return;\n          _this36.name = fontName;\n          _this36.status = _this36.FontLoader.Ready;\n        }, function () {\n          if (_this36.$lastName !== fontName) return;\n          _this36.status = _this36.FontLoader.Error;\n        });\n      } else if (typeof FontLoader === \"function\") {\n        var fontLoader = new FontLoader([fontName], {\n          fontsLoaded: function fontsLoaded(error) {\n            if (error !== null) {\n              if (_this36.$lastName === fontName && error.notLoadedFontFamilies[0] === fontName) {\n                // Set the name for the case of font loading after the timeout.\n                _this36.name = fontName;\n                _this36.status = _this36.FontLoader.Error;\n              }\n            }\n          },\n          fontLoaded: function fontLoaded(fontFamily) {\n            if (_this36.$lastName === fontName && fontFamily === fontName) {\n              _this36.name = fontName;\n              _this36.status = _this36.FontLoader.Ready;\n            }\n          }\n        }, this.$timeouts[this.$timeouts.length - 1]);\n        // Else I get problems loading multiple fonts (FontLoader.js bug?)\n        FontLoader.testDiv = null;\n        fontLoader.loadFonts();\n      } else {\n        console.warn(\"FontLoader.js library is not loaded.\\nYou should load FontLoader.js if you want to use QtQuick FontLoader elements.\\nRefs: https://github.com/smnh/FontLoader.\");\n        // You should not rely on 'status' property without FontLoader.js.\n        this.status = this.FontLoader.Error;\n        this.name = fontName;\n        this.$cycleTouchName(fontName, 0);\n      }\n    }\n  }, {\n    key: \"$cycleTouchName\",\n    value: function $cycleTouchName(fontName, i) {\n      var _this37 = this;\n\n      if (this.$lastName !== fontName) {\n        return;\n      }\n      if (i > 0) {\n        var name = this.name;\n        this.$inTouchName = true;\n        // Calling this.nameChanged() is not enough, we have to actually change\n        // the value to flush the bindings.\n        this.name = \"sans-serif\";\n        this.name = name;\n        this.$inTouchName = false;\n      }\n      if (i < this.$timeouts.length) {\n        setTimeout(function () {\n          _this37.$cycleTouchName(fontName, i + 1);\n        }, this.$timeouts[i] - (i > 0 ? this.$timeouts[i - 1] : 0));\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(font_src) {\n      // Load font by source url\n      var rand = Math.round(Math.random() * 1e15);\n      var fontName = \"font_\" + Date.now().toString(36) + \"_\" + rand.toString(36);\n      if ((typeof FontFace === \"undefined\" ? \"undefined\" : _typeof(FontFace)) !== undefined && document.fonts && document.fonts.add) {\n        var fontFace = new FontFace(fontName, \"url('\" + font_src + \"')\");\n        document.fonts.add(fontFace);\n        fontFace.load();\n        this.$loadFont(fontName, fontFace);\n        return;\n      }\n      if (!this.$domStyle) {\n        this.$domStyle = document.createElement(\"style\");\n      }\n      this.$domStyle.innerHTML = \"@font-face {\\n      font-family: \" + fontName + \";\\n      src: url('\" + font_src + \"');\\n    }\";\n      document.getElementsByTagName(\"head\")[0].appendChild(this.$domStyle);\n      this.$loadFont(fontName);\n    }\n  }, {\n    key: \"$onNameChanged\",\n    value: function $onNameChanged(fontName) {\n      // Load font by the name\n      this.$loadFont(fontName);\n    }\n  }]);\n\n  return _class45;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Grid\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Grid: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    columns: \"int\",\n    rows: \"int\",\n    flow: \"enum\",\n    layoutDirection: \"enum\"\n  }\n}, function () {\n  function _class46(meta) {\n    _classCallCheck(this, _class46);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class46, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      // How many items are actually visible?\n      var visibleItems = this.$getVisibleItems();\n\n      // How many rows and columns do we need?\n\n      var _$calculateSize = this.$calculateSize(visibleItems.length),\n          _$calculateSize2 = _slicedToArray(_$calculateSize, 2),\n          c = _$calculateSize2[0],\n          r = _$calculateSize2[1];\n\n      // How big are the colums/rows?\n\n\n      var _$calculateGrid = this.$calculateGrid(visibleItems, c, r),\n          _$calculateGrid2 = _slicedToArray(_$calculateGrid, 2),\n          colWidth = _$calculateGrid2[0],\n          rowHeight = _$calculateGrid2[1];\n\n      // Do actual positioning\n      // When layoutDirection is RightToLeft we need oposite order of coumns\n\n\n      var step = this.layoutDirection === 1 ? -1 : 1;\n      var startingPoint = this.layoutDirection === 1 ? c - 1 : 0;\n      var endPoint = this.layoutDirection === 1 ? -1 : c;\n      var curHPos = 0;\n      var curVPos = 0;\n      if (this.flow === 0) {\n        for (var i = 0; i < r; i++) {\n          for (var j = startingPoint; j !== endPoint; j += step) {\n            var item = visibleItems[i * c + j];\n            if (!item) {\n              break;\n            }\n            item.x = curHPos;\n            item.y = curVPos;\n\n            curHPos += colWidth[j] + this.spacing;\n          }\n          curVPos += rowHeight[i] + this.spacing;\n          curHPos = 0;\n        }\n      } else {\n        for (var _i2 = startingPoint; _i2 !== endPoint; _i2 += step) {\n          for (var _j = 0; _j < r; _j++) {\n            var _item = visibleItems[_i2 * r + _j];\n            if (!_item) {\n              break;\n            }\n            _item.x = curHPos;\n            _item.y = curVPos;\n\n            curVPos += rowHeight[_j] + this.spacing;\n          }\n          curHPos += colWidth[_i2] + this.spacing;\n          curVPos = 0;\n        }\n      }\n\n      // Set implicit size\n      var gridWidth = -this.spacing;\n      var gridHeight = -this.spacing;\n      for (var _i3 in colWidth) {\n        gridWidth += colWidth[_i3] + this.spacing;\n      }\n      for (var _i4 in rowHeight) {\n        gridHeight += rowHeight[_i4] + this.spacing;\n      }\n      this.implicitWidth = gridWidth;\n      this.implicitHeight = gridHeight;\n    }\n  }, {\n    key: \"$getVisibleItems\",\n    value: function $getVisibleItems() {\n      return this.children.filter(function (child) {\n        return child.visible && child.width && child.height;\n      });\n    }\n  }, {\n    key: \"$calculateSize\",\n    value: function $calculateSize(length) {\n      var cols = void 0;\n      var rows = void 0;\n      if (!this.columns && !this.rows) {\n        cols = 4;\n        rows = Math.ceil(length / cols);\n      } else if (!this.columns) {\n        rows = this.rows;\n        cols = Math.ceil(length / rows);\n      } else {\n        cols = this.columns;\n        rows = Math.ceil(length / cols);\n      }\n      return [cols, rows];\n    }\n  }, {\n    key: \"$calculateGrid\",\n    value: function $calculateGrid(visibleItems, cols, rows) {\n      var colWidth = [];\n      var rowHeight = [];\n\n      if (this.flow === 0) {\n        for (var i = 0; i < rows; i++) {\n          for (var j = 0; j < cols; j++) {\n            var item = visibleItems[i * cols + j];\n            if (!item) {\n              break;\n            }\n            if (!colWidth[j] || item.width > colWidth[j]) {\n              colWidth[j] = item.width;\n            }\n            if (!rowHeight[i] || item.height > rowHeight[i]) {\n              rowHeight[i] = item.height;\n            }\n          }\n        }\n      } else {\n        for (var _i5 = 0; _i5 < cols; _i5++) {\n          for (var _j2 = 0; _j2 < rows; _j2++) {\n            var _item2 = visibleItems[_i5 * rows + _j2];\n            if (!_item2) {\n              break;\n            }\n            if (!rowHeight[_j2] || _item2.height > rowHeight[_j2]) {\n              rowHeight[_j2] = _item2.height;\n            }\n            if (!colWidth[_i5] || _item2.width > colWidth[_i5]) {\n              colWidth[_i5] = _item2.width;\n            }\n          }\n        }\n      }\n\n      return [colWidth, rowHeight];\n    }\n  }]);\n\n  return _class46;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Image\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Image: {\n      Stretch: 1, PreserveAspectFit: 2, PreserveAspectCrop: 3,\n      Tile: 4, TileVertically: 5, TileHorizontally: 6,\n\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    asynchronous: { type: \"bool\", initialValue: true },\n    cache: { type: \"bool\", initialValue: true },\n    smooth: { type: \"bool\", initialValue: true },\n    fillMode: { type: \"enum\", initialValue: 1 }, // Image.Stretch\n    mirror: \"bool\",\n    progress: \"real\",\n    source: \"url\",\n    status: { type: \"enum\", initialValue: 1 } // Image.Null\n  }\n}, function () {\n  function _class47(meta) {\n    var _this38 = this;\n\n    _classCallCheck(this, _class47);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.sourceSize = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.sourceSize, {\n      width: \"int\",\n      height: \"int\"\n    });\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", function () {\n      var w = _this38.$img.naturalWidth;\n      var h = _this38.$img.naturalHeight;\n      _this38.sourceSize.width = w;\n      _this38.sourceSize.height = h;\n      _this38.implicitWidth = w;\n      _this38.implicitHeight = h;\n      _this38.progress = 1;\n      _this38.status = _this38.Image.Ready;\n    });\n    this.$img.addEventListener(\"error\", function () {\n      _this38.status = _this38.Image.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.mirrorChanged.connect(this, this.$onMirrorChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n\n  _createClass(_class47, [{\n    key: \"$updateFillMode\",\n    value: function $updateFillMode() {\n      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.fillMode;\n\n      var style = this.impl.style;\n      switch (val) {\n        default:\n        case this.Image.Stretch:\n          style.backgroundRepeat = \"auto\";\n          style.backgroundSize = \"100% 100%\";\n          style.backgroundPosition = \"auto\";\n          break;\n        case this.Image.Tile:\n          style.backgroundRepeat = \"auto\";\n          style.backgroundSize = \"auto\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.PreserveAspectFit:\n          style.backgroundRepeat = \"no-repeat\";\n          style.backgroundSize = \"contain\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.PreserveAspectCrop:\n          style.backgroundRepeat = \"no-repeat\";\n          style.backgroundSize = \"cover\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.TileVertically:\n          style.backgroundRepeat = \"repeat-y\";\n          style.backgroundSize = \"100% auto\";\n          style.backgroundPosition = \"auto\";\n          break;\n        case this.Image.TileHorizontally:\n          style.backgroundRepeat = \"repeat-x\";\n          style.backgroundSize = \"auto 100%\";\n          style.backgroundPosition = \"auto\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      this.progress = 0;\n      this.status = this.Image.Loading;\n      var imageURL = QmlWeb.engine.$resolveImageURL(source);\n      this.impl.style.backgroundImage = \"url(\\\"\" + imageURL + \"\\\")\";\n      this.$img.src = imageURL;\n      if (this.$img.complete) {\n        this.progress = 1;\n        this.status = this.Image.Ready;\n      }\n      this.$updateFillMode();\n    }\n  }, {\n    key: \"$onMirrorChanged\",\n    value: function $onMirrorChanged(val) {\n      var transformRule = \"scale(-1,1)\";\n      if (!val) {\n        var index = this.transform.indexOf(transformRule);\n        if (index >= 0) {\n          this.transform.splice(index, 1);\n        }\n      } else {\n        this.transform.push(transformRule);\n      }\n      this.$updateTransform();\n    }\n  }, {\n    key: \"$onFillModeChanged\",\n    value: function $onFillModeChanged(val) {\n      this.$updateFillMode(val);\n    }\n  }, {\n    key: \"$onSmoothChanged\",\n    value: function $onSmoothChanged(val) {\n      var style = this.impl.style;\n      if (val) {\n        style.imageRendering = \"auto\";\n      } else {\n        style.imageRendering = \"-webkit-optimize-contrast\";\n        style.imageRendering = \"-moz-crisp-edges\";\n        style.imageRendering = \"crisp-edges\";\n        style.imageRendering = \"pixelated\";\n      }\n    }\n  }]);\n\n  return _class47;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"IntValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    bottom: { type: \"int\", initialValue: -2147483647 },\n    top: { type: \"int\", initialValue: 2147483647 }\n  }\n}, function () {\n  function _class48(meta) {\n    _classCallCheck(this, _class48);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class48, [{\n    key: \"validate\",\n    value: function validate(string) {\n      var regExp = /^(-|\\+)?\\s*[0-9]+$/;\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value = parseInt(string, 10);\n        acceptable = this.bottom <= value && this.top >= value;\n      }\n      return acceptable;\n    }\n  }]);\n\n  return _class48;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Item\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    $opacity: { type: \"real\", initialValue: 1 },\n    parent: \"Item\",\n    antialiasing: \"bool\",\n    state: \"string\",\n    states: \"list\",\n    transitions: \"list\",\n    data: \"list\",\n    children: \"list\",\n    resources: \"list\",\n    transform: \"list\",\n    x: \"real\",\n    y: \"real\",\n    z: \"real\",\n    width: \"real\",\n    height: \"real\",\n    implicitWidth: \"real\",\n    implicitHeight: \"real\",\n    left: \"real\",\n    right: \"real\",\n    top: \"real\",\n    bottom: \"real\",\n    horizontalCenter: \"real\",\n    verticalCenter: \"real\",\n    rotation: \"real\",\n    scale: { type: \"real\", initialValue: 1 },\n    opacity: { type: \"real\", initialValue: 1 },\n    visible: { type: \"bool\", initialValue: true },\n    clip: \"bool\",\n    focus: \"bool\"\n  },\n  defaultProperty: \"data\"\n}, function () {\n  function _class49(meta) {\n    _classCallCheck(this, _class49);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (!this.dom) {\n      // Create a dom element for this item.\n      this.dom = document.createElement(meta.tagName || \"div\");\n    }\n    this.dom.style.position = \"absolute\";\n    this.dom.style.pointerEvents = \"none\";\n    // In case the class is qualified, only use the last part for the css class\n    // name.\n    var classComponent = meta.object.$class.split(\".\").pop();\n    this.dom.className = \"\" + classComponent + (this.id ? \" \" + this.id : \"\");\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = \"border-box\";\n\n    if (this.$isComponentRoot) {\n      QmlWeb.createProperty(\"var\", this, \"activeFocus\");\n    }\n\n    this.parentChanged.connect(this, this.$onParentChanged_);\n    this.dataChanged.connect(this, this.$onDataChanged);\n    this.stateChanged.connect(this, this.$onStateChanged);\n    this.visibleChanged.connect(this, this.$onVisibleChanged_);\n    this.clipChanged.connect(this, this.$onClipChanged);\n    this.zChanged.connect(this, this.$onZChanged);\n    this.xChanged.connect(this, this.$onXChanged);\n    this.yChanged.connect(this, this.$onYChanged);\n    this.widthChanged.connect(this, this.$onWidthChanged_);\n    this.heightChanged.connect(this, this.$onHeightChanged_);\n    this.focusChanged.connect(this, this.$onFocusChanged_);\n\n    this.widthChanged.connect(this, this.$updateHGeometry);\n    this.heightChanged.connect(this, this.$updateVGeometry);\n    this.implicitWidthChanged.connect(this, this.$onImplicitWidthChanged);\n    this.implicitHeightChanged.connect(this, this.$onImplicitHeightChanged);\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.anchors, {\n      left: \"var\",\n      right: \"var\",\n      top: \"var\",\n      bottom: \"var\",\n      horizontalCenter: \"var\",\n      verticalCenter: \"var\",\n      fill: \"Item\",\n      centerIn: \"Item\",\n      margins: \"real\",\n      leftMargin: \"real\",\n      rightMargin: \"real\",\n      topMargin: \"real\",\n      bottomMargin: \"real\"\n    });\n    this.anchors.leftChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomChanged.connect(this, this.$updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, this.$updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, this.$updateVGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateHGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateVGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateHGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateHGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.childrenRect, {\n      x: \"real\", // TODO ro\n      y: \"real\", // TODO ro\n      width: \"real\", // TODO ro\n      height: \"real\" // TODO ro\n    });\n\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n\n    this.Component.completed.connect(this, this.Component$onCompleted_);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = this.x + \"px\";\n    this.css.top = this.y + \"px\";\n  }\n\n  _createClass(_class49, [{\n    key: \"$onParentChanged_\",\n    value: function $onParentChanged_(newParent, oldParent, propName) {\n      if (oldParent) {\n        oldParent.children.splice(oldParent.children.indexOf(this), 1);\n        oldParent.childrenChanged();\n        oldParent.dom.removeChild(this.dom);\n      }\n      if (newParent && newParent.children.indexOf(this) === -1) {\n        newParent.children.push(this);\n        newParent.childrenChanged();\n      }\n      if (newParent) {\n        newParent.dom.appendChild(this.dom);\n      }\n      this.$updateHGeometry(newParent, oldParent, propName);\n      this.$updateVGeometry(newParent, oldParent, propName);\n    }\n  }, {\n    key: \"$onDataChanged\",\n    value: function $onDataChanged(newData) {\n      var QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n      for (var i in newData) {\n        var child = newData[i];\n        if (child instanceof QMLItem) {\n          child.parent = this; // This will also add it to children.\n        } else {\n          this.resources.push(child);\n        }\n      }\n    }\n  }, {\n    key: \"$onStateChanged\",\n    value: function $onStateChanged(newVal, oldVal) {\n      // let oldState; // TODO: do we need oldState?\n      var newState = void 0;\n      for (var i = 0; i < this.states.length; i++) {\n        if (this.states[i].name === newVal) {\n          newState = this.states[i];\n        }\n        /*\r\n        else if (this.states[i].name === oldVal) {\r\n          oldState = this.states[i];\r\n        }\r\n        */\n      }\n\n      var actions = this.$revertActions.slice();\n\n      // Get current values for revert actions\n      for (var _i6 in actions) {\n        var action = actions[_i6];\n        action.from = action.target[action.property];\n      }\n      if (newState) {\n        var changes = newState.$getAllChanges();\n\n        // Get all actions we need to do and create actions to revert them\n        for (var _i7 = 0; _i7 < changes.length; _i7++) {\n          this.$applyChange(actions, changes[_i7]);\n        }\n      }\n\n      // Set all property changes and fetch the actual values afterwards\n      // The latter is needed for transitions. We need to set all properties\n      // before we fetch the values because properties can be interdependent.\n      for (var _i8 in actions) {\n        var _action = actions[_i8];\n        _action.target.$properties[_action.property].set(_action.value, QmlWeb.QMLProperty.ReasonUser, _action.target, newState ? newState.$context : _action.target.$context);\n      }\n      for (var _i9 in actions) {\n        var _action2 = actions[_i9];\n        _action2.to = _action2.target[_action2.property];\n        if (_action2.explicit) {\n          // Remove binding\n          _action2.target[_action2.property] = _action2.target[_action2.property];\n          _action2.value = _action2.target[_action2.property];\n        }\n      }\n\n      // Find the best transition to use\n      var transition = void 0;\n      var rating = 0;\n      for (var _i10 = 0; _i10 < this.transitions.length; _i10++) {\n        // We need to stop running transitions, so let's do\n        // it while iterating through the transitions anyway\n        this.transitions[_i10].$stop();\n        var curTransition = this.transitions[_i10];\n        var curRating = 0;\n        if (curTransition.from === oldVal || curTransition.reversible && curTransition.from === newVal) {\n          curRating += 2;\n        } else if (curTransition.from === \"*\") {\n          curRating++;\n        } else {\n          continue;\n        }\n        if (curTransition.to === newVal || curTransition.reversible && curTransition.to === oldVal) {\n          curRating += 2;\n        } else if (curTransition.to === \"*\") {\n          curRating++;\n        } else {\n          continue;\n        }\n        if (curRating > rating) {\n          rating = curRating;\n          transition = curTransition;\n        }\n      }\n      if (transition) {\n        transition.$start(actions);\n      }\n    }\n  }, {\n    key: \"$applyChange\",\n    value: function $applyChange(actions, change) {\n      var _this39 = this;\n\n      var arrayFindIndex = QmlWeb.helpers.arrayFindIndex;\n\n      var _loop = function _loop(j) {\n        var item = change.$actions[j];\n\n        var action = {\n          target: change.target,\n          property: item.property,\n          origValue: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n          value: item.value,\n          from: change.target[item.property],\n          to: undefined,\n          explicit: change.explicit\n        };\n\n        var actionIndex = arrayFindIndex(actions, function (element) {\n          return element.target === action.target && element.property === action.property;\n        });\n        if (actionIndex !== -1) {\n          actions[actionIndex] = action;\n        } else {\n          actions.push(action);\n        }\n\n        // Look for existing revert action, else create it\n        var revertIndex = arrayFindIndex(_this39.$revertActions, function (element) {\n          return element.target === change.target && element.property === item.property;\n        });\n        if (revertIndex !== -1 && !change.restoreEntryValues) {\n          // We don't want to revert, so remove it\n          _this39.$revertActions.splice(revertIndex, 1);\n        } else if (revertIndex === -1 && change.restoreEntryValues) {\n          _this39.$revertActions.push({\n            target: change.target,\n            property: item.property,\n            value: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n            from: undefined,\n            to: change.target[item.property]\n          });\n        }\n      };\n\n      for (var j = 0; j < change.$actions.length; j++) {\n        _loop(j);\n      }\n    }\n  }, {\n    key: \"$onVisibleChanged_\",\n    value: function $onVisibleChanged_(newVal) {\n      this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n    }\n  }, {\n    key: \"$onClipChanged\",\n    value: function $onClipChanged(newVal) {\n      this.css.overflow = newVal ? \"hidden\" : \"visible\";\n    }\n  }, {\n    key: \"$onZChanged\",\n    value: function $onZChanged() {\n      this.$updateTransform();\n    }\n  }, {\n    key: \"$onXChanged\",\n    value: function $onXChanged(newVal) {\n      this.css.left = newVal + \"px\";\n      this.$updateHGeometry();\n    }\n  }, {\n    key: \"$onYChanged\",\n    value: function $onYChanged(newVal) {\n      this.css.top = newVal + \"px\";\n      this.$updateVGeometry();\n    }\n  }, {\n    key: \"$onWidthChanged_\",\n    value: function $onWidthChanged_(newVal) {\n      this.css.width = newVal ? newVal + \"px\" : \"auto\";\n    }\n  }, {\n    key: \"$onHeightChanged_\",\n    value: function $onHeightChanged_(newVal) {\n      this.css.height = newVal ? newVal + \"px\" : \"auto\";\n    }\n  }, {\n    key: \"$onFocusChanged_\",\n    value: function $onFocusChanged_(newVal) {\n      if (newVal) {\n        if (this.dom.firstChild) {\n          this.dom.firstChild.focus();\n        }\n        document.qmlFocus = this;\n        this.$context.activeFocus = this;\n      } else if (document.qmlFocus === this) {\n        document.getElementsByTagName(\"BODY\")[0].focus();\n        document.qmlFocus = QmlWeb.engine.rootContext().base;\n        this.$context.activeFocus = null;\n      }\n    }\n  }, {\n    key: \"setupFocusOnDom\",\n    value: function setupFocusOnDom(element) {\n      var _this40 = this;\n\n      var updateFocus = function updateFocus() {\n        var hasFocus = document.activeElement === _this40.dom || document.activeElement === _this40.dom.firstChild;\n        if (_this40.focus !== hasFocus) {\n          _this40.focus = hasFocus;\n        }\n      };\n      element.addEventListener(\"focus\", updateFocus);\n      element.addEventListener(\"blur\", updateFocus);\n    }\n  }, {\n    key: \"$updateTransform\",\n    value: function $updateTransform() {\n      var QMLTranslate = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Translate\");\n      var QMLRotation = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Rotation\");\n      var QMLScale = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Scale\");\n      var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\n      var filter = \"\";\n      var transformStyle = \"preserve-3d\";\n\n      for (var i = 0; i < this.transform.length; i++) {\n        var t = this.transform[i];\n        if (t instanceof QMLRotation) {\n          var ax = t.axis;\n          transform += \" rotate3d(\" + ax.x + \", \" + ax.y + \", \" + ax.z + \", \" + ax.angle + \"deg)\";\n        } else if (t instanceof QMLScale) {\n          transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\n        } else if (t instanceof QMLTranslate) {\n          transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\n        } else if (typeof t.transformType !== \"undefined\") {\n          if (t.transformType === \"filter\") {\n            filter += t.operation + \"(\" + t.parameters + \") \";\n          }\n        } else if (typeof t === \"string\") {\n          transform += t;\n        }\n      }\n      if (typeof this.z === \"number\") {\n        transform += \" translate3d(0, 0, \" + this.z + \"px)\";\n        // should also consider z as zIndex for stacking order behaviour of qml\n        // see http://doc.qt.io/qt-5/qml-qtquick-item.html#z-prop\n        this.dom.style.zIndex = this.z;\n      }\n      this.dom.style.transform = transform;\n      this.dom.style.transformStyle = transformStyle;\n      this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n      this.dom.style.webkitTransformStyle = transformStyle;\n      this.dom.style.msTransform = transform; // IE\n      this.dom.style.filter = filter;\n      this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n    }\n  }, {\n    key: \"Component$onCompleted_\",\n    value: function Component$onCompleted_() {\n      this.$calculateOpacity();\n    }\n  }, {\n    key: \"$calculateOpacity\",\n    value: function $calculateOpacity() {\n      // TODO: reset all opacity on layer.enabled changed\n      /*\r\n      if (false) { // TODO: check layer.enabled\r\n        this.css.opacity = this.opacity;\r\n      }\r\n      */\n      var parentOpacity = this.$parent && this.$parent.$opacity || 1;\n      this.$opacity = this.opacity * parentOpacity;\n      if (this.impl) {\n        this.impl.style.opacity = this.$opacity;\n      }\n    }\n  }, {\n    key: \"$onImplicitWidthChanged\",\n    value: function $onImplicitWidthChanged() {\n      if (this.$isUsingImplicitWidth) {\n        this.width = this.implicitWidth;\n        this.$isUsingImplicitWidth = true;\n      }\n    }\n  }, {\n    key: \"$onImplicitHeightChanged\",\n    value: function $onImplicitHeightChanged() {\n      if (this.$isUsingImplicitHeight) {\n        this.height = this.implicitHeight;\n        this.$isUsingImplicitHeight = true;\n      }\n    }\n  }, {\n    key: \"$updateHGeometry\",\n    value: function $updateHGeometry(newVal, oldVal, propName) {\n      var anchors = this.anchors || this;\n      if (this.$updatingHGeometry) {\n        return;\n      }\n      this.$updatingHGeometry = true;\n\n      var flags = QmlWeb.Signal.UniqueConnection;\n      var lM = anchors.leftMargin || anchors.margins;\n      var rM = anchors.rightMargin || anchors.margins;\n      var w = this.width;\n      var left = this.parent ? this.parent.left : 0;\n\n      // Width\n      if (propName === \"width\") {\n        this.$isUsingImplicitWidth = false;\n      }\n\n      // Position TODO: Layouts\n\n      var u = {}; // our update object\n\n      if (anchors.fill !== undefined) {\n        var fill = anchors.fill;\n        var props = fill.$properties;\n        props.left.changed.connect(this, this.$updateHGeometry, flags);\n        props.right.changed.connect(this, this.$updateHGeometry, flags);\n        props.width.changed.connect(this, this.$updateHGeometry, flags);\n\n        this.$isUsingImplicitWidth = false;\n        u.width = fill.width - lM - rM;\n        u.x = fill.left - left + lM;\n        u.left = fill.left + lM;\n        u.right = fill.right - rM;\n        u.horizontalCenter = (u.left + u.right) / 2;\n      } else if (anchors.centerIn !== undefined) {\n        var horizontalCenter = anchors.centerIn.$properties.horizontalCenter;\n        horizontalCenter.changed.connect(this, this.$updateHGeometry, flags);\n\n        u.horizontalCenter = anchors.centerIn.horizontalCenter;\n        u.x = u.horizontalCenter - w / 2 - left;\n        u.left = u.horizontalCenter - w / 2;\n        u.right = u.horizontalCenter + w / 2;\n      } else if (anchors.left !== undefined) {\n        u.left = anchors.left + lM;\n        if (anchors.right !== undefined) {\n          u.right = anchors.right - rM;\n          this.$isUsingImplicitWidth = false;\n          u.width = u.right - u.left;\n          u.x = u.left - left;\n          u.horizontalCenter = (u.right + u.left) / 2;\n        } else if (anchors.horizontalCenter !== undefined) {\n          u.horizontalCenter = anchors.horizontalCenter;\n          this.$isUsingImplicitWidth = false;\n          u.width = (u.horizontalCenter - u.left) * 2;\n          u.x = u.left - left;\n          u.right = 2 * u.horizontalCenter - u.left;\n        } else {\n          u.x = u.left - left;\n          u.right = u.left + w;\n          u.horizontalCenter = u.left + w / 2;\n        }\n      } else if (anchors.right !== undefined) {\n        u.right = anchors.right - rM;\n        if (anchors.horizontalCenter !== undefined) {\n          u.horizontalCenter = anchors.horizontalCenter;\n          this.$isUsingImplicitWidth = false;\n          u.width = (u.right - u.horizontalCenter) * 2;\n          u.x = 2 * u.horizontalCenter - u.right - left;\n          u.left = 2 * u.horizontalCenter - u.right;\n        } else {\n          u.x = u.right - w - left;\n          u.left = u.right - w;\n          u.horizontalCenter = u.right - w / 2;\n        }\n      } else if (anchors.horizontalCenter !== undefined) {\n        u.horizontalCenter = anchors.horizontalCenter;\n        u.x = u.horizontalCenter - w / 2 - left;\n        u.left = u.horizontalCenter - w / 2;\n        u.right = u.horizontalCenter + w / 2;\n      } else {\n        if (this.parent) {\n          var leftProp = this.parent.$properties.left;\n          leftProp.changed.connect(this, this.$updateHGeometry, flags);\n        }\n\n        u.left = this.x + left;\n        u.right = u.left + w;\n        u.horizontalCenter = u.left + w / 2;\n      }\n\n      for (var key in u) {\n        this[key] = u[key];\n      }\n\n      this.$updatingHGeometry = false;\n\n      if (this.parent) this.$updateChildrenRect(this.parent);\n    }\n  }, {\n    key: \"$updateVGeometry\",\n    value: function $updateVGeometry(newVal, oldVal, propName) {\n      var anchors = this.anchors || this;\n      if (this.$updatingVGeometry) {\n        return;\n      }\n      this.$updatingVGeometry = true;\n\n      var flags = QmlWeb.Signal.UniqueConnection;\n      var tM = anchors.topMargin || anchors.margins;\n      var bM = anchors.bottomMargin || anchors.margins;\n      var h = this.height;\n      var top = this.parent ? this.parent.top : 0;\n\n      // HeighttopProp\n      if (propName === \"height\") {\n        this.$isUsingImplicitHeight = false;\n      }\n\n      // Position TODO: Layouts\n\n      var u = {}; // our update object\n\n      if (anchors.fill !== undefined) {\n        var fill = anchors.fill;\n        var props = fill.$properties;\n        props.top.changed.connect(this, this.$updateVGeometry, flags);\n        props.bottom.changed.connect(this, this.$updateVGeometry, flags);\n        props.height.changed.connect(this, this.$updateVGeometry, flags);\n\n        this.$isUsingImplicitHeight = false;\n        u.height = fill.height - tM - bM;\n        u.y = fill.top - top + tM;\n        u.top = fill.top + tM;\n        u.bottom = fill.bottom - bM;\n        u.verticalCenter = (u.top + u.bottom) / 2;\n      } else if (anchors.centerIn !== undefined) {\n        var verticalCenter = anchors.centerIn.$properties.verticalCenter;\n        verticalCenter.changed.connect(this, this.$updateVGeometry, flags);\n\n        u.verticalCenter = anchors.centerIn.verticalCenter;\n        u.y = u.verticalCenter - h / 2 - top;\n        u.top = u.verticalCenter - h / 2;\n        u.bottom = u.verticalCenter + h / 2;\n      } else if (anchors.top !== undefined) {\n        u.top = anchors.top + tM;\n        if (anchors.bottom !== undefined) {\n          u.bottom = anchors.bottom - bM;\n          this.$isUsingImplicitHeight = false;\n          u.height = u.bottom - u.top;\n          u.y = u.top - top;\n          u.verticalCenter = (u.bottom + u.top) / 2;\n        } else if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n          this.$isUsingImplicitHeight = false;\n          u.height = (u.verticalCenter - u.top) * 2;\n          u.y = u.top - top;\n          u.bottom = 2 * u.verticalCenter - u.top;\n        } else {\n          u.y = u.top - top;\n          u.bottom = u.top + h;\n          u.verticalCenter = u.top + h / 2;\n        }\n      } else if (anchors.bottom !== undefined) {\n        u.bottom = anchors.bottom - bM;\n        if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n          this.$isUsingImplicitHeight = false;\n          u.height = (u.bottom - u.verticalCenter) * 2;\n          u.y = 2 * u.verticalCenter - u.bottom - top;\n          u.top = 2 * u.verticalCenter - u.bottom;\n        } else {\n          u.y = u.bottom - h - top;\n          u.top = u.bottom - h;\n          u.verticalCenter = u.bottom - h / 2;\n        }\n      } else if (anchors.verticalCenter !== undefined) {\n        u.verticalCenter = anchors.verticalCenter;\n        u.y = u.verticalCenter - h / 2 - top;\n        u.top = u.verticalCenter - h / 2;\n        u.bottom = u.verticalCenter + h / 2;\n      } else {\n        if (this.parent) {\n          var topProp = this.parent.$properties.top;\n          topProp.changed.connect(this, this.$updateVGeometry, flags);\n        }\n\n        u.top = this.y + top;\n        u.bottom = u.top + h;\n        u.verticalCenter = u.top + h / 2;\n      }\n\n      for (var key in u) {\n        this[key] = u[key];\n      }\n\n      this.$updatingVGeometry = false;\n\n      if (this.parent) this.$updateChildrenRect(this.parent);\n    }\n  }, {\n    key: \"$updateChildrenRect\",\n    value: function $updateChildrenRect(component) {\n      if (!component || !component.children || component.children.length === 0) {\n        return;\n      }\n      var children = component.children;\n\n      var maxWidth = 0;\n      var maxHeight = 0;\n      var minX = children.length > 0 ? children[0].x : 0;\n      var minY = children.length > 0 ? children[0].y : 0;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        maxWidth = Math.max(maxWidth, child.x + child.width);\n        maxHeight = Math.max(maxHeight, child.y + child.heighth);\n        minX = Math.min(minX, child.x);\n        minY = Math.min(minX, child.y);\n      }\n\n      component.childrenRect.x = minX;\n      component.childrenRect.y = minY;\n      component.childrenRect.width = maxWidth;\n      component.childrenRect.height = maxHeight;\n    }\n  }]);\n\n  return _class49;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListElement\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function _class50(meta) {\n    _classCallCheck(this, _class50);\n\n    QmlWeb.callSuper(this, meta);\n\n    for (var i in meta.object) {\n      if (i[0] !== \"$\") {\n        QmlWeb.createProperty(\"variant\", this, i);\n      }\n    }\n    QmlWeb.applyProperties(meta.object, this, this, this.$context);\n  }\n\n  return _class50;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListModel\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    count: \"int\",\n    $items: \"list\"\n  },\n  defaultProperty: \"$items\"\n}, function () {\n  function _class51(meta) {\n    var _this41 = this;\n\n    _classCallCheck(this, _class51);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$firstItem = true;\n    this.$itemsChanged.connect(this, this.$on$itemsChanged);\n    this.$model = new QmlWeb.JSItemModel();\n    this.$model.data = function (index, role) {\n      return _this41.$items[index][role];\n    };\n    this.$model.rowCount = function () {\n      return _this41.$items.length;\n    };\n  }\n\n  _createClass(_class51, [{\n    key: \"$on$itemsChanged\",\n    value: function $on$itemsChanged(newVal) {\n      this.count = this.$items.length;\n      if (this.$firstItem && newVal.length > 0) {\n        var QMLListElement = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListElement\");\n        this.$firstItem = false;\n        var roleNames = [];\n        var dict = newVal[0];\n        if (dict instanceof QMLListElement) {\n          dict = dict.$properties;\n        }\n        for (var i in dict) {\n          if (i !== \"index\") {\n            roleNames.push(i);\n          }\n        }\n        this.$model.setRoleNames(roleNames);\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(dict) {\n      var index = this.$items.length;\n      var c = 0;\n\n      if (dict instanceof Array) {\n        for (var key in dict) {\n          this.$items.push(dict[key]);\n          c++;\n        }\n      } else {\n        this.$items.push(dict);\n        c = 1;\n      }\n\n      this.$itemsChanged(this.$items);\n      this.$model.rowsInserted(index, index + c);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.$items.length = 0;\n      this.count = 0;\n      this.$model.modelReset();\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.$items[index];\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(index, dict) {\n      this.$items.splice(index, 0, dict);\n      this.$itemsChanged(this.$items);\n      this.$model.rowsInserted(index, index + 1);\n    }\n  }, {\n    key: \"move\",\n    value: function move(from, to, n) {\n      var vals = this.$items.splice(from, n);\n      for (var i = 0; i < vals.length; i++) {\n        this.$items.splice(to + i, 0, vals[i]);\n      }\n      this.$model.rowsMoved(from, from + n, to);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(index) {\n      this.$items.splice(index, 1);\n      this.$model.rowsRemoved(index, index + 1);\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, dict) {\n      this.$items[index] = dict;\n      this.$model.dataChanged(index, index);\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(index, property, value) {\n      this.$items[index][property] = value;\n      this.$model.dataChanged(index, index);\n    }\n  }]);\n\n  return _class51;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListView\",\n  versions: /.*/,\n  baseClass: \"Repeater\",\n  properties: {\n    orientation: \"enum\",\n    spacing: \"real\"\n  }\n}, function () {\n  function _class52(meta) {\n    _classCallCheck(this, _class52);\n\n    QmlWeb.callSuper(this, meta);\n    this.modelChanged.connect(this, this.$styleChanged);\n    this.delegateChanged.connect(this, this.$styleChanged);\n    this.orientationChanged.connect(this, this.$styleChanged);\n    this.spacingChanged.connect(this, this.$styleChanged);\n    this._childrenInserted.connect(this, this.$applyStyleOnItem);\n  }\n\n  _createClass(_class52, [{\n    key: \"container\",\n    value: function container() {\n      return this;\n    }\n  }, {\n    key: \"$applyStyleOnItem\",\n    value: function $applyStyleOnItem($item) {\n      var Qt = QmlWeb.Qt;\n      $item.dom.style.position = \"initial\";\n      if (this.orientation === Qt.Horizontal) {\n        $item.dom.style.display = \"inline-block\";\n        if ($item !== this.$items[0]) {\n          $item.dom.style[\"margin-left\"] = this.spacing + \"px\";\n        }\n      } else {\n        $item.dom.style.display = \"block\";\n        if ($item !== this.$items[0]) {\n          $item.dom.style[\"margin-top\"] = this.spacing + \"px\";\n        }\n      }\n    }\n  }, {\n    key: \"$styleChanged\",\n    value: function $styleChanged() {\n      for (var i = 0; i < this.$items.length; ++i) {\n        this.$applyStyleOnItem(this.$items[i]);\n      }\n    }\n  }]);\n\n  return _class52;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Loader\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    active: { type: \"bool\", initialValue: true },\n    asynchronous: \"bool\",\n    item: \"var\",\n    progress: \"real\",\n    source: \"url\",\n    sourceComponent: \"Component\",\n    status: { type: \"enum\", initialValue: 1 }\n  },\n  signals: {\n    loaded: []\n  }\n}, function () {\n  function _class53(meta) {\n    _classCallCheck(this, _class53);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$sourceUrl = \"\";\n\n    this.activeChanged.connect(this, this.$onActiveChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);\n    this.widthChanged.connect(this, this.$updateGeometry);\n    this.heightChanged.connect(this, this.$updateGeometry);\n  }\n\n  _createClass(_class53, [{\n    key: \"$onActiveChanged\",\n    value: function $onActiveChanged() {\n      if (!this.active) {\n        this.$unload();\n        return;\n      }\n      if (this.source) {\n        this.$onSourceChanged(this.source);\n      } else if (this.sourceComponent) {\n        this.$onSourceComponentChanged(this.sourceComponent);\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(fileName) {\n      // TODO\n      // if (fileName == this.$sourceUrl && this.item !== undefined) return;\n      if (!this.active) return;\n      this.$unload();\n\n      if (!fileName) {\n        this.sourceComponent = null;\n        this.$sourceUrl = fileName;\n        return;\n      }\n\n      var tree = QmlWeb.engine.loadComponent(fileName);\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var meta = { object: tree, context: this.$context, parent: this };\n      var qmlComponent = new QMLComponent(meta);\n      qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);\n      qmlComponent.$imports = tree.$imports;\n      qmlComponent.$file = tree.$file;\n      QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath, qmlComponent.importContextId);\n      var loadedComponent = this.$createComponentObject(qmlComponent, this);\n      this.sourceComponent = loadedComponent;\n      this.$sourceUrl = fileName;\n    }\n  }, {\n    key: \"$onSourceComponentChanged\",\n    value: function $onSourceComponentChanged(newItem) {\n      if (!this.active) return;\n      this.$unload();\n\n      if (!newItem) {\n        this.item = null;\n        return;\n      }\n\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var qmlComponent = newItem;\n      if (newItem instanceof QMLComponent) {\n        qmlComponent = newItem.$createObject(this, {}, this);\n      }\n      qmlComponent.parent = this;\n      this.item = qmlComponent;\n      this.$updateGeometry();\n      if (this.item) {\n        this.loaded();\n      }\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(url, options) {\n      this.$sourceUrl = url;\n      this.props = options;\n      this.source = url;\n    }\n  }, {\n    key: \"$unload\",\n    value: function $unload() {\n      if (!this.item) return;\n      this.item.$delete();\n      this.item.parent = undefined;\n      this.item = undefined;\n    }\n  }, {\n    key: \"$callOnCompleted\",\n    value: function $callOnCompleted(child) {\n      child.Component.completed();\n      var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n      for (var i = 0; i < child.$tidyupList.length; i++) {\n        if (child.$tidyupList[i] instanceof QMLBaseObject) {\n          this.$callOnCompleted(child.$tidyupList[i]);\n        }\n      }\n    }\n  }, {\n    key: \"$createComponentObject\",\n    value: function $createComponentObject(qmlComponent, parent) {\n      var newComponent = qmlComponent.createObject(parent);\n      if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n        // We don't call those on first creation, as they will be called\n        // by the regular creation-procedures at the right time.\n        QmlWeb.engine.$initializePropertyBindings();\n        this.$callOnCompleted(newComponent);\n      }\n      return newComponent;\n    }\n  }, {\n    key: \"$updateGeometry\",\n    value: function $updateGeometry() {\n      // Loader size doesn't exist\n      if (!this.width) {\n        this.width = this.item ? this.item.width : 0;\n      } else if (this.item) {\n        // Loader size exists\n        this.item.width = this.width;\n      }\n\n      if (!this.height) {\n        this.height = this.item ? this.item.height : 0;\n      } else if (this.item) {\n        // Loader size exists\n        this.item.height = this.height;\n      }\n    }\n  }]);\n\n  return _class53;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"MouseArea\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    acceptedButtons: { type: \"variant\", initialValue: 1 }, // Qt.LeftButton\n    enabled: { type: \"bool\", initialValue: true },\n    hoverEnabled: \"bool\",\n    mouseX: \"real\",\n    mouseY: \"real\",\n    pressed: \"bool\",\n    containsMouse: \"bool\",\n    pressedButtons: { type: \"variant\", initialValue: 0 },\n    cursorShape: \"enum\" // Qt.ArrowCursor\n  },\n  signals: {\n    clicked: [{ type: \"variant\", name: \"mouse\" }],\n    entered: [],\n    exited: [],\n    positionChanged: [{ type: \"variant\", name: \"mouse\" }],\n    wheel: [{ type: \"variant\", name: \"wheel\" }]\n  }\n}, function () {\n  function _class54(meta) {\n    var _this42 = this;\n\n    _classCallCheck(this, _class54);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"all\";\n\n    // IE does not handle mouse clicks to transparent divs, so we have\n    // to set a background color and make it invisible using opacity\n    // as that doesn't affect the mouse handling.\n    this.dom.style.backgroundColor = \"white\";\n    this.dom.style.opacity = 0;\n\n    this.cursorShapeChanged.connect(this, this.$onCursorShapeChanged);\n\n    this.dom.addEventListener(\"click\", function (e) {\n      return _this42.$handleClick(e);\n    });\n    this.dom.addEventListener(\"contextmenu\", function (e) {\n      return _this42.$handleClick(e);\n    });\n    var handleMouseMove = function handleMouseMove(e) {\n      if (!_this42.enabled || !_this42.hoverEnabled && !_this42.pressed) return;\n      _this42.$handlePositionChanged(e);\n    };\n    var handleMouseUp = function handleMouseUp() {\n      _this42.pressed = false;\n      _this42.pressedButtons = 0;\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n      _this42.$clientTransform = undefined;\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      if (!_this42.enabled) return;\n      // Handle scale and translate transformations\n      var boundingRect = _this42.dom.getBoundingClientRect();\n      _this42.$clientTransform = {\n        x: boundingRect.left,\n        y: boundingRect.top,\n        xScale: _this42.width ? (boundingRect.right - boundingRect.left) / _this42.width : 1,\n        yScale: _this42.height ? (boundingRect.bottom - boundingRect.top) / _this42.height : 1\n      };\n      var mouse = _this42.$eventToMouse(e);\n      _this42.mouseX = mouse.x;\n      _this42.mouseY = mouse.y;\n      _this42.pressed = true;\n      _this42.pressedButtons = mouse.button;\n      document.addEventListener(\"mouseup\", handleMouseUp);\n      document.addEventListener(\"mousemove\", handleMouseMove);\n    });\n    this.dom.addEventListener(\"mouseover\", function () {\n      _this42.containsMouse = true;\n      _this42.entered();\n    });\n    this.dom.addEventListener(\"mouseout\", function () {\n      _this42.containsMouse = false;\n      _this42.exited();\n    });\n    // This is to emit positionChanged for `hoverEnabled` only. When `pressed`,\n    // `positionChanged` is handled by a temporary `mousemove` event listener\n    // on `document`.\n    this.dom.addEventListener(\"mousemove\", function (e) {\n      if (!_this42.enabled || !_this42.hoverEnabled || _this42.pressed) return;\n      _this42.$handlePositionChanged(e);\n    });\n    this.dom.addEventListener(\"wheel\", function (e) {\n      _this42.$handleWheel(e);\n    });\n  }\n\n  _createClass(_class54, [{\n    key: \"$onCursorShapeChanged\",\n    value: function $onCursorShapeChanged() {\n      this.dom.style.cursor = this.$cursorShapeToCSS();\n    }\n  }, {\n    key: \"$handlePositionChanged\",\n    value: function $handlePositionChanged(e) {\n      var mouse = this.$eventToMouse(e);\n      this.mouseX = mouse.x;\n      this.mouseY = mouse.y;\n      this.positionChanged(mouse);\n    }\n  }, {\n    key: \"$handleWheel\",\n    value: function $handleWheel(e) {\n      var wheel = this.$eventToMouse(e);\n      wheel.angleDelta = { x: e.deltaX, y: e.deltaY };\n      wheel.accepted = false;\n\n      this.wheel(wheel);\n\n      if (wheel.accepted) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  }, {\n    key: \"$handleClick\",\n    value: function $handleClick(e) {\n      var mouse = this.$eventToMouse(e);\n      if (this.enabled && this.acceptedButtons & mouse.button) {\n        this.clicked(mouse);\n      }\n      // This decides whether to show the browser's context menu on right click or\n      // not\n      return !(this.acceptedButtons & QmlWeb.Qt.RightButton);\n    }\n  }, {\n    key: \"$eventToMouse\",\n    value: function $eventToMouse(e) {\n      var Qt = QmlWeb.Qt;\n      var mouse = {\n        accepted: true,\n        button: e.button === 0 ? Qt.LeftButton : e.button === 1 ? Qt.MiddleButton : e.button === 2 ? Qt.RightButton : 0,\n        modifiers: e.ctrlKey * Qt.CtrlModifier | e.altKey * Qt.AltModifier | e.shiftKey * Qt.ShiftModifier | e.metaKey * Qt.MetaModifier\n      };\n      if (this.$clientTransform) {\n        // Handle scale and translate transformations\n        mouse.x = (e.clientX - this.$clientTransform.x) / this.$clientTransform.xScale;\n        mouse.y = (e.clientY - this.$clientTransform.y) / this.$clientTransform.yScale;\n      } else {\n        mouse.x = e.offsetX || e.layerX;\n        mouse.y = e.offsetY || e.layerY;\n      }\n      return mouse;\n    }\n\n    // eslint-disable-next-line complexity\n\n  }, {\n    key: \"$cursorShapeToCSS\",\n    value: function $cursorShapeToCSS() {\n      var Qt = QmlWeb.Qt;\n      switch (this.cursorShape) {\n        case Qt.ArrowCursor:\n          return \"default\";\n        case Qt.UpArrowCursor:\n          return \"n-resize\";\n        case Qt.CrossCursor:\n          return \"crosshair\";\n        case Qt.WaitCursor:\n          return \"wait\";\n        case Qt.IBeamCursor:\n          return \"text\";\n        case Qt.SizeVerCursor:\n          return \"ew-resize\";\n        case Qt.SizeHorCursor:\n          return \"ns-resize\";\n        case Qt.SizeBDiagCursor:\n          return \"nesw-resize\";\n        case Qt.SizeFDiagCursor:\n          return \"nwse-resize\";\n        case Qt.SizeAllCursor:\n          return \"all-scroll\";\n        case Qt.BlankCursor:\n          return \"none\";\n        case Qt.SplitVCursor:\n          return \"row-resize\";\n        case Qt.SplitHCursor:\n          return \"col-resize\";\n        case Qt.PointingHandCursor:\n          return \"pointer\";\n        case Qt.ForbiddenCursor:\n          return \"not-allowed\";\n        case Qt.WhatsThisCursor:\n          return \"help\";\n        case Qt.BusyCursor:\n          return \"progress\";\n        case Qt.OpenHandCursor:\n          return \"grab\";\n        case Qt.ClosedHandCursor:\n          return \"grabbing\";\n        case Qt.DragCopyCursor:\n          return \"copy\";\n        case Qt.DragMoveCursor:\n          return \"move\";\n        case Qt.DragLinkCursor:\n          return \"alias\";\n        //case Qt.BitmapCursor: return \"auto\";\n        //case Qt.CustomCursor: return \"auto\";\n      }\n      return \"auto\";\n    }\n  }]);\n\n  return _class54;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"NumberAnimation\",\n  versions: /.*/,\n  baseClass: \"PropertyAnimation\"\n}, function () {\n  function _class55(meta) {\n    var _this43 = this;\n\n    _classCallCheck(this, _class55);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$at = 0;\n    this.$loop = 0;\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this43.$ticker.apply(_this43, arguments);\n    });\n    this.runningChanged.connect(this, this.$onRunningChanged);\n  }\n\n  _createClass(_class55, [{\n    key: \"$startLoop\",\n    value: function $startLoop() {\n      for (var i in this.$actions) {\n        var _action3 = this.$actions[i];\n        _action3.from = _action3.from !== undefined ? _action3.from : _action3.target[_action3.property];\n      }\n      this.$at = 0;\n    }\n  }, {\n    key: \"$ticker\",\n    value: function $ticker(now, elapsed) {\n      if (!this.running && this.$loop !== -1 || this.paused) {\n        // $loop === -1 is a marker to just finish this run\n        return;\n      }\n      if (this.$at === 0 && this.$loop === 0 && !this.$actions.length) {\n        this.$redoActions();\n      }\n      this.$at += elapsed / this.duration;\n      if (this.$at >= 1) {\n        this.complete();\n        return;\n      }\n      for (var i in this.$actions) {\n        var _action4 = this.$actions[i];\n        var value = _action4.from + (_action4.to - _action4.from) * this.easing.$valueForProgress(this.$at);\n        var property = _action4.target.$properties[_action4.property];\n        property.set(value, QmlWeb.QMLProperty.ReasonAnimation);\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged(newVal) {\n      if (newVal) {\n        this.$startLoop();\n        this.paused = false;\n      } else if (this.alwaysRunToEnd && this.$at < 1) {\n        this.$loop = -1; // -1 is used as a marker to stop\n      } else {\n        this.$loop = 0;\n        this.$actions = [];\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      for (var i in this.$actions) {\n        var _action5 = this.$actions[i];\n        var property = _action5.target.$properties[_action5.property];\n        property.set(_action5.to, QmlWeb.QMLProperty.ReasonAnimation);\n      }\n      this.$loop++;\n      if (this.$loop === this.loops) {\n        this.running = false;\n      } else if (!this.running) {\n        this.$actions = [];\n      } else {\n        this.$startLoop(this);\n      }\n    }\n  }]);\n\n  return _class55;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"OpacityAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class56(meta) {\n    _classCallCheck(this, _class56);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class56;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ParallelAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  enums: {\n    Animation: { Infinite: Math.Infinite }\n  },\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class57(meta) {\n    var _this44 = this;\n\n    _classCallCheck(this, _class57);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningAnimations = 0;\n\n    this.animationsChanged.connect(this, this.$onAnimationsChanged);\n\n    QmlWeb.engine.$registerStart(function () {\n      if (!_this44.running) return;\n      self.running = false; // toggled back by start();\n      self.start();\n    });\n    QmlWeb.engine.$registerStop(function () {\n      return _this44.stop();\n    });\n  }\n\n  _createClass(_class57, [{\n    key: \"$onAnimationsChanged\",\n    value: function $onAnimationsChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.runningChanged.connect(this, this.$animationFinished, flags);\n      }\n    }\n  }, {\n    key: \"$animationFinished\",\n    value: function $animationFinished(newVal) {\n      this.$runningAnimations += newVal ? 1 : -1;\n      if (this.$runningAnimations === 0) {\n        this.running = false;\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.running) return;\n      this.running = true;\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].start();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) return;\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].stop();\n      }\n      this.running = false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.stop();\n    }\n  }]);\n\n  return _class57;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PauseAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 }\n  }\n}, function () {\n  function _class58(meta) {\n    var _this45 = this;\n\n    _classCallCheck(this, _class58);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$at = 0;\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this45.$ticker.apply(_this45, arguments);\n    });\n    this.runningChanged.connect(this, this.$onRunningChanged);\n  }\n\n  _createClass(_class58, [{\n    key: \"$ticker\",\n    value: function $ticker(now, elapsed) {\n      if (!this.running || this.paused) {\n        return;\n      }\n      this.$at += elapsed / this.duration;\n      if (this.$at >= 1) {\n        this.complete();\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged(newVal) {\n      if (newVal) {\n        this.$at = 0;\n        this.paused = false;\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.running = false;\n    }\n  }]);\n\n  return _class58;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Positioner\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    spacing: \"int\",\n    padding: \"int\"\n  }\n}, function () {\n  function _class59(meta) {\n    _classCallCheck(this, _class59);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class59, [{\n    key: \"$onChildrenChanged\",\n    value: function $onChildrenChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.widthChanged.connect(this, this.layoutChildren, flags);\n        child.heightChanged.connect(this, this.layoutChildren, flags);\n        child.visibleChanged.connect(this, this.layoutChildren, flags);\n      }\n    }\n  }]);\n\n  return _class59;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 },\n    from: \"real\",\n    to: \"real\",\n    properties: \"string\",\n    property: \"string\",\n    target: \"QtObject\",\n    targets: \"list\"\n  }\n}, function () {\n  function _class60(meta) {\n    _classCallCheck(this, _class60);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.easing = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.easing, {\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\n      amplitude: { type: \"real\", initialValue: 1 },\n      overshoot: { type: \"real\", initialValue: 1.70158 },\n      period: { type: \"real\", initialValue: 0.3 },\n      bezierCurve: \"list\"\n    });\n\n    this.easing.$valueForProgress = function (t) {\n      return QmlWeb.$ease(this.type, this.period, this.amplitude, this.overshoot, t);\n    };\n\n    this.$props = [];\n    this.$targets = [];\n    this.$actions = [];\n\n    this.targetChanged.connect(this, this.$redoTargets);\n    this.targetsChanged.connect(this, this.$redoTargets);\n    this.propertyChanged.connect(this, this.$redoProperties);\n    this.propertiesChanged.connect(this, this.$redoProperties);\n\n    if (meta.object.$on !== undefined) {\n      this.property = meta.object.$on;\n      this.target = this.$parent;\n      this.running = true;\n    }\n  }\n\n  _createClass(_class60, [{\n    key: \"$redoActions\",\n    value: function $redoActions() {\n      this.$actions = [];\n      for (var i = 0; i < this.$targets.length; i++) {\n        for (var j in this.$props) {\n          this.$actions.push({\n            target: this.$targets[i],\n            property: this.$props[j],\n            from: this.from,\n            to: this.to\n          });\n        }\n      }\n    }\n  }, {\n    key: \"$redoProperties\",\n    value: function $redoProperties() {\n      this.$props = this.properties.split(\",\");\n\n      // Remove whitespaces\n      for (var i = 0; i < this.$props.length; i++) {\n        var matches = this.$props[i].match(/\\w+/);\n        if (matches) {\n          this.$props[i] = matches[0];\n        } else {\n          this.$props.splice(i, 1);\n          i--;\n        }\n      }\n      // Merge properties and property\n      if (this.property && this.$props.indexOf(this.property) === -1) {\n        this.$props.push(this.property);\n      }\n    }\n  }, {\n    key: \"$redoTargets\",\n    value: function $redoTargets() {\n      this.$targets = this.targets.slice();\n      if (this.target && this.$targets.indexOf(this.target) === -1) {\n        this.$targets.push(this.target);\n      }\n    }\n  }]);\n\n  return _class60;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyChanges\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: \"QtObject\",\n    explicit: \"bool\",\n    restoreEntryValues: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class61(meta) {\n    _classCallCheck(this, _class61);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$actions = [];\n  }\n\n  _createClass(_class61, [{\n    key: \"$setCustomData\",\n    value: function $setCustomData(property, value) {\n      this.$actions.push({ property: property, value: value });\n    }\n  }]);\n\n  return _class61;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rectangle\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    color: { type: \"color\", initialValue: \"white\" },\n    radius: \"real\"\n  }\n}, function () {\n  function _class62(meta) {\n    _classCallCheck(this, _class62);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.border = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.border, {\n      color: { type: \"color\", initialValue: \"black\" },\n      width: { type: \"int\", initialValue: 1 }\n    });\n    this.$borderActive = false;\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.position = \"absolute\";\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = \"0px\";\n    bg.style.borderWidth = \"0px\";\n    bg.style.borderStyle = \"solid\";\n    bg.style.borderColor = this.border.color.$css;\n    bg.style.backgroundColor = this.color.$css;\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.border.colorChanged.connect(this, this.border$onColorChanged);\n    this.border.widthChanged.connect(this, this.border$onWidthChanged);\n    this.widthChanged.connect(this, this.$updateBorder);\n    this.heightChanged.connect(this, this.$updateBorder);\n  }\n\n  _createClass(_class62, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.backgroundColor = newVal.$css;\n    }\n  }, {\n    key: \"border$onColorChanged\",\n    value: function border$onColorChanged(newVal) {\n      this.$borderActive = true;\n      this.impl.style.borderColor = newVal.$css;\n      this.$updateBorder();\n    }\n  }, {\n    key: \"border$onWidthChanged\",\n    value: function border$onWidthChanged() {\n      this.$borderActive = true;\n      this.$updateBorder();\n    }\n  }, {\n    key: \"$onRadiusChanged\",\n    value: function $onRadiusChanged(newVal) {\n      this.impl.style.borderRadius = newVal + \"px\";\n    }\n  }, {\n    key: \"$updateBorder\",\n    value: function $updateBorder() {\n      var border = this.$borderActive ? Math.max(0, this.border.width) : 0;\n      var style = this.impl.style;\n      if (border * 2 > this.width || border * 2 > this.height) {\n        // Border is covering the whole background\n        style.borderWidth = \"0px\";\n        style.borderTopWidth = this.height + \"px\";\n      } else {\n        style.borderWidth = border + \"px\";\n      }\n    }\n  }]);\n\n  return _class62;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"RegExpValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    regExp: \"var\"\n  }\n}, function () {\n  function _class63(meta) {\n    _classCallCheck(this, _class63);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class63, [{\n    key: \"validate\",\n    value: function validate(string) {\n      if (!this.regExp) return true;\n      return this.regExp.test(string);\n    }\n  }]);\n\n  return _class63;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Repeater\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    delegate: \"Component\",\n    model: { type: \"variant\", initialValue: 0 },\n    count: \"int\"\n  },\n  signals: {\n    _childrenInserted: []\n  },\n  defaultProperty: \"delegate\"\n}, function () {\n  function _class64(meta) {\n    _classCallCheck(this, _class64);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.parent = meta.parent;\n    // TODO: some (all ?) of the components including Repeater needs to know own\n    // parent at creation time. Please consider this major change.\n\n    this.$completed = false;\n    this.$items = []; // List of created items\n\n    this.modelChanged.connect(this, this.$onModelChanged);\n    this.delegateChanged.connect(this, this.$onDelegateChanged);\n    this.parentChanged.connect(this, this.$onParentChanged);\n  }\n\n  _createClass(_class64, [{\n    key: \"container\",\n    value: function container() {\n      return this.parent;\n    }\n  }, {\n    key: \"itemAt\",\n    value: function itemAt(index) {\n      return this.$items[index];\n    }\n  }, {\n    key: \"$onModelChanged\",\n    value: function $onModelChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$onDelegateChanged\",\n    value: function $onDelegateChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$onParentChanged\",\n    value: function $onParentChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$getModel\",\n    value: function $getModel() {\n      var QMLListModel = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListModel\");\n      return this.model instanceof QMLListModel ? this.model.$model : this.model;\n    }\n  }, {\n    key: \"$applyModel\",\n    value: function $applyModel() {\n      if (!this.delegate || !this.parent) {\n        return;\n      }\n      var model = this.$getModel();\n      if (model instanceof QmlWeb.JSItemModel) {\n        var flags = QmlWeb.Signal.UniqueConnection;\n        model.dataChanged.connect(this, this.$_onModelDataChanged, flags);\n        model.rowsInserted.connect(this, this.$_onRowsInserted, flags);\n        model.rowsMoved.connect(this, this.$_onRowsMoved, flags);\n        model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);\n        model.modelReset.connect(this, this.$_onModelReset, flags);\n\n        this.$removeChildren(0, this.$items.length);\n        this.$insertChildren(0, model.rowCount());\n      } else if (typeof model === \"number\") {\n        if (this.$items.length > model) {\n          // have more than we need\n          this.$removeChildren(model, this.$items.length);\n        } else {\n          // need more\n          this.$insertChildren(this.$items.length, model);\n        }\n      } else if (model instanceof Array) {\n        this.$removeChildren(0, this.$items.length);\n        this.$insertChildren(0, model.length);\n      }\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$callOnCompleted\",\n    value: function $callOnCompleted(child) {\n      child.Component.completed();\n      var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n      for (var i = 0; i < child.$tidyupList.length; i++) {\n        if (child.$tidyupList[i] instanceof QMLBaseObject) {\n          this.$callOnCompleted(child.$tidyupList[i]);\n        }\n      }\n    }\n  }, {\n    key: \"$_onModelDataChanged\",\n    value: function $_onModelDataChanged(startIndex, endIndex, roles) {\n      var model = this.$getModel();\n      var roleNames = roles || model.roleNames;\n      for (var index = startIndex; index <= endIndex; index++) {\n        var _item3 = this.$items[index];\n        var modelData = _item3.$properties.model;\n        for (var i in roleNames) {\n          var roleName = roleNames[i];\n          var roleData = model.data(index, roleName);\n          _item3.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);\n          modelData[roleName] = roleData;\n        }\n        _item3.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);\n      }\n    }\n  }, {\n    key: \"$_onRowsInserted\",\n    value: function $_onRowsInserted(startIndex, endIndex) {\n      this.$insertChildren(startIndex, endIndex);\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$_onRowsMoved\",\n    value: function $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\n      var vals = this.$items.splice(sourceStartIndex, sourceEndIndex - sourceStartIndex);\n      for (var i = 0; i < vals.length; i++) {\n        this.$items.splice(destinationIndex + i, 0, vals[i]);\n      }\n      var smallestChangedIndex = sourceStartIndex < destinationIndex ? sourceStartIndex : destinationIndex;\n      for (var _i11 = smallestChangedIndex; _i11 < this.$items.length; _i11++) {\n        this.$items[_i11].index = _i11;\n      }\n    }\n  }, {\n    key: \"$_onRowsRemoved\",\n    value: function $_onRowsRemoved(startIndex, endIndex) {\n      this.$removeChildren(startIndex, endIndex);\n      for (var i = startIndex; i < this.$items.length; i++) {\n        this.$items[i].index = i;\n      }\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$_onModelReset\",\n    value: function $_onModelReset() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$insertChildren\",\n    value: function $insertChildren(startIndex, endIndex) {\n      if (endIndex <= 0) {\n        this.count = 0;\n        return;\n      }\n\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      var createProperty = QmlWeb.createProperty;\n      var model = this.$getModel();\n      var index = void 0;\n      for (index = startIndex; index < endIndex; index++) {\n        var newItem = this.delegate.$createObject(this.parent);\n        createProperty(\"int\", newItem, \"index\", { initialValue: index });\n\n        if (typeof model === \"number\" || model instanceof Array) {\n          if (typeof newItem.$properties.modelData === \"undefined\") {\n            createProperty(\"variant\", newItem, \"modelData\");\n          }\n          var value = model instanceof Array ? model[index] : typeof model === \"number\" ? index : \"undefined\";\n          newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit, newItem, model.$context);\n        } else {\n          // QML exposes a \"model\" property in the scope that contains all role\n          // data.\n          var modelData = {};\n          for (var i = 0; i < model.roleNames.length; i++) {\n            var roleName = model.roleNames[i];\n            if (typeof newItem.$properties[roleName] === \"undefined\") {\n              createProperty(\"variant\", newItem, roleName);\n            }\n            var roleData = model.data(index, roleName);\n            modelData[roleName] = roleData;\n            newItem.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);\n          }\n          if (typeof newItem.$properties.model === \"undefined\") {\n            createProperty(\"variant\", newItem, \"model\");\n          }\n          newItem.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);\n        }\n\n        this.$items.splice(index, 0, newItem);\n\n        // parent must be set after the roles have been added to newItem scope in\n        // case we are outside of QMLOperationState.Init and parentChanged has\n        // any side effects that result in those roleNames being referenced.\n        newItem.parent = this.parent;\n\n        // TODO debug this. Without check to Init, Completed sometimes called\n        // twice.. But is this check correct?\n        if (QmlWeb.engine.operationState !== QMLOperationState.Init && QmlWeb.engine.operationState !== QMLOperationState.Idle) {\n          // We don't call those on first creation, as they will be called\n          // by the regular creation-procedures at the right time.\n          this.$callOnCompleted(newItem);\n        }\n      }\n      if (QmlWeb.engine.operationState !== QMLOperationState.Init) {\n        // We don't call those on first creation, as they will be called\n        // by the regular creation-procedures at the right time.\n        QmlWeb.engine.$initializePropertyBindings();\n      }\n\n      if (index > 0) {\n        this.container().childrenChanged();\n      }\n\n      for (var _i12 = endIndex; _i12 < this.$items.length; _i12++) {\n        this.$items[_i12].index = _i12;\n      }\n    }\n  }, {\n    key: \"$removeChildren\",\n    value: function $removeChildren(startIndex, endIndex) {\n      var removed = this.$items.splice(startIndex, endIndex - startIndex);\n      for (var index in removed) {\n        removed[index].$delete();\n        this.$removeChildProperties(removed[index]);\n      }\n    }\n  }, {\n    key: \"$removeChildProperties\",\n    value: function $removeChildProperties(child) {\n      var signals = QmlWeb.engine.completedSignals;\n      signals.splice(signals.indexOf(child.Component.completed), 1);\n      for (var i = 0; i < child.children.length; i++) {\n        this.$removeChildProperties(child.children[i]);\n      }\n    }\n  }]);\n\n  return _class64;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rotation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    angle: \"real\"\n  }\n}, function () {\n  function _class65(meta) {\n    _classCallCheck(this, _class65);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.axis = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.axis, {\n      x: \"real\",\n      y: \"real\",\n      z: { type: \"real\", initialValue: 1 }\n    });\n\n    this.origin = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.origin, {\n      x: \"real\",\n      y: \"real\"\n    });\n\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n    this.$parent.$updateTransform();\n  }\n\n  _createClass(_class65, [{\n    key: \"$updateOrigin\",\n    value: function $updateOrigin() {\n      var style = this.$parent.dom.style;\n      style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n      style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n    }\n  }]);\n\n  return _class65;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"RotationAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class66(meta) {\n    _classCallCheck(this, _class66);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class66;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Row\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  properties: {\n    layoutDirection: \"enum\"\n  }\n}, function () {\n  function _class67(meta) {\n    _classCallCheck(this, _class67);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class67, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      var curPos = this.padding;\n      var maxHeight = 0;\n      // When layoutDirection is RightToLeft we need oposite order\n      var i = this.layoutDirection === 1 ? this.children.length - 1 : 0;\n      var endPoint = this.layoutDirection === 1 ? -1 : this.children.length;\n      var step = this.layoutDirection === 1 ? -1 : 1;\n      for (; i !== endPoint; i += step) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height)) {\n          continue;\n        }\n        maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n        child.x = curPos;\n        if (this.padding > 0) child.y = this.padding;\n\n        curPos += child.width + this.spacing;\n      }\n      this.implicitHeight = maxHeight + this.padding * 2;\n      // We want no spacing at the right side\n      this.implicitWidth = curPos - this.spacing + this.padding;\n    }\n  }]);\n\n  return _class67;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Scale\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    xScale: { type: \"real\", initialValue: 1 },\n    yScale: { type: \"real\", initialValue: 1 }\n  }\n}, function () {\n  function _class68(meta) {\n    _classCallCheck(this, _class68);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.origin = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.origin, {\n      x: \"real\",\n      y: \"real\"\n    });\n\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n\n    /* QML default origin is top-left, while CSS default origin is centre, so\r\n     * $updateOrigin must be called to set the initial transformOrigin. */\n    this.$updateOrigin();\n  }\n\n  _createClass(_class68, [{\n    key: \"$updateOrigin\",\n    value: function $updateOrigin() {\n      var style = this.$parent.dom.style;\n      style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n      style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n    }\n  }]);\n\n  return _class68;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ScaleAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class69(meta) {\n    _classCallCheck(this, _class69);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class69;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SequentialAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class70(meta) {\n    var _this46 = this;\n\n    _classCallCheck(this, _class70);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.animationsChanged.connect(this, this.$onAnimatonsChanged);\n\n    QmlWeb.engine.$registerStart(function () {\n      if (!_this46.running) return;\n      _this46.running = false; // toggled back by start();\n      _this46.start();\n    });\n    QmlWeb.engine.$registerStop(function () {\n      return self.stop();\n    });\n  }\n\n  _createClass(_class70, [{\n    key: \"$onAnimatonsChanged\",\n    value: function $onAnimatonsChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.runningChanged.connect(this, this.$nextAnimation, flags);\n      }\n    }\n  }, {\n    key: \"$nextAnimation\",\n    value: function $nextAnimation(proceed) {\n      if (this.running && !proceed) {\n        this.$curIndex++;\n        if (this.$curIndex < this.animations.length) {\n          var anim = this.animations[this.$curIndex];\n          console.log(\"nextAnimation\", this, this.$curIndex, anim);\n          anim.start();\n        } else {\n          this.$passedLoops++;\n          if (this.$passedLoops >= this.loops) {\n            this.complete();\n          } else {\n            this.$curIndex = -1;\n            this.$nextAnimation();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.running) return;\n      this.running = true;\n      this.$curIndex = -1;\n      this.$passedLoops = 0;\n      this.$nextAnimation();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) return;\n      this.running = false;\n      if (this.$curIndex < this.animations.length) {\n        this.animations[this.$curIndex].stop();\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (!this.running) return;\n      if (this.$curIndex < this.animations.length) {\n        // Stop current animation\n        this.animations[this.$curIndex].stop();\n      }\n      this.running = false;\n    }\n  }]);\n\n  return _class70;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ShaderEffect\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    ShaderEffect: {\n      NoCulling: 0, BackFaceCulling: 1, FrontFaceCulling: 2,\n      Compiled: 0, Uncompiled: 1, Error: 2\n    }\n  },\n  properties: {\n    blending: { type: \"bool\", initialValue: true },\n    cullMode: \"enum\", // ShaderEffect.NoCulling\n    fragmentShader: \"string\",\n    log: \"string\",\n    mesh: \"var\",\n    status: { type: \"enum\", initialValue: 1 }, // ShaderEffect.Uncompiled\n    supportsAtlasTextures: \"bool\",\n    vertexShader: \"string\"\n  }\n}, function () {\n  function _class71(meta) {\n    _classCallCheck(this, _class71);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class71;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ShaderEffectSource\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    ShaderEffectSource: {\n      Alpha: 0x6406, RGB: 0x6407, RGBA: 0x6408,\n      NoMirroring: 0, MirrorHorizontally: 1, MirrorVertically: 2,\n      ClampToEdge: 0, RepeatHorizontally: 1, RepeatVertically: 2, Repeat: 3\n    }\n  },\n  properties: {\n    format: { type: \"enum\", initialValue: 0x6408 }, // ShaderEffectSource.RGBA\n    hideSource: \"bool\",\n    live: { type: \"bool\", initialValue: true },\n    mipmap: \"bool\",\n    recursive: \"bool\",\n    sourceItem: \"Item\",\n    sourceRect: \"rect\",\n    textureMirroring: { type: \"enum\", initialValue: 2 }, // MirrorVertically\n    textureSize: \"size\",\n    wrapMode: \"enum\" // ShaderEffectSource.ClampToEdge\n  }\n}, function () {\n  function _class72(meta) {\n    _classCallCheck(this, _class72);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class72, [{\n    key: \"scheduleUpdate\",\n    value: function scheduleUpdate() {\n      // TODO\n    }\n  }]);\n\n  return _class72;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"State\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    name: \"string\",\n    changes: \"list\",\n    extend: \"string\",\n    when: \"bool\"\n  },\n  defaultProperty: \"changes\"\n}, function () {\n  function _class73(meta) {\n    _classCallCheck(this, _class73);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n\n    this.whenChanged.connect(this, this.$onWhenChanged);\n  }\n\n  _createClass(_class73, [{\n    key: \"$getAllChanges\",\n    value: function $getAllChanges() {\n      var _this47 = this;\n\n      if (this.extend) {\n        /* ECMAScript 2015. TODO: polyfill Array?\r\n        const base = this.$item.states.find(state => state.name === this.extend);\r\n        */\n        var states = this.$item.states;\n        var base = states.filter(function (state) {\n          return state.name === _this47.extend;\n        })[0];\n        if (base) {\n          return base.$getAllChanges().concat(this.changes);\n        }\n        console.error(\"Can't find the state to extend!\");\n      }\n      return this.changes;\n    }\n  }, {\n    key: \"$onWhenChanged\",\n    value: function $onWhenChanged(newVal) {\n      if (newVal) {\n        this.$item.state = this.name;\n      } else if (this.$item.state === this.name) {\n        this.$item.state = \"\";\n      }\n    }\n  }]);\n\n  return _class73;\n}());\n\nvar platformsDetectors = [\n//{ name: \"W8\", regexp: /Windows NT 6\\.2/ },\n//{ name: \"W7\", regexp: /Windows NT 6\\.1/ },\n//{ name: \"Windows\", regexp: /Windows NT/ },\n{ name: \"OSX\", regexp: /Macintosh/ }];\n\nvar systemPalettes = {};\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SystemPalette\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    SystemPalette: {\n      Active: 0, Inactive: 2, Disabled: 1\n    }\n  },\n  properties: {\n    alternateBase: { type: \"color\", readOnly: true },\n    base: { type: \"color\", readOnly: true },\n    button: { type: \"color\", readOnly: true },\n    buttonText: { type: \"color\", readOnly: true },\n    dark: { type: \"color\", readOnly: true },\n    highlight: { type: \"color\", readOnly: true },\n    highlightedText: { type: \"color\", readOnly: true },\n    light: { type: \"color\", readOnly: true },\n    mid: { type: \"color\", readOnly: true },\n    midlight: { type: \"color\", readOnly: true },\n    shadow: { type: \"color\", readOnly: true },\n    text: { type: \"color\", readOnly: true },\n    window: { type: \"color\", readOnly: true },\n    windowText: { type: \"color\", readOnly: true },\n\n    colorGroup: \"enum\"\n  }\n}, function () {\n  function _class74(meta) {\n    _classCallCheck(this, _class74);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.colorGroupChanged.connect(this, this.$onColorGroupChanged);\n\n    this.$platform = \"OSX\";\n    // Detect OS\n    for (var i = 0; i < platformsDetectors.length; ++i) {\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n        this.$platform = platformsDetectors[i].name;\n        break;\n      }\n    }\n\n    this.$onColorGroupChanged(this.colorGroup);\n  }\n\n  _createClass(_class74, [{\n    key: \"$onColorGroupChanged\",\n    value: function $onColorGroupChanged(newVal) {\n      var _this48 = this;\n\n      var name = [\"active\", \"disabled\", \"inactive\"][newVal];\n      var pallete = systemPalettes[this.$platform][name];\n      this.$canEditReadOnlyProperties = true;\n      Object.keys(pallete).forEach(function (key) {\n        _this48[key] = pallete[key];\n      });\n      delete this.$canEditReadOnlyProperties;\n    }\n  }]);\n\n  return _class74;\n}());\n\nsystemPalettes.OSX = {\n  active: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#fbed73\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  inactive: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  disabled: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ededed\",\n    button: \"#ededed\",\n    buttonText: \"#949494\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#7f7f7f\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#7f7f7f\",\n    window: \"#ededed\",\n    windowText: \"#7f7f7f\"\n  }\n};\n\nQmlWeb.systemPalettes = systemPalettes;\nQmlWeb.platformsDetectors = platformsDetectors;\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Text\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Text: {\n      NoWrap: 0, WordWrap: 1, WrapAnywhere: 2, Wrap: 3,\n      WrapAtWordBoundaryOrAnywhere: 4,\n      AlignLeft: 1, AlignRight: 2, AlignHCenter: 4, AlignJustify: 8,\n      AlignTop: 32, AlignBottom: 64, AlignVCenter: 128,\n      AutoText: 2, PlainText: 0, StyledText: 4, RichText: 1,\n      Normal: 0, Outline: 1, Raised: 2, Sunken: 3\n    }\n  },\n  properties: {\n    color: { type: \"color\", initialValue: \"black\" },\n    text: \"string\",\n    textFormat: { type: \"enum\", initialValue: 2 }, // Text.AutoText\n    font: \"font\",\n    lineHeight: \"real\",\n    wrapMode: { type: \"enum\", initialValue: 0 }, // Text.NoWrap\n    horizontalAlignment: { type: \"enum\", initialValue: 1 }, // Text.AlignLeft\n    style: \"enum\",\n    styleColor: \"color\"\n  }\n}, function () {\n  function _class75(meta) {\n    _classCallCheck(this, _class75);\n\n    QmlWeb.callSuper(this, meta);\n\n    var fc = this.impl = document.createElement(\"span\");\n    fc.style.pointerEvents = \"none\";\n    fc.style.width = \"100%\";\n    fc.style.height = \"100%\";\n    fc.style.whiteSpace = \"pre\";\n    this.dom.style.textAlign = \"left\";\n    this.dom.appendChild(fc);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.textFormatChanged.connect(this, this.$onTextFormatChanged);\n    this.lineHeightChanged.connect(this, this.$onLineHeightChanged);\n    this.wrapModeChanged.connect(this, this.$onWrapModeChanged);\n    this.horizontalAlignmentChanged.connect(this, this.$onHorizontalAlignmentChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.styleColorChanged.connect(this, this.$onStyleColorChanged);\n\n    this.widthChanged.connect(this, this.$onWidthChanged);\n    this.fontChanged.connect(this, this.$onFontChanged);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class75, [{\n    key: \"$redrawText\",\n    value: function $redrawText() {\n      var text = this.text;\n      var format = this.textFormat;\n      if (format === this.Text.AutoText) {\n        // NOTE: this is not the exact same heuristics that Qt uses\n        if (/<[a-zA-Z]+(\\s[^>]*)?\\/?>/.test(text)) {\n          format = this.Text.StyledText;\n        } else {\n          format = this.Text.PlainText;\n        }\n      }\n      if (format === this.Text.PlainText) {\n        this.impl.innerHTML = \"\";\n        this.impl.appendChild(document.createTextNode(text));\n      } else {\n        // TODO: sanitize StyledText/RichText\n        this.impl.innerHTML = text;\n      }\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.color = newVal.$css;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged() {\n      this.$redrawText();\n    }\n  }, {\n    key: \"$onTextFormatChanged\",\n    value: function $onTextFormatChanged() {\n      this.$redrawText();\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onLineHeightChanged\",\n    value: function $onLineHeightChanged(newVal) {\n      this.impl.style.lineHeight = newVal + \"px\";\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onStyleChanged\",\n    value: function $onStyleChanged(newVal) {\n      this.$updateShadow(newVal, this.styleColor.$css);\n    }\n  }, {\n    key: \"$onStyleColorChanged\",\n    value: function $onStyleColorChanged(newVal) {\n      this.$updateShadow(this.style, newVal.$css);\n    }\n  }, {\n    key: \"$onWrapModeChanged\",\n    value: function $onWrapModeChanged(newVal) {\n      var style = this.impl.style;\n      switch (newVal) {\n        case this.Text.NoWrap:\n          style.whiteSpace = \"pre\";\n          break;\n        case this.Text.WordWrap:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordWrap = \"normal\";\n          break;\n        case this.Text.WrapAnywhere:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordBreak = \"break-all\";\n          break;\n        case this.Text.Wrap:\n        case this.Text.WrapAtWordBoundaryOrAnywhere:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordWrap = \"break-word\";\n      }\n      this.$updateJustifyWhiteSpace();\n    }\n  }, {\n    key: \"$onHorizontalAlignmentChanged\",\n    value: function $onHorizontalAlignmentChanged(newVal) {\n      var textAlign = null;\n      switch (newVal) {\n        case this.Text.AlignLeft:\n          textAlign = \"left\";\n          break;\n        case this.Text.AlignRight:\n          textAlign = \"right\";\n          break;\n        case this.Text.AlignHCenter:\n          textAlign = \"center\";\n          break;\n        case this.Text.AlignJustify:\n          textAlign = \"justify\";\n          break;\n      }\n      this.dom.style.textAlign = textAlign;\n      this.$updateJustifyWhiteSpace();\n    }\n  }, {\n    key: \"$onFontChanged\",\n    value: function $onFontChanged() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$updateImplicit\",\n    value: function $updateImplicit() {\n      if (!this.text || !this.dom) {\n        this.implicitHeight = this.implicitWidth = 0;\n        return;\n      }\n\n      if (!this.$isUsingImplicitWidth) {\n        this.implicitWidth = this.impl.offsetWidth;\n        this.implicitHeight = this.impl.offsetHeight;\n        return;\n      }\n\n      var fc = this.impl;\n      var engine = QmlWeb.engine;\n      // Need to move the child out of it's parent so that it can properly\n      // recalculate it's \"natural\" offsetWidth/offsetHeight\n      if (engine.dom === document.body && engine.dom !== engine.domTarget) {\n        // Can't use document.body here, as it could have Shadow DOM inside\n        // The root is document.body, though, so it's probably not hidden\n        engine.domTarget.appendChild(fc);\n      } else {\n        document.body.appendChild(fc);\n      }\n      var height = fc.offsetHeight;\n      var width = fc.offsetWidth;\n      this.dom.appendChild(fc);\n\n      this.implicitHeight = height;\n      this.implicitWidth = width;\n    }\n  }, {\n    key: \"$updateShadow\",\n    value: function $updateShadow(textStyle, styleColor) {\n      var style = this.impl.style;\n      switch (textStyle) {\n        case 0:\n          style.textShadow = \"none\";\n          break;\n        case 1:\n          style.textShadow = [\"1px 0 0 \" + styleColor, \"-1px 0 0 \" + styleColor, \"0 1px 0 \" + styleColor, \"0 -1px 0 \" + styleColor].join(\",\");\n          break;\n        case 2:\n          style.textShadow = \"1px 1px 0 \" + styleColor;\n          break;\n        case 3:\n          style.textShadow = \"-1px -1px 0 \" + styleColor;\n          break;\n      }\n    }\n  }, {\n    key: \"$updateJustifyWhiteSpace\",\n    value: function $updateJustifyWhiteSpace() {\n      var style = this.impl.style;\n      // AlignJustify doesn't work with pre/pre-wrap, so we decide the lesser of\n      // the two evils to be ignoring \"\\n\"s inside the text.\n      if (this.horizontalAlignment === this.Text.AlignJustify) {\n        style.whiteSpace = \"normal\";\n      }\n      this.$updateImplicit();\n    }\n  }]);\n\n  return _class75;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextEdit\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    activeFocusOnPress: { type: \"bool\", initialValue: true },\n    baseUrl: \"url\",\n    canPaste: \"bool\",\n    canRedo: \"bool\",\n    canUndo: \"bool\",\n    color: { type: \"color\", initialValue: \"white\" },\n    contentHeight: \"real\",\n    contentWidth: \"real\",\n    cursorDelegate: \"Component\",\n    cursorPosition: \"int\",\n    cursorRectangle: \"rect\",\n    cursorVisible: { type: \"bool\", initialValue: true },\n    effectiveHorizontalAlignment: \"enum\",\n    font: \"font\",\n    horizontalAlignment: \"enum\",\n    hoveredLink: \"string\",\n    inputMethodComposing: \"bool\",\n    inputMethodHints: \"enum\",\n    length: \"int\",\n    lineCount: \"int\",\n    mouseSelectionMode: \"enum\",\n    persistentSelection: \"bool\",\n    readOnly: \"bool\",\n    renderType: \"enum\",\n    selectByKeyboard: { type: \"bool\", initialValue: true },\n    selectByMouse: \"bool\",\n    selectedText: \"string\",\n    selectedTextColor: { type: \"color\", initialValue: \"yellow\" },\n    selectionColor: { type: \"color\", initialValue: \"pink\" },\n    selectionEnd: \"int\",\n    selectionStart: \"int\",\n    text: \"string\",\n    textDocument: \"TextDocument\",\n    textFormat: \"enum\",\n    textMargin: \"real\",\n    verticalAlignment: \"enum\",\n    wrapMode: \"enum\"\n  },\n  signals: {\n    linkActivated: [{ type: \"string\", name: \"link\" }],\n    linkHovered: [{ type: \"string\", name: \"link\" }]\n  }\n}, function () {\n  function _class76(meta) {\n    var _this49 = this;\n\n    _classCallCheck(this, _class76);\n\n    QmlWeb.callSuper(this, meta);\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    var textarea = this.impl = document.createElement(\"textarea\");\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = \"border-box\";\n    textarea.style.borderWidth = \"0\";\n    textarea.style.background = \"none\";\n    textarea.style.outline = \"none\";\n    textarea.style.resize = \"none\";\n    textarea.style.padding = \"0\"; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this49.$updateValue();\n    });\n  }\n\n  _createClass(_class76, [{\n    key: \"append\",\n    value: function append(text) {\n      this.text += text;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      // TODO\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      this.text = this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);\n      // TODO\n    }\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      //this.selectionStart = -1;\n      //this.selectionEnd = -1;\n      //this.selectedText = null;\n      // TODO\n    }\n  }, {\n    key: \"getFormattedText\",\n    value: function getFormattedText(start, end) {\n      var text = this.text.slice(start, end);\n      // TODO\n      // process text\n      return text;\n    }\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return this.text.slice(start, end);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert() /*position, text*/{\n      // TODO\n    }\n  }, {\n    key: \"isRightToLeft\",\n    value: function isRightToLeft() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"linkAt\",\n    value: function linkAt() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"moveCursorSelection\",\n    value: function moveCursorSelection() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"paste\",\n    value: function paste() {\n      // TODO\n    }\n  }, {\n    key: \"positionAt\",\n    value: function positionAt() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"positionToRectangle\",\n    value: function positionToRectangle() /*position*/{\n      // TODO\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      // TODO\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"select\",\n    value: function select() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      // TODO\n    }\n  }, {\n    key: \"selectWord\",\n    value: function selectWord() {\n      // TODO\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      // TODO\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.selectByKeyboard = !this.readOnly;\n      this.impl.readOnly = this.readOnly;\n      this.$updateValue();\n      this.implicitWidth = this.offsetWidth;\n      this.implicitHeight = this.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.value = newVal;\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.color = newVal.$css;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.text = this.impl.value;\n      }\n      this.length = this.text.length;\n      this.lineCount = this.$getLineCount();\n      this.$updateCss();\n    }\n    // Transfer dom style to firstChild,\n    // then clear corresponding dom style\n\n  }, {\n    key: \"$updateCss\",\n    value: function $updateCss() {\n      var supported = [\"border\", \"borderRadius\", \"borderWidth\", \"borderColor\", \"backgroundColor\"];\n      var style = this.impl.style;\n      for (var n = 0; n < supported.length; n++) {\n        var o = supported[n];\n        var v = this.css[o];\n        if (v) {\n          style[o] = v;\n          this.css[o] = null;\n        }\n      }\n    }\n  }, {\n    key: \"$getLineCount\",\n    value: function $getLineCount() {\n      return this.text.split(/\\n/).length;\n    }\n  }]);\n\n  return _class76;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextInput\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, function () {\n  function _class77(meta) {\n    var _this50 = this;\n\n    _classCallCheck(this, _class77);\n\n    QmlWeb.callSuper(this, meta);\n\n    var input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    // In some browsers text-inputs have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    input.style.margin = \"0\";\n    input.style.padding = \"0\";\n    input.style.width = \"100%\";\n    input.style.height = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this50.$updateValue();\n    });\n  }\n\n  _createClass(_class77, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      // We have to check if value actually changes.\n      // If we do not have this check, then after user updates text input\n      // following occurs: user updates gui text -> updateValue gets called ->\n      // textChanged gets called -> gui value updates again -> caret position\n      // moves to the right!\n      if (this.impl.value !== newVal) {\n        this.impl.value = newVal;\n      }\n    }\n  }, {\n    key: \"$onEchoModeChanged\",\n    value: function $onEchoModeChanged(newVal) {\n      var TextInput = this.TextInput;\n      var input = this.impl;\n      switch (newVal) {\n        case TextInput.Normal:\n          input.type = \"text\";\n          break;\n        case TextInput.Password:\n          input.type = \"password\";\n          break;\n        case TextInput.NoEcho:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n        case TextInput.PasswordEchoOnEdit:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onMaximumLengthChanged\",\n    value: function $onMaximumLengthChanged(newVal) {\n      this.impl.maxLength = newVal < 0 ? null : newVal;\n    }\n  }, {\n    key: \"$onReadOnlyChanged\",\n    value: function $onReadOnlyChanged(newVal) {\n      this.impl.disabled = newVal;\n    }\n  }, {\n    key: \"Keys$onPressed\",\n    value: function Keys$onPressed(e) {\n      var Qt = QmlWeb.Qt;\n      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n      if (submit && this.$testValidator()) {\n        this.accepted();\n        e.accepted = true;\n      }\n    }\n  }, {\n    key: \"$testValidator\",\n    value: function $testValidator() {\n      if (this.validator) {\n        return this.validator.validate(this.text);\n      }\n      return true;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.$canEditReadOnlyProperties = true;\n        this.text = this.impl.value;\n        this.$canEditReadOnlyProperties = false;\n      }\n    }\n  }]);\n\n  return _class77;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Transition\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animations: \"list\",\n    from: { type: \"string\", initialValue: \"*\" },\n    to: { type: \"string\", initialValue: \"*\" },\n    reversible: \"bool\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class78(meta) {\n    _classCallCheck(this, _class78);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n  }\n\n  _createClass(_class78, [{\n    key: \"$start\",\n    value: function $start(actions) {\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.$actions = [];\n        var $targets = animation.$targets,\n            $props = animation.$props,\n            $actions = animation.$actions;\n\n        for (var j in actions) {\n          var _action6 = actions[j];\n          if (($targets.length === 0 || $targets.indexOf(_action6.target) !== -1) && ($props.length === 0 || $props.indexOf(_action6.property) !== -1)) {\n            $actions.push(_action6);\n          }\n        }\n        animation.start();\n      }\n    }\n  }, {\n    key: \"$stop\",\n    value: function $stop() {\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].stop();\n      }\n    }\n  }]);\n\n  return _class78;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Translate\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    x: \"real\",\n    y: \"real\"\n  }\n}, function () {\n  function _class79(meta) {\n    _classCallCheck(this, _class79);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n  }\n\n  return _class79;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"UniformAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\",\n  properties: {\n    uniform: \"string\"\n  }\n}, function () {\n  function _class80(meta) {\n    _classCallCheck(this, _class80);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class80;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"XAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class81(meta) {\n    _classCallCheck(this, _class81);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class81;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"YAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class82(meta) {\n    _classCallCheck(this, _class82);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class82;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtTest\",\n  name: \"TestCase\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    completed: \"bool\",\n    name: \"string\",\n    optional: \"bool\",\n    running: \"bool\",\n    when: \"bool\",\n    windowShown: \"bool\"\n  }\n}, function () {\n  function _class83(meta) {\n    var _this51 = this;\n\n    _classCallCheck(this, _class83);\n\n    QmlWeb.callSuper(this, meta);\n    this.Component.completed.connect(this, this.Component$onCompleted);\n\n    var engine = QmlWeb.engine;\n    if (!engine.tests) {\n      QmlWeb.engine.tests = {\n        name: engine.name || \"Run_\" + Math.random().toString(36).slice(2, 10),\n        started: false,\n        finished: false,\n        duration: 0,\n        total: 0,\n        completed: 0,\n        errors: [],\n        stats: {\n          pass: 0,\n          fail: 0,\n          skip: 0\n        }\n      };\n    }\n    QmlWeb.engine.tests.total++;\n\n    this.console = {\n      assert: function assert() {\n        var _console;\n\n        return (_console = console).assert.apply(_console, arguments);\n      },\n      error: function error() {\n        var _console2;\n\n        for (var _len26 = arguments.length, a = Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n          a[_key26] = arguments[_key26];\n        }\n\n        return (_console2 = console).error.apply(_console2, [\"QSYSTEM: \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      info: function info() {\n        var _console3;\n\n        for (var _len27 = arguments.length, a = Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n          a[_key27] = arguments[_key27];\n        }\n\n        return (_console3 = console).info.apply(_console3, [\"QINFO  : \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      log: function log() {\n        var _console4;\n\n        for (var _len28 = arguments.length, a = Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n          a[_key28] = arguments[_key28];\n        }\n\n        return (_console4 = console).log.apply(_console4, [\"QDEBUG : \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      time: function time() {\n        var _console5;\n\n        return (_console5 = console).time.apply(_console5, arguments);\n      },\n      timeEnd: function timeEnd() {\n        var _console6;\n\n        return (_console6 = console).timeEnd.apply(_console6, arguments);\n      },\n      trace: function trace() {\n        var _console7;\n\n        return (_console7 = console).trace.apply(_console7, arguments);\n      },\n      warn: function warn() {\n        var _console8;\n\n        for (var _len29 = arguments.length, a = Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n          a[_key29] = arguments[_key29];\n        }\n\n        return (_console8 = console).warn.apply(_console8, [\"QWARN  : \" + _this51.$testId + \" qml:\"].concat(a));\n      }\n    };\n  }\n\n  _createClass(_class83, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      var _this52 = this;\n\n      var info = QmlWeb.engine.tests;\n      if (!info.started) {\n        console.log(\"********* Start testing of \" + info.name + \" *********\");\n        console.log(\"Config: Using QmlWeb, \" + window.navigator.userAgent);\n        info.started = true;\n      }\n\n      var keys = Object.keys(this);\n      var tests = keys.filter(function (key) {\n        return key.lastIndexOf(\"test_\", 0) === 0;\n      }).filter(function (key) {\n        return key.indexOf(\"_data\", key.length - 5) === -1;\n      }).sort();\n\n      tests.unshift(\"initTestCase\");\n      tests.push(\"cleanupTestCase\");\n      tests.forEach(function (test) {\n        _this52.$testId = info.name + \"::\" + _this52.name + \"::\" + test + \"()\";\n        var special = test === \"initTestCase\" || test === \"cleanupTestCase\";\n\n        var dstart = performance.now();\n        var data = void 0;\n        if (_this52[test + \"_data\"] && !special) {\n          data = _this52[test + \"_data\"]();\n          if (!data || !data.length) {\n            _this52.warn(\"no data supplied for \" + test + \"() by \" + test + \"_data()\");\n            data = [];\n          }\n        } else if (_this52.init_data && !special) {\n          data = _this52.init_data();\n          if (!data || !data.length) {\n            data = undefined;\n          }\n        }\n        if (!data) {\n          data = [null];\n        }\n        var dend = performance.now();\n        info.duration += dend - dstart;\n\n        data.forEach(function (row) {\n          var arg = row ? row.tag : \"\";\n          _this52.$testId = info.name + \"::\" + _this52.name + \"::\" + test + \"(\" + arg + \")\";\n          var start = performance.now();\n          var error = void 0;\n          try {\n            if (!special) {\n              _this52.init();\n            }\n            _this52[test](row);\n          } catch (e) {\n            error = e;\n          } finally {\n            if (!special) {\n              _this52.cleanup();\n            }\n          }\n          var end = performance.now();\n          info.duration += end - start;\n          if (error && error.skip) {\n            info.stats.skip++;\n            console.log(\"SKIP   : \" + _this52.$testId + \" \" + error.message);\n          } else if (error) {\n            info.stats.fail++;\n            info.errors.push(_this52.$testId + \" \" + error.message);\n            console.log(\"FAIL!  : \" + _this52.$testId + \" \" + error.message);\n            if (\"actual\" in error) {\n              console.log(\"   Actual   (): \" + error.actual);\n            }\n            if (\"expected\" in error) {\n              console.log(\"   Expected (): \" + error.expected);\n            }\n          } else {\n            info.stats.pass++;\n            console.log(\"PASS   : \" + _this52.$testId);\n          }\n        });\n\n        _this52.$testId = info.name + \"::UnknownTestFunc()\";\n      });\n\n      // TODO: benchmarks\n\n      info.completed++;\n      if (info.completed === info.total) {\n        info.finished = true;\n        var _info$stats = info.stats,\n            pass = _info$stats.pass,\n            fail = _info$stats.fail,\n            skip = _info$stats.skip;\n\n        var duration = Math.round(info.duration * 100) / 100;\n        console.log(\"Totals: \" + pass + \" passed, \" + fail + \" failed, \" + skip + \" skipped, \" + duration + \"ms\");\n        console.log(\"********* Finished testing of \" + info.name + \" *********\");\n      }\n    }\n\n    // No-ops\n\n  }, {\n    key: \"init\",\n    value: function init() {}\n  }, {\n    key: \"initTestCase\",\n    value: function initTestCase() {}\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {}\n  }, {\n    key: \"cleanupTestCase\",\n    value: function cleanupTestCase() {}\n\n    // API\n\n  }, {\n    key: \"compare\",\n    value: function compare(actual, expected) {\n      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n\n      if (actual !== expected) {\n        var err = new Error(message);\n        err.actual = actual;\n        err.expected = expected;\n        throw err;\n      }\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(condition) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n      if (!condition) {\n        throw new Error(\"'\" + message + \"' returned FALSE. ()\");\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      throw new Error(message);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(message) {\n      console.warn(\"WARNING: \" + this.$testId + \" \" + message);\n    }\n  }, {\n    key: \"skip\",\n    value: function skip() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      var err = new Error(message);\n      err.skip = true;\n      throw err;\n    }\n    /*\r\n    expectFail(tag, message) {\r\n      // TODO\r\n    }\r\n    expectFailContinue(tag, message) {\r\n      // TODO\r\n    }\r\n    findChild(parent, objectName) {\r\n      // TODO\r\n      // return QtObject\r\n    }\r\n    fuzzyCompare(actual, expected, delta, message) {\r\n      // TODO\r\n    }\r\n    grabImage(item) {\r\n      if (!window.top || !window.top.callPhantom) {\r\n        this.skip(\"Can't use TestCase::grabImage() without PhantomJS.\");\r\n      }\r\n      // TODO\r\n      return {\r\n        red: (x, y) => {},\r\n        green: (x, y) => {},\r\n        blue: (x, y) => {},\r\n        alpha: (x, y) => {},\r\n        pixel: (x, y) => {},\r\n        equals: image => false\r\n      };\r\n    }\r\n    ignoreWarning(message) {\r\n      // TODO\r\n    }\r\n    sleep(ms) {\r\n      // TODO\r\n    }\r\n    tryCompare(obj, property, expected, timeout, message) {\r\n      // TODO\r\n    }\r\n    wait(ms) {\r\n      // TODO\r\n    }\r\n    waitForRendering(item, timeout = 5000) {\r\n      // TODO\r\n    }\r\n    */\n\n    // TODO\n    /*\r\n    // Events\r\n    keyClick(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    keyPress(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    keyRelease(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseClick(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDoubleClick(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDoubleClickSequence(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDrag(item, x, y, dx, dy, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseMove(item, x, y, delay = -1) {\r\n      // TODO\r\n    }\r\n    mousePress(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseRelease(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseWheel(item, x, y, xDelta, yDelta, button, modifiers, delay = -1) {\r\n      // button = Qt.LeftButton, modifiers = Qt.NoModifier\r\n      // TODO\r\n    }\r\n    */\n\n  }]);\n\n  return _class83;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtWebEngine\",\n  name: \"WebEngineView\",\n  versions: /^5\\./,\n  baseClass: \"QtWebView.WebView\", // It's easier this way\n  properties: {\n    // TODO\n  },\n  signals: {\n    // TODO\n  }\n}, function () {\n  function _class84(meta) {\n    _classCallCheck(this, _class84);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implement more features on top of WebView\n  }\n\n  return _class84;\n}());\n\n// WARNING: Can have wrong behavior if url is changed while the socket is in\n// Connecting state.\n// TODO: Recheck everything.\n\nQmlWeb.registerQmlType({\n  module: \"QtWebSockets\",\n  name: \"WebSocket\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    WebSocket: { Connecting: 0, Open: 1, Closing: 2, Closed: 3, Error: 4 }\n  },\n  properties: {\n    active: \"bool\",\n    status: { type: \"enum\", initialValue: 3 }, // WebSocket.Closed\n    errorString: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    textMessageReceived: [{ type: \"string\", name: \"message\" }]\n  }\n}, function () {\n  function _class85(meta) {\n    _classCallCheck(this, _class85);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$socket = undefined;\n    this.$reconnect = false;\n\n    this.statusChanged.connect(this, this.$onStatusChanged);\n    this.activeChanged.connect(this, this.$reconnectSocket);\n    this.urlChanged.connect(this, this.$reconnectSocket);\n  }\n\n  _createClass(_class85, [{\n    key: \"$onStatusChanged\",\n    value: function $onStatusChanged(status) {\n      if (status !== this.WebSocket.Error) {\n        this.errorString = \"\";\n      }\n    }\n  }, {\n    key: \"$connectSocket\",\n    value: function $connectSocket() {\n      var _this53 = this;\n\n      this.$reconnect = false;\n\n      if (!this.url || !this.active) {\n        return;\n      }\n\n      this.status = this.WebSocket.Connecting;\n      this.$socket = new WebSocket(this.url);\n      this.$socket.onopen = function () {\n        _this53.status = _this53.WebSocket.Open;\n      };\n      this.$socket.onclose = function () {\n        _this53.status = _this53.WebSocket.Closed;\n        if (_this53.$reconnect) {\n          _this53.$connectSocket();\n        }\n      };\n      this.$socket.onerror = function (error) {\n        _this53.errorString = error.message;\n        _this53.status = _this53.WebSocket.Error;\n      };\n      this.$socket.onmessage = function (message) {\n        _this53.textMessageReceived(message.data);\n      };\n    }\n  }, {\n    key: \"$reconnectSocket\",\n    value: function $reconnectSocket() {\n      this.$reconnect = true;\n      if (this.status === this.WebSocket.Open) {\n        this.status = this.WebSocket.Closing;\n        this.$socket.close();\n      } else if (this.status !== this.WebSocket.Closing) {\n        this.$connectSocket();\n      }\n    }\n  }, {\n    key: \"sendTextMessage\",\n    value: function sendTextMessage(message) {\n      if (this.status === this.WebSocket.Open) {\n        this.$socket.send(message);\n      }\n    }\n  }]);\n\n  return _class85;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtWebView\",\n  name: \"WebView\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    canGoBack: \"bool\", // TODO\n    canGoForward: \"bool\", // TODO\n    loadProgress: \"int\",\n    loading: \"bool\",\n    title: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    /* // TODO\r\n    loadingChanged: [\r\n      { type: \"WebViewLoadRequest\", name: \"loadRequest\" }\r\n    ]\r\n    */\n  }\n}, function () {\n  function _class86(meta) {\n    var _this54 = this;\n\n    _classCallCheck(this, _class86);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.urlChanged.connect(this, this.$onUrlChanged);\n\n    var iframe = this.impl = document.createElement(\"iframe\");\n    iframe.style.display = \"block\";\n    iframe.style.position = \"absolute\";\n    iframe.style.width = \"100%\";\n    iframe.style.height = \"100%\";\n    iframe.style.borderWidth = \"0\";\n    iframe.style.pointerEvents = \"auto\";\n    this.dom.appendChild(iframe);\n\n    iframe.onload = function () {\n      try {\n        _this54.title = iframe.contentDocument.title;\n      } catch (e) {\n        console.log(\"CSP prevents us from reading title for \" + _this54.url);\n        _this54.title = \"\";\n      }\n      _this54.loadProgress = 100;\n      _this54.loading = false;\n    };\n    iframe.onerror = function () {\n      _this54.title = \"\";\n      _this54.loadProgress = 0;\n      _this54.loading = false;\n    };\n  }\n\n  _createClass(_class86, [{\n    key: \"$onUrlChanged\",\n    value: function $onUrlChanged(newVal) {\n      this.loadProgress = 0;\n      this.loading = true;\n      this.impl.src = newVal;\n    }\n  }]);\n\n  return _class86;\n}());\n}(typeof global != \"undefined\" ? global : window));\n\n\n",";(function(global) {\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QmlWeb = {};\n\nglobal.QmlWeb = QmlWeb;\n\nvar objectIds = 0;\n\nvar QObject = function () {\n  function QObject(parent) {\n    _classCallCheck(this, QObject);\n\n    this.$parent = parent;\n    if (parent && parent.$tidyupList) {\n      parent.$tidyupList.push(this);\n    }\n\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n    this.$signals = [];\n\n    this.objectId = objectIds++;\n  }\n\n  _createClass(QObject, [{\n    key: \"$delete\",\n    value: function $delete() {\n      if (this.$Component) {\n        this.$Component.destruction();\n      }\n\n      while (this.$tidyupList.length > 0) {\n        var item = this.$tidyupList[0];\n        if (item.$delete) {\n          // It's a QObject\n          item.$delete();\n        } else {\n          // It must be a signal\n          item.disconnect(this);\n        }\n      }\n\n      for (var i in this.$properties) {\n        var prop = this.$properties[i];\n        while (prop.$tidyupList.length > 0) {\n          prop.$tidyupList[0].disconnect(prop);\n        }\n      }\n\n      if (this.$parent && this.$parent.$tidyupList) {\n        var index = this.$parent.$tidyupList.indexOf(this);\n        this.$parent.$tidyupList.splice(index, 1);\n      }\n\n      // must do this:\n      // 1) parent will be notified and erase object from it's children.\n      // 2) DOM node will be removed.\n      this.parent = undefined;\n\n      // Disconnect any slots connected to any of our signals. Do this after\n      // clearing the parent, as that relies on parentChanged being handled.\n      for (var _i in this.$signals) {\n        this.$signals[_i].disconnect();\n      }\n    }\n\n    // must have a `destroy` method\n    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.$delete();\n    }\n  }, {\n    key: \"$toString\",\n    value: function $toString() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.constructor.name + \"(\" + args.join(\", \") + \")\";\n    }\n  }]);\n\n  return QObject;\n}();\n\nQmlWeb.QObject = QObject;\n\nvar JSItemModel = function () {\n  function JSItemModel() {\n    _classCallCheck(this, JSItemModel);\n\n    this.roleNames = [];\n\n    var Signal = QmlWeb.Signal;\n    this.dataChanged = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsInserted = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.rowsMoved = Signal.signal([{ type: \"int\", name: \"sourceStartIndex\" }, { type: \"int\", name: \"sourceEndIndex\" }, { type: \"int\", name: \"destinationIndex\" }]);\n    this.rowsRemoved = Signal.signal([{ type: \"int\", name: \"startIndex\" }, { type: \"int\", name: \"endIndex\" }]);\n    this.modelReset = Signal.signal();\n  }\n\n  _createClass(JSItemModel, [{\n    key: \"setRoleNames\",\n    value: function setRoleNames(names) {\n      this.roleNames = names;\n    }\n  }]);\n\n  return JSItemModel;\n}();\n\nQmlWeb.JSItemModel = JSItemModel;\n\nvar QColor = function () {\n  function QColor() {\n    _classCallCheck(this, QColor);\n\n    this.$changed = new QmlWeb.Signal();\n    this.$r = this.$g = this.$b = 0;\n    this.$a = 1;\n    var val = arguments.length <= 0 ? undefined : arguments[0];\n    if (arguments.length >= 3) {\n      this.$r = arguments.length <= 0 ? undefined : arguments[0];\n      this.$g = arguments.length <= 1 ? undefined : arguments[1];\n      this.$b = arguments.length <= 2 ? undefined : arguments[2];\n      if (arguments.length >= 4) {\n        this.$a = arguments.length <= 3 ? undefined : arguments[3];\n      }\n    } else if (val instanceof QColor) {\n      // Copy constructor\n      this.$a = val.a;\n      this.$r = val.r;\n      this.$g = val.g;\n      this.$b = val.b;\n    } else if (typeof val === \"string\") {\n      var lval = val.toLowerCase();\n      if (QColor.colormap[lval]) {\n        var rgb = QColor.colormap[lval];\n        this.$r = rgb[0] / 255;\n        this.$g = rgb[1] / 255;\n        this.$b = rgb[2] / 255;\n      } else if (lval === \"transparent\") {\n        this.$a = 0;\n      } else if (lval[0] === \"#\") {\n        var hex = lval.substr(1);\n        if (hex.length === 3) {\n          this.$r = parseInt(hex[0], 16) / 15;\n          this.$g = parseInt(hex[1], 16) / 15;\n          this.$b = parseInt(hex[2], 16) / 15;\n        } else {\n          var _rgb = hex.match(/.{2}/g).map(function (x) {\n            return parseInt(x, 16);\n          });\n          if (_rgb.length === 4) {\n            this.$a = _rgb.shift() / 255;\n          }\n          this.$r = _rgb[0] / 255;\n          this.$g = _rgb[1] / 255;\n          this.$b = _rgb[2] / 255;\n        }\n      } else {\n        throw new Error(\"Can not convert \" + val + \" to color\");\n      }\n    } else if (typeof val !== \"undefined\") {\n      throw new Error(\"Can not assign \" + (typeof val === \"undefined\" ? \"undefined\" : _typeof(val)) + \" to QColor\");\n    }\n  }\n\n  _createClass(QColor, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.$string) return this.$string;\n      var argb = [this.$a, this.$r, this.$g, this.$b].map(function (x) {\n        return (Math.round(x * 255) + 0x100).toString(16).substr(-2);\n      });\n      if (argb[0] === \"ff\") {\n        argb.shift(); // We don't need alpha if it's ff\n      }\n      this.$string = \"#\" + argb.join(\"\");\n      return \"#\" + argb.join(\"\");\n    }\n  }, {\n    key: \"$css\",\n    get: function get() {\n      if (this.$cssValue) return this.$cssValue;\n      if (this.$a === 1) {\n        this.$cssValue = this.toString();\n      } else if (this.$a === 0) {\n        this.$cssValue = \"transparent\";\n      } else {\n        var intr = Math.round(this.$r * 255);\n        var intg = Math.round(this.$g * 255);\n        var intb = Math.round(this.$b * 255);\n        this.$cssValue = \"rgba(\" + intr + \",\" + intg + \",\" + intb + \",\" + this.$a + \")\";\n      }\n      return this.$cssValue;\n    }\n  }, {\n    key: \"r\",\n    get: function get() {\n      return this.$r;\n    },\n    set: function set(r) {\n      this.$r = r;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"g\",\n    get: function get() {\n      return this.$g;\n    },\n    set: function set(g) {\n      this.$g = g;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"b\",\n    get: function get() {\n      return this.$b;\n    },\n    set: function set(b) {\n      this.$b = b;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"a\",\n    get: function get() {\n      return this.$a;\n    },\n    set: function set(a) {\n      this.$a = a;\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvHue\",\n    get: function get() {\n      var v = this.hsvValue;\n      var m = Math.min(this.$r, this.$g, this.$b);\n      if (v === m) return -1;\n      if (v === this.$r) return ((this.$g - this.$b) / (v - m) + 1) % 1 / 6;\n      if (v === this.$g) return ((this.$b - this.$r) / (v - m) + 2) / 6;\n      if (v === this.$b) return ((this.$r - this.$g) / (v - m) + 4) / 6;\n      throw new Error();\n    },\n    set: function set(h) {\n      var rgb = QColor.$hsv(h, this.hsvSaturation, this.hsvValue);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvSaturation\",\n    get: function get() {\n      var v = this.hsvValue;\n      if (v === 0) return 0;\n      return 1 - Math.min(this.$r, this.$g, this.$b) / v;\n    },\n    set: function set(s) {\n      var rgb = QColor.$hsv(this.hsvHue, s, this.hsvValue);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hsvValue\",\n    get: function get() {\n      return Math.max(this.$r, this.$g, this.$b);\n    },\n    set: function set(v) {\n      var rgb = QColor.$hsv(this.hsvHue, this.hsvSaturation, v);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslHue\",\n    get: function get() {\n      return this.hsvHue;\n    },\n    set: function set(h) {\n      var rgb = QColor.$hsl(h, this.hslSaturation, this.hslLightness);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslSaturation\",\n    get: function get() {\n      var max = Math.max(this.$r, this.$g, this.$b);\n      var min = Math.min(this.$r, this.$g, this.$b);\n      if (max === min) return 0;\n      return (max - min) / (1 - Math.abs(1 - max - min));\n    },\n    set: function set(s) {\n      var rgb = QColor.$hsl(this.hslHue, s, this.hslLightness);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }, {\n    key: \"hslLightness\",\n    get: function get() {\n      var max = Math.max(this.$r, this.$g, this.$b);\n      var min = Math.min(this.$r, this.$g, this.$b);\n      return (max + min) / 2;\n    },\n    set: function set(l) {\n      var rgb = QColor.$hsl(this.hslHue, this.hslSaturation, l);\n      this.$r = rgb[0];\n      this.$g = rgb[1];\n      this.$b = rgb[2];\n      this.$string = this.$cssValue = null;\n      this.$changed.execute();\n    }\n  }], [{\n    key: \"$hsv\",\n    value: function $hsv(h, s, v) {\n      var c = v * s;\n      var m = v - c;\n      return QColor.$hcma(h, c, m);\n    }\n  }, {\n    key: \"$hsl\",\n    value: function $hsl(h, s, l) {\n      var c = (1 - Math.abs(2 * l - 1)) * s;\n      var m = l - c / 2;\n      return QColor.$hcma(h, c, m);\n    }\n  }, {\n    key: \"$hcma\",\n    value: function $hcma(h, c, m) {\n      var hh = h > 0 ? h * 6 % 6 : 0;\n      var x = c * (1 - Math.abs(hh % 2 - 1));\n      var rgb = void 0;\n      switch (Math.floor(hh)) {\n        case 0:\n          rgb = [c, x, 0];\n          break;\n        case 1:\n          rgb = [x, c, 0];\n          break;\n        case 2:\n          rgb = [0, c, x];\n          break;\n        case 3:\n          rgb = [0, x, c];\n          break;\n        case 4:\n          rgb = [x, 0, c];\n          break;\n        case 5:\n          rgb = [c, 0, x];\n          break;\n      }\n      return rgb.map(function (y) {\n        return Math.min(1, y + m);\n      });\n    }\n  }, {\n    key: \"darker\",\n    value: function darker(baseColor) {\n      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);\n      var v = color.hsvValue / factor;\n      // Undocumented in Qt, but this matches the observed Qt behaviour\n      var s = color.hsvSaturation - Math.max(0, v - 1);\n      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\n    }\n  }, {\n    key: \"lighter\",\n    value: function lighter(baseColor) {\n      var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.5;\n\n      var color = baseColor instanceof QColor ? baseColor : new QColor(baseColor);\n      var v = color.hsvValue * factor;\n      // Undocumented in Qt, but this matches the observed Qt behaviour\n      var s = color.hsvSaturation - Math.max(0, v - 1);\n      return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\n    }\n  }, {\n    key: \"equal\",\n    value: function equal(lhs, rhs) {\n      var a = lhs instanceof QColor ? lhs : new QColor(lhs);\n      var b = rhs instanceof QColor ? rhs : new QColor(rhs);\n      return a.toString() === b.toString();\n    }\n  }]);\n\n  return QColor;\n}();\n\nQColor.rgba = function (r, g, b) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new QColor(r, g, b, a);\n};\n\nQColor.hsva = function (h, s, v) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsv(h, s, v)), [a])))();\n};\n\nQColor.hsla = function (h, s, l) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return new (Function.prototype.bind.apply(QColor, [null].concat(_toConsumableArray(QColor.$hsl(h, s, l)), [a])))();\n};\n\nQColor.colormap = { // https://www.w3.org/TR/SVG/types.html#ColorKeywords\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nQColor.nonNullableType = true;\nQColor.requireConstructor = true;\n\nQmlWeb.QColor = QColor;\n\nvar QFont = function (_QmlWeb$QObject) {\n  _inherits(QFont, _QmlWeb$QObject);\n\n  function QFont(parent) {\n    _classCallCheck(this, QFont);\n\n    var _this = _possibleConstructorReturn(this, (QFont.__proto__ || Object.getPrototypeOf(QFont)).call(this, parent));\n\n    _this.Font = QFont.Font;\n\n    var Font = _this.Font;\n\n    QmlWeb.createProperties(_this, {\n      bold: \"bool\",\n      capitalization: { type: \"enum\", initialValue: Font.MixedCase },\n      family: { type: \"string\", initialValue: \"sans-serif\" },\n      italic: \"bool\",\n      letterSpacing: \"real\",\n      pixelSize: { type: \"int\", initialValue: 13 },\n      pointSize: { type: \"real\", initialValue: 10 },\n      strikeout: \"bool\",\n      underline: \"bool\",\n      weight: { type: \"enum\", initialValue: Font.Normal },\n      wordSpacing: \"real\"\n    });\n\n    _this.$sizeLock = false;\n\n    _this.boldChanged.connect(_this, _this.$onBoldChanged);\n    _this.capitalizationChanged.connect(_this, _this.$onCapitalizationChanged);\n    _this.familyChanged.connect(_this, _this.$onFamilyChanged);\n    _this.italicChanged.connect(_this, _this.$onItalicChanged);\n    _this.letterSpacingChanged.connect(_this, _this.$onLetterSpacingChanged);\n    _this.pixelSizeChanged.connect(_this, _this.$onPixelSizeChanged);\n    _this.pointSizeChanged.connect(_this, _this.$onPointSizeChanged);\n    _this.strikeoutChanged.connect(_this, _this.$onStrikeoutChanged);\n    _this.underlineChanged.connect(_this, _this.$onUnderlineChanged);\n    _this.weightChanged.connect(_this, _this.$onWidthChanged);\n    _this.wordSpacingChanged.connect(_this, _this.$onWordSpacingChanged);\n    return _this;\n  }\n\n  _createClass(QFont, [{\n    key: \"$onBoldChanged\",\n    value: function $onBoldChanged(newVal) {\n      var Font = this.Font;\n      this.weight = newVal ? Font.Bold : Font.Normal;\n    }\n  }, {\n    key: \"$onCapitalizationChanged\",\n    value: function $onCapitalizationChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontVariant = newVal === this.Font.SmallCaps ? \"small-caps\" : \"none\";\n      style.textTransform = this.$capitalizationToTextTransform(newVal);\n    }\n  }, {\n    key: \"$onFamilyChanged\",\n    value: function $onFamilyChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontFamily = newVal;\n    }\n  }, {\n    key: \"$onItalicChanged\",\n    value: function $onItalicChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontStyle = newVal ? \"italic\" : \"normal\";\n    }\n  }, {\n    key: \"$onLetterSpacingChanged\",\n    value: function $onLetterSpacingChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.letterSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n    }\n  }, {\n    key: \"$onPixelSizeChanged\",\n    value: function $onPixelSizeChanged(newVal) {\n      if (!this.$sizeLock) {\n        this.pointSize = newVal * 0.75;\n      }\n      var val = newVal + \"px\";\n      this.$parent.dom.style.fontSize = val;\n      this.$parent.dom.firstChild.style.fontSize = val;\n    }\n  }, {\n    key: \"$onPointSizeChanged\",\n    value: function $onPointSizeChanged(newVal) {\n      this.$sizeLock = true;\n      this.pixelSize = Math.round(newVal / 0.75);\n      this.$sizeLock = false;\n    }\n  }, {\n    key: \"$onStrikeoutChanged\",\n    value: function $onStrikeoutChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.textDecoration = newVal ? \"line-through\" : this.$parent.font.underline ? \"underline\" : \"none\";\n    }\n  }, {\n    key: \"$onUnderlineChanged\",\n    value: function $onUnderlineChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.textDecoration = this.$parent.font.strikeout ? \"line-through\" : newVal ? \"underline\" : \"none\";\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.fontWeight = this.$weightToCss(newVal);\n    }\n  }, {\n    key: \"$onWordSpacingChanged\",\n    value: function $onWordSpacingChanged(newVal) {\n      var style = this.$parent.dom.firstChild.style;\n      style.wordSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n    }\n  }, {\n    key: \"$weightToCss\",\n    value: function $weightToCss(weight) {\n      var Font = this.Font;\n      switch (weight) {\n        case Font.Thin:\n          return \"100\";\n        case Font.ExtraLight:\n          return \"200\";\n        case Font.Light:\n          return \"300\";\n        case Font.Normal:\n          return \"400\";\n        case Font.Medium:\n          return \"500\";\n        case Font.DemiBold:\n          return \"600\";\n        case Font.Bold:\n          return \"700\";\n        case Font.ExtraBold:\n          return \"800\";\n        case Font.Black:\n          return \"900\";\n      }\n      return \"normal\";\n    }\n  }, {\n    key: \"$capitalizationToTextTransform\",\n    value: function $capitalizationToTextTransform(capitalization) {\n      var Font = this.Font;\n      switch (capitalization) {\n        case Font.AllUppercase:\n          return \"uppercase\";\n        case Font.AllLowercase:\n          return \"lowercase\";\n        case Font.Capitalize:\n          return \"capitalize\";\n      }\n      return \"none\";\n    }\n  }]);\n\n  return QFont;\n}(QmlWeb.QObject);\n\nQFont.Font = {\n  // Capitalization\n  MixedCase: 0,\n  AllUppercase: 1,\n  AllLowercase: 2,\n  SmallCaps: 3,\n  Capitalize: 4,\n  // Weight\n  Thin: 0,\n  ExtraLight: 12,\n  Light: 25,\n  Normal: 50,\n  Medium: 57,\n  DemiBold: 63,\n  Bold: 75,\n  ExtraBold: 81,\n  Black: 87\n};\nQFont.requireParent = true;\n\n\nQmlWeb.QFont = QFont;\nglobal.Font = QFont.Font; // HACK\n\nvar QMatrix4x4 = function (_QmlWeb$QObject2) {\n  _inherits(QMatrix4x4, _QmlWeb$QObject2);\n\n  function QMatrix4x4() {\n    _classCallCheck(this, QMatrix4x4);\n\n    var _this2 = _possibleConstructorReturn(this, (QMatrix4x4.__proto__ || Object.getPrototypeOf(QMatrix4x4)).call(this));\n\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [];\n      for (var row = 1; row <= 4; row++) {\n        for (var col = 1; col <= 4; col++) {\n          data.push(col === row ? 1 : 0);\n        }\n      }\n    } else if (args.length === 1 && args[0] instanceof QMatrix4x4) {\n      data = [];\n      for (var _row = 1; _row <= 4; _row++) {\n        for (var _col = 1; _col <= 4; _col++) {\n          var name = \"m\" + _row + _col;\n          data.push(args[0][name]);\n        }\n      }\n    } else if (args.length !== 16) {\n      throw new Error(\"Invalid arguments\");\n    }\n    for (var _row2 = 1; _row2 <= 4; _row2++) {\n      for (var _col2 = 1; _col2 <= 4; _col2++) {\n        var _name = \"m\" + _row2 + _col2;\n        var value = data[4 * (_row2 - 1) + _col2 - 1];\n        QmlWeb.createProperty(\"real\", _this2, _name, { initialValue: value });\n      }\n    }\n    return _this2;\n  }\n\n  _createClass(QMatrix4x4, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QMatrix4x4.prototype.__proto__ || Object.getPrototypeOf(QMatrix4x4.prototype), \"$toString\", this).call(this, this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44);\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var t = this;\n        return new QmlWeb.QMatrix4x4(t.m11 * a.m11 + t.m12 * a.m21 + t.m13 * a.m31 + t.m14 * a.m41, t.m11 * a.m12 + t.m12 * a.m22 + t.m13 * a.m32 + t.m14 * a.m42, t.m11 * a.m13 + t.m12 * a.m23 + t.m13 * a.m33 + t.m14 * a.m43, t.m11 * a.m14 + t.m12 * a.m24 + t.m13 * a.m34 + t.m14 * a.m44, t.m21 * a.m11 + t.m22 * a.m21 + t.m23 * a.m31 + t.m24 * a.m41, t.m21 * a.m12 + t.m22 * a.m22 + t.m23 * a.m32 + t.m24 * a.m42, t.m21 * a.m13 + t.m22 * a.m23 + t.m23 * a.m33 + t.m24 * a.m43, t.m21 * a.m14 + t.m22 * a.m24 + t.m23 * a.m34 + t.m24 * a.m44, t.m31 * a.m11 + t.m32 * a.m21 + t.m33 * a.m31 + t.m34 * a.m41, t.m31 * a.m12 + t.m32 * a.m22 + t.m33 * a.m32 + t.m34 * a.m42, t.m31 * a.m13 + t.m32 * a.m23 + t.m33 * a.m33 + t.m34 * a.m43, t.m31 * a.m14 + t.m32 * a.m24 + t.m33 * a.m34 + t.m34 * a.m44, t.m41 * a.m11 + t.m42 * a.m21 + t.m43 * a.m31 + t.m44 * a.m41, t.m41 * a.m12 + t.m42 * a.m22 + t.m43 * a.m32 + t.m44 * a.m42, t.m41 * a.m13 + t.m42 * a.m23 + t.m43 * a.m33 + t.m44 * a.m43, t.m41 * a.m14 + t.m42 * a.m24 + t.m43 * a.m34 + t.m44 * a.m44);\n      }\n      if (a instanceof QmlWeb.QVector4D) {\n        var _t = this;\n        return new QmlWeb.QVector4D(_t.m11 * a.x + _t.m12 * a.y + _t.m13 * a.z + _t.m14 * a.w, _t.m21 * a.x + _t.m22 * a.y + _t.m23 * a.z + _t.m24 * a.w, _t.m31 * a.x + _t.m32 * a.y + _t.m33 * a.z + _t.m34 * a.w, _t.m41 * a.x + _t.m42 * a.y + _t.m43 * a.z + _t.m44 * a.w);\n      }\n      if (a instanceof QmlWeb.QVector3D) {\n        var v = this.times(new QmlWeb.QVector4D(a.x, a.y, a.z, 1));\n        return new QmlWeb.QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\n      }\n      return new QMatrix4x4(this.m11 * a, this.m12 * a, this.m13 * a, this.m14 * a, this.m21 * a, this.m22 * a, this.m23 * a, this.m24 * a, this.m31 * a, this.m32 * a, this.m33 * a, this.m34 * a, this.m41 * a, this.m42 * a, this.m43 * a, this.m44 * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(other) {\n      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\n      return new QMatrix4x4(this.m11 + a.m11, this.m12 + a.m12, this.m13 + a.m13, this.m14 + a.m14, this.m21 + a.m21, this.m22 + a.m22, this.m23 + a.m23, this.m24 + a.m24, this.m31 + a.m31, this.m32 + a.m32, this.m33 + a.m33, this.m34 + a.m34, this.m41 + a.m41, this.m42 + a.m42, this.m43 + a.m43, this.m44 + a.m44);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(other) {\n      var a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\n      return new QMatrix4x4(this.m11 - a.m11, this.m12 - a.m12, this.m13 - a.m13, this.m14 - a.m14, this.m21 - a.m21, this.m22 - a.m22, this.m23 - a.m23, this.m24 - a.m24, this.m31 - a.m31, this.m32 - a.m32, this.m33 - a.m33, this.m34 - a.m34, this.m41 - a.m41, this.m42 - a.m42, this.m43 - a.m43, this.m44 - a.m44);\n    }\n  }, {\n    key: \"row\",\n    value: function row(i) {\n      var _this3 = this;\n\n      var row = i + 1;\n      var arr = [1, 2, 3, 4].map(function (col) {\n        return _this3[\"m\" + row + col];\n      });\n      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();\n    }\n  }, {\n    key: \"column\",\n    value: function column(i) {\n      var _this4 = this;\n\n      var col = i + 1;\n      var arr = [1, 2, 3, 4].map(function (row) {\n        return _this4[\"m\" + row + col];\n      });\n      return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(_toConsumableArray(arr))))();\n    }\n  }, {\n    key: \"determinant\",\n    value: function determinant() {\n      // Laplace expansion\n      var t = this;\n      var s0 = t.m11 * t.m22 - t.m12 * t.m21;\n      var c5 = t.m33 * t.m44 - t.m34 * t.m43;\n      var s1 = t.m11 * t.m23 - t.m13 * t.m21;\n      var c4 = t.m32 * t.m44 - t.m34 * t.m42;\n      var s2 = t.m11 * t.m24 - t.m14 * t.m21;\n      var c3 = t.m32 * t.m43 - t.m33 * t.m42;\n      var s3 = t.m12 * t.m23 - t.m13 * t.m22;\n      var c2 = t.m31 * t.m44 - t.m34 * t.m41;\n      var s4 = t.m12 * t.m24 - t.m14 * t.m22;\n      var c1 = t.m31 * t.m43 - t.m33 * t.m41;\n      var s5 = t.m13 * t.m24 - t.m14 * t.m23;\n      var c0 = t.m31 * t.m42 - t.m32 * t.m41;\n      return s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\n    }\n  }, {\n    key: \"inverted\",\n    value: function inverted() {\n      // Laplace expansion\n      var t = this;\n      var s0 = t.m11 * t.m22 - t.m12 * t.m21;\n      var c5 = t.m33 * t.m44 - t.m34 * t.m43;\n      var s1 = t.m11 * t.m23 - t.m13 * t.m21;\n      var c4 = t.m32 * t.m44 - t.m34 * t.m42;\n      var s2 = t.m11 * t.m24 - t.m14 * t.m21;\n      var c3 = t.m32 * t.m43 - t.m33 * t.m42;\n      var s3 = t.m12 * t.m23 - t.m13 * t.m22;\n      var c2 = t.m31 * t.m44 - t.m34 * t.m41;\n      var s4 = t.m12 * t.m24 - t.m14 * t.m22;\n      var c1 = t.m31 * t.m43 - t.m33 * t.m41;\n      var s5 = t.m13 * t.m24 - t.m14 * t.m23;\n      var c0 = t.m31 * t.m42 - t.m32 * t.m41;\n      var det = s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\n      var adj = [+t.m22 * c5 - t.m23 * c4 + t.m24 * c3, -t.m12 * c5 + t.m13 * c4 - t.m14 * c3, +t.m42 * s5 - t.m43 * s4 + t.m44 * s3, -t.m32 * s5 + t.m33 * s4 - t.m34 * s3, -t.m21 * c5 + t.m23 * c2 - t.m24 * c1, +t.m11 * c5 - t.m13 * c2 + t.m14 * c1, -t.m41 * s5 + t.m43 * s2 - t.m44 * s1, +t.m31 * s5 - t.m33 * s2 + t.m34 * s1, +t.m21 * c4 - t.m22 * c2 + t.m24 * c0, -t.m11 * c4 + t.m12 * c2 - t.m14 * c0, +t.m41 * s4 - t.m42 * s2 + t.m44 * s0, -t.m31 * s4 + t.m32 * s2 - t.m34 * s0, -t.m21 * c3 + t.m22 * c1 - t.m23 * c0, +t.m11 * c3 - t.m12 * c1 + t.m13 * c0, -t.m41 * s3 + t.m42 * s1 - t.m43 * s0, +t.m31 * s3 - t.m32 * s1 + t.m33 * s0];\n      return new (Function.prototype.bind.apply(QMatrix4x4, [null].concat(_toConsumableArray(adj.map(function (x) {\n        return x / det;\n      })))))();\n    }\n  }, {\n    key: \"transposed\",\n    value: function transposed() {\n      return new QMatrix4x4(this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43, this.m14, this.m24, this.m34, this.m44);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      for (var row = 1; row <= 4; row++) {\n        for (var col = 1; col <= 4; col++) {\n          var name = \"m\" + row + col;\n          if (Math.abs(this[name] - a[name]) > epsilon) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }]);\n\n  return QMatrix4x4;\n}(QmlWeb.QObject);\n\nQMatrix4x4.nonNullableType = true;\nQMatrix4x4.requireConstructor = true;\n\n\nQmlWeb.QMatrix4x4 = QMatrix4x4;\n\nvar QPointF = function (_QmlWeb$QObject3) {\n  _inherits(QPointF, _QmlWeb$QObject3);\n\n  function QPointF() {\n    _classCallCheck(this, QPointF);\n\n    var _this5 = _possibleConstructorReturn(this, (QPointF.__proto__ || Object.getPrototypeOf(QPointF)).call(this));\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [0, 0];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) throw new Error(\"point expected\");\n    } else if (args.length === 1 && args[0] instanceof QPointF) {\n      data = [args[0].x, args[0].y];\n    } else if (args.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this5, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] }\n    });\n    return _this5;\n  }\n\n  _createClass(QPointF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QPointF.prototype.__proto__ || Object.getPrototypeOf(QPointF.prototype), \"$toString\", this).call(this, this.x, this.y);\n    }\n  }]);\n\n  return QPointF;\n}(QmlWeb.QObject);\n\nQPointF.nonNullableType = true;\nQPointF.requireConstructor = true;\n\n\nQmlWeb.QPointF = QPointF;\n\nvar QQuaternion = function (_QmlWeb$QObject4) {\n  _inherits(QQuaternion, _QmlWeb$QObject4);\n\n  function QQuaternion() {\n    _classCallCheck(this, QQuaternion);\n\n    var _this6 = _possibleConstructorReturn(this, (QQuaternion.__proto__ || Object.getPrototypeOf(QQuaternion)).call(this));\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 4) data = [];\n    } else if (args.length === 1 && args[0] instanceof QQuaternion) {\n      data = [args[0].scalar, args[0].x, args[0].y, args[0].z];\n    }\n    if (data.length === 0) {\n      data = [1, 0, 0, 0];\n    } else if (data.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this6, {\n      scalar: { type: \"real\", initialValue: data[0] },\n      x: { type: \"real\", initialValue: data[1] },\n      y: { type: \"real\", initialValue: data[2] },\n      z: { type: \"real\", initialValue: data[3] }\n    });\n    return _this6;\n  }\n\n  _createClass(QQuaternion, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QQuaternion.prototype.__proto__ || Object.getPrototypeOf(QQuaternion.prototype), \"$toString\", this).call(this, this.scalar, this.x, this.y, this.z);\n    }\n  }]);\n\n  return QQuaternion;\n}(QmlWeb.QObject);\n\nQQuaternion.nonNullableType = true;\nQQuaternion.requireConstructor = true;\n\n\nQmlWeb.QQuaternion = QQuaternion;\n\nvar QRectF = function (_QmlWeb$QObject5) {\n  _inherits(QRectF, _QmlWeb$QObject5);\n\n  function QRectF() {\n    _classCallCheck(this, QRectF);\n\n    var _this7 = _possibleConstructorReturn(this, (QRectF.__proto__ || Object.getPrototypeOf(QRectF)).call(this));\n\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [0, 0, 0, 0];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      var mask = /^\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*x\\s*[-\\d.]+\\s*$/;\n      if (!args[0].match(mask)) throw new Error(\"rect expected\");\n      data = args[0].replace(\"x\", \",\").split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n    } else if (args.length === 1 && args[0] instanceof QRectF) {\n      data = [args[0].x, args[0].y, args[0].z, args[0].width];\n    } else if (args.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this7, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      width: { type: \"real\", initialValue: data[2] },\n      height: { type: \"real\", initialValue: data[3] }\n    });\n    return _this7;\n  }\n\n  _createClass(QRectF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QRectF.prototype.__proto__ || Object.getPrototypeOf(QRectF.prototype), \"$toString\", this).call(this, this.x, this.y, this.width, this.height);\n    }\n  }]);\n\n  return QRectF;\n}(QmlWeb.QObject);\n\nQRectF.nonNullableType = true;\nQRectF.requireConstructor = true;\n\n\nQmlWeb.QRectF = QRectF;\n\nvar QSizeF = function (_QmlWeb$QObject6) {\n  _inherits(QSizeF, _QmlWeb$QObject6);\n\n  function QSizeF() {\n    _classCallCheck(this, QSizeF);\n\n    var _this8 = _possibleConstructorReturn(this, (QSizeF.__proto__ || Object.getPrototypeOf(QSizeF)).call(this));\n\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var data = args;\n    if (args.length === 0) {\n      data = [-1, -1];\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\"x\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) throw new Error(\"size expected\");\n    } else if (args.length === 1 && args[0] instanceof QSizeF) {\n      data = [args[0].width, args[0].height];\n    } else if (args.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this8, {\n      width: { type: \"real\", initialValue: data[0] },\n      height: { type: \"real\", initialValue: data[1] }\n    });\n    return _this8;\n  }\n\n  _createClass(QSizeF, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QSizeF.prototype.__proto__ || Object.getPrototypeOf(QSizeF.prototype), \"$toString\", this).call(this, this.width, this.height);\n    }\n  }]);\n\n  return QSizeF;\n}(QmlWeb.QObject);\n\nQSizeF.nonNullableType = true;\nQSizeF.requireConstructor = true;\n\n\nQmlWeb.QSizeF = QSizeF;\n\nvar QVector2D = function (_QmlWeb$QObject7) {\n  _inherits(QVector2D, _QmlWeb$QObject7);\n\n  function QVector2D() {\n    _classCallCheck(this, QVector2D);\n\n    var _this9 = _possibleConstructorReturn(this, (QVector2D.__proto__ || Object.getPrototypeOf(QVector2D)).call(this));\n\n    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 2) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector2D) {\n      data = [args[0].x, args[0].y];\n    }\n    if (data.length === 0) {\n      data = [0, 0];\n    } else if (data.length !== 2) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this9, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] }\n    });\n    return _this9;\n  }\n\n  _createClass(QVector2D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector2D.prototype.__proto__ || Object.getPrototypeOf(QVector2D.prototype), \"$toString\", this).call(this, this.x, this.y);\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector2D) {\n        return a.x * this.x + a.y * this.y;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x * a.x, this.y * a.y);\n      }\n      return new QVector2D(this.x * a, this.y * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x + a.x, this.y + a.y);\n      }\n      return new QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector2D) {\n        return new QVector2D(this.x - a.x, this.y - a.y);\n      }\n      return new QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector3d\",\n    value: function toVector3d() {\n      return new QmlWeb.QVector3D(this.x, this.y, 0);\n    }\n  }, {\n    key: \"toVector4d\",\n    value: function toVector4d() {\n      return new QmlWeb.QVector4D(this.x, this.y, 0, 0);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector2D;\n}(QmlWeb.QObject);\n\nQVector2D.nonNullableType = true;\nQVector2D.requireConstructor = true;\n\n\nQmlWeb.QVector2D = QVector2D;\n\nvar QVector3D = function (_QmlWeb$QObject8) {\n  _inherits(QVector3D, _QmlWeb$QObject8);\n\n  function QVector3D() {\n    _classCallCheck(this, QVector3D);\n\n    var _this10 = _possibleConstructorReturn(this, (QVector3D.__proto__ || Object.getPrototypeOf(QVector3D)).call(this));\n\n    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 3) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector3D) {\n      data = [args[0].x, args[0].y, args[0].z];\n    }\n    if (data.length === 0) {\n      data = [0, 0, 0];\n    } else if (data.length !== 3) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this10, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      z: { type: \"real\", initialValue: data[2] }\n    });\n    return _this10;\n  }\n\n  _createClass(QVector3D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector3D.prototype.__proto__ || Object.getPrototypeOf(QVector3D.prototype), \"$toString\", this).call(this, this.x, this.y, this.z);\n    }\n  }, {\n    key: \"crossProduct\",\n    value: function crossProduct(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);\n      }\n      return new QVector3D();\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector3D) {\n        return a.x * this.x + a.y * this.y + a.z * this.z;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var v = new QmlWeb.QVector4D(this.x, this.y, this.z, 1).times(a);\n        return new QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\n      }\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x * a.x, this.y * a.y, this.z * a.z);\n      }\n      return new QVector3D(this.x * a, this.y * a, this.z * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x + a.x, this.y + a.y, this.z + a.z);\n      }\n      return new QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector3D) {\n        return new QVector3D(this.x - a.x, this.y - a.y, this.z - a.z);\n      }\n      return new QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector2d\",\n    value: function toVector2d() {\n      return new QmlWeb.QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"toVector4d\",\n    value: function toVector4d() {\n      return new QmlWeb.QVector4D(this.x, this.y, this.z, 0);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y, this.z - a.z].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector3D;\n}(QmlWeb.QObject);\n\nQVector3D.nonNullableType = true;\nQVector3D.requireConstructor = true;\n\n\nQmlWeb.QVector3D = QVector3D;\n\nvar QVector4D = function (_QmlWeb$QObject9) {\n  _inherits(QVector4D, _QmlWeb$QObject9);\n\n  function QVector4D() {\n    _classCallCheck(this, QVector4D);\n\n    var _this11 = _possibleConstructorReturn(this, (QVector4D.__proto__ || Object.getPrototypeOf(QVector4D)).call(this));\n\n    for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    var data = args;\n    if (args.length === 1 && typeof args[0] === \"string\") {\n      data = args[0].split(\",\").map(function (x) {\n        return parseFloat(x.trim(), 10);\n      });\n      if (data.length !== 4) data = [];\n    } else if (args.length === 1 && args[0] instanceof QVector4D) {\n      data = [args[0].x, args[0].y, args[0].z, args[0].w];\n    }\n    if (data.length === 0) {\n      data = [0, 0, 0, 0];\n    } else if (data.length !== 4) {\n      throw new Error(\"Invalid arguments\");\n    }\n    QmlWeb.createProperties(_this11, {\n      x: { type: \"real\", initialValue: data[0] },\n      y: { type: \"real\", initialValue: data[1] },\n      z: { type: \"real\", initialValue: data[2] },\n      w: { type: \"real\", initialValue: data[3] }\n    });\n    return _this11;\n  }\n\n  _createClass(QVector4D, [{\n    key: \"toString\",\n    value: function toString() {\n      return _get(QVector4D.prototype.__proto__ || Object.getPrototypeOf(QVector4D.prototype), \"$toString\", this).call(this, this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"dotProduct\",\n    value: function dotProduct(a) {\n      if (a instanceof QVector4D) {\n        return a.x * this.x + a.y * this.y + a.z * this.z + a.w * this.w;\n      }\n      return 0;\n    }\n  }, {\n    key: \"times\",\n    value: function times(a) {\n      if (a instanceof QmlWeb.QMatrix4x4) {\n        var t = this;\n        return new QVector4D(t.x * a.m11 + t.y * a.m21 + t.z * a.m31 + t.w * a.m41, t.x * a.m12 + t.y * a.m22 + t.z * a.m32 + t.w * a.m42, t.x * a.m13 + t.y * a.m23 + t.z * a.m33 + t.w * a.m43, t.x * a.m14 + t.y * a.m24 + t.z * a.m34 + t.w * a.m44);\n      }\n      if (a instanceof QVector4D) {\n        var _t2 = this;\n        return new QVector4D(_t2.x * a.x, _t2.y * a.y, _t2.z * a.z, _t2.w * a.w);\n      }\n      return new QVector4D(this.x * a, this.y * a, this.z * a, this.w * a);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(a) {\n      if (a instanceof QVector4D) {\n        var t = this;\n        return new QVector4D(t.x + a.x, t.y + a.y, t.z + a.z, t.w + a.w);\n      }\n      return new QVector4D(this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(a) {\n      if (a instanceof QVector4D) {\n        var t = this;\n        return new QVector4D(t.x - a.x, t.y - a.y, t.z - a.z, t.w - a.w);\n      }\n      return new QVector4D(this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: \"normalized\",\n    value: function normalized() {\n      var length = this.length();\n      return this.times(1 / (length === 0 ? 1 : length));\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.dotProduct(this));\n    }\n  }, {\n    key: \"toVector2d\",\n    value: function toVector2d() {\n      return new QmlWeb.QVector2D(this.x, this.y);\n    }\n  }, {\n    key: \"toVector3d\",\n    value: function toVector3d() {\n      return new QmlWeb.QVector3D(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"fuzzyEquals\",\n    value: function fuzzyEquals(a) {\n      var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n\n      return [this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w].every(function (delta) {\n        return Math.abs(delta) <= epsilon;\n      });\n    }\n  }]);\n\n  return QVector4D;\n}(QmlWeb.QObject);\n\nQVector4D.nonNullableType = true;\nQVector4D.requireConstructor = true;\n\n\nQmlWeb.QVector4D = QVector4D;\n\nvar Signal = function () {\n  function Signal() {\n    var _this12 = this;\n\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Signal);\n\n    this.connectedSlots = [];\n    this.obj = options.obj;\n    this.options = options;\n\n    this.signal = function () {\n      return _this12.execute.apply(_this12, arguments);\n    };\n    this.signal.parameters = params;\n    this.signal.connect = this.connect.bind(this);\n    this.signal.disconnect = this.disconnect.bind(this);\n    this.signal.isConnected = this.isConnected.bind(this);\n\n    // TODO Fix Keys that don't have an obj for the signal\n    if (this.obj && this.obj.$signals !== undefined) {\n      this.obj.$signals.push(this.signal);\n    }\n  }\n\n  _createClass(Signal, [{\n    key: \"execute\",\n    value: function execute() {\n      QmlWeb.QMLProperty.pushEvalStack();\n\n      for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      for (var i in this.connectedSlots) {\n        var desc = this.connectedSlots[i];\n        if (desc.type & Signal.QueuedConnection) {\n          Signal.$addQueued(desc, args);\n        } else {\n          Signal.$execute(desc, args);\n        }\n      }\n      QmlWeb.QMLProperty.popEvalStack();\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var type = Signal.AutoConnection;\n\n      for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n\n      if (typeof args[args.length - 1] === \"number\") {\n        type = args.pop();\n      }\n      if (type & Signal.UniqueConnection) {\n        if (this.isConnected.apply(this, args)) {\n          return;\n        }\n      }\n      if (args.length === 1) {\n        this.connectedSlots.push({ thisObj: global, slot: args[0], type: type });\n      } else if (typeof args[1] === \"string\" || args[1] instanceof String) {\n        if (args[0].$tidyupList && args[0] !== this.obj) {\n          args[0].$tidyupList.push(this.signal);\n        }\n        var slot = args[0][args[1]];\n        this.connectedSlots.push({ thisObj: args[0], slot: slot, type: type });\n      } else {\n        if (args[0].$tidyupList && (!this.obj || args[0] !== this.obj && args[0] !== this.obj.$parent)) {\n          args[0].$tidyupList.push(this.signal);\n        }\n        this.connectedSlots.push({ thisObj: args[0], slot: args[1], type: type });\n      }\n\n      // Notify object of connect\n      if (this.options.obj && this.options.obj.$connectNotify) {\n        this.options.obj.$connectNotify(this.options);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n\n      // type meaning:\n      //  1 = function, 2 = string\n      //  3 = object with string method,  4 = object with function\n      // No args means disconnect everything connected to this signal\n      var callType = args.length === 1 ? args[0] instanceof Function ? 1 : 2 : typeof args[1] === \"string\" || args[1] instanceof String ? 3 : 4;\n      for (var i = 0; i < this.connectedSlots.length; i++) {\n        var _connectedSlots$i = this.connectedSlots[i],\n            slot = _connectedSlots$i.slot,\n            thisObj = _connectedSlots$i.thisObj;\n\n        if (args.length === 0 || callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] || callType === 3 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {\n          if (thisObj) {\n            var index = thisObj.$tidyupList.indexOf(this.signal);\n            if (index >= 0) {\n              thisObj.$tidyupList.splice(index, 1);\n            }\n          }\n          this.connectedSlots.splice(i, 1);\n          // We have removed an item from the list so the indexes shifted one\n          // backwards\n          i--;\n        }\n      }\n\n      // Notify object of disconnect\n      if (this.options.obj && this.options.obj.$disconnectNotify) {\n        this.options.obj.$disconnectNotify(this.options);\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      for (var _len13 = arguments.length, args = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n\n      var callType = args.length === 1 ? 1 : typeof args[1] === \"string\" || args[1] instanceof String ? 2 : 3;\n      for (var i in this.connectedSlots) {\n        var _connectedSlots$i2 = this.connectedSlots[i],\n            slot = _connectedSlots$i2.slot,\n            thisObj = _connectedSlots$i2.thisObj;\n\n        if (callType === 1 && slot === args[0] || callType === 2 && thisObj === args[0] && slot === args[0][args[1]] || thisObj === args[0] && slot === args[1]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }], [{\n    key: \"signal\",\n    value: function signal() {\n      for (var _len14 = arguments.length, args = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n\n      return new (Function.prototype.bind.apply(Signal, [null].concat(args)))().signal;\n    }\n  }, {\n    key: \"$execute\",\n    value: function $execute(desc, args) {\n      try {\n        desc.slot.apply(desc.thisObj, args);\n      } catch (err) {\n        console.error(\"Signal slot error:\", err.message, err, desc.slot ? Function.prototype.toString.call(desc.slot) : \"desc.slot is undefined!\");\n      }\n    }\n  }, {\n    key: \"$addQueued\",\n    value: function $addQueued(desc, args) {\n      if (Signal.$queued.length === 0) {\n        if (global.setImmediate) {\n          global.setImmediate(Signal.$executeQueued);\n        } else {\n          global.setTimeout(Signal.$executeQueued, 0);\n        }\n      }\n      Signal.$queued.push([desc, args]);\n    }\n  }, {\n    key: \"$executeQueued\",\n    value: function $executeQueued() {\n      // New queued signals should be executed on next tick of the event loop\n      var queued = Signal.$queued;\n      Signal.$queued = [];\n\n      QmlWeb.QMLProperty.pushEvalStack();\n      for (var i in queued) {\n        Signal.$execute.apply(Signal, _toConsumableArray(queued[i]));\n      }\n      QmlWeb.QMLProperty.popEvalStack();\n    }\n  }]);\n\n  return Signal;\n}();\n\nSignal.$queued = [];\nSignal.AutoConnection = 0;\nSignal.DirectConnection = 1;\nSignal.QueuedConnection = 2;\nSignal.UniqueConnection = 128;\n\n\nQmlWeb.Signal = Signal;\n\nvar Qt = {\n  openUrlExternally: function openUrlExternally(url) {\n    var page = window.open(url, \"_blank\");\n    page.focus();\n  },\n  // Load file, parse and construct as Component (.qml)\n  createComponent: function createComponent(name) {\n    var engine = QmlWeb.engine;\n\n    var file = engine.$resolvePath(name);\n\n    // If \"name\" was a full URL, \"file\" will be equivalent to name and this\n    // will try and load the Component from the full URL, otherwise, this\n    // doubles as checking for the file in the current directory.\n    var tree = engine.loadComponent(file);\n\n    // If the Component is not found, and it is not a URL, look for \"name\" in\n    // this context's importSearchPaths\n    if (!tree) {\n      var nameIsUrl = engine.$parseURI(name) !== undefined;\n      if (!nameIsUrl) {\n        var moreDirs = engine.importSearchPaths(QmlWeb.executionContext.importContextId);\n        for (var i = 0; i < moreDirs.length; i++) {\n          file = \"\" + moreDirs[i] + name;\n          tree = engine.loadComponent(file);\n          if (tree) break;\n        }\n      }\n    }\n\n    if (!tree) {\n      return undefined;\n    }\n\n    var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    var component = new QMLComponent({\n      object: tree,\n      context: QmlWeb.executionContext\n    });\n    component.$basePath = engine.extractBasePath(file);\n    component.$imports = tree.$imports;\n    component.$file = file; // just for debugging\n\n    engine.loadImports(tree.$imports, component.$basePath, component.importContextId);\n\n    return component;\n  },\n\n  createQmlObject: function createQmlObject(src, parent, file) {\n    var tree = QmlWeb.parseQML(src, file);\n\n    // Create and initialize objects\n\n    var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n    var component = new QMLComponent({\n      object: tree,\n      parent: parent,\n      context: QmlWeb.executionContext\n    });\n\n    var engine = QmlWeb.engine;\n    engine.loadImports(tree.$imports, undefined, component.importContextId);\n\n    var resolvedFile = file || Qt.resolvedUrl(\"createQmlObject_function\");\n    component.$basePath = engine.extractBasePath(resolvedFile);\n    component.$imports = tree.$imports; // for later use\n    // not just for debugging, but for basepath too, see above\n    component.$file = resolvedFile;\n\n    var obj = component.createObject(parent);\n\n    var QMLOperationState = QmlWeb.QMLOperationState;\n    if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n      // We don't call those on first creation, as they will be called\n      // by the regular creation-procedures at the right time.\n      engine.$initializePropertyBindings();\n\n      engine.callCompletedSignals();\n    }\n\n    return obj;\n  },\n\n  // Returns url resolved relative to the URL of the caller.\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n  resolvedUrl: function resolvedUrl(url) {\n    return QmlWeb.qmlUrl(url);\n  },\n\n  // Basic QML types constructors\n  point: function point() {\n    for (var _len15 = arguments.length, args = Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      args[_key15] = arguments[_key15];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QPointF, [null].concat(args)))();\n  },\n  rect: function rect() {\n    for (var _len16 = arguments.length, args = Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n      args[_key16] = arguments[_key16];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QRectF, [null].concat(args)))();\n  },\n  size: function size() {\n    for (var _len17 = arguments.length, args = Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n      args[_key17] = arguments[_key17];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QSizeF, [null].concat(args)))();\n  },\n  vector2d: function vector2d() {\n    for (var _len18 = arguments.length, args = Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n      args[_key18] = arguments[_key18];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector2D, [null].concat(args)))();\n  },\n  vector3d: function vector3d() {\n    for (var _len19 = arguments.length, args = Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n      args[_key19] = arguments[_key19];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector3D, [null].concat(args)))();\n  },\n  vector4d: function vector4d() {\n    for (var _len20 = arguments.length, args = Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n      args[_key20] = arguments[_key20];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QVector4D, [null].concat(args)))();\n  },\n  quaternion: function quaternion() {\n    for (var _len21 = arguments.length, args = Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n      args[_key21] = arguments[_key21];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QQuaternion, [null].concat(args)))();\n  },\n  matrix4x4: function matrix4x4() {\n    for (var _len22 = arguments.length, args = Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n      args[_key22] = arguments[_key22];\n    }\n\n    return new (Function.prototype.bind.apply(QmlWeb.QMatrix4x4, [null].concat(args)))();\n  },\n\n  // Colors\n  rgba: function rgba() {\n    var _QmlWeb$QColor;\n\n    return (_QmlWeb$QColor = QmlWeb.QColor).rgba.apply(_QmlWeb$QColor, arguments);\n  },\n  hsla: function hsla() {\n    var _QmlWeb$QColor2;\n\n    return (_QmlWeb$QColor2 = QmlWeb.QColor).hsla.apply(_QmlWeb$QColor2, arguments);\n  },\n  hsva: function hsva() {\n    var _QmlWeb$QColor3;\n\n    return (_QmlWeb$QColor3 = QmlWeb.QColor).hsva.apply(_QmlWeb$QColor3, arguments);\n  },\n  colorEqual: function colorEqual() {\n    var _QmlWeb$QColor4;\n\n    return (_QmlWeb$QColor4 = QmlWeb.QColor).equal.apply(_QmlWeb$QColor4, arguments);\n  },\n  darker: function darker() {\n    var _QmlWeb$QColor5;\n\n    return (_QmlWeb$QColor5 = QmlWeb.QColor).darker.apply(_QmlWeb$QColor5, arguments);\n  },\n  lighter: function lighter() {\n    var _QmlWeb$QColor6;\n\n    return (_QmlWeb$QColor6 = QmlWeb.QColor).lighter.apply(_QmlWeb$QColor6, arguments);\n  },\n\n  include: function include(path) {\n    var engine = QmlWeb.engine;\n\n    var uri = engine.$resolvePath(path);\n\n    /* Handle recursive includes */\n    if (QmlWeb.executionContext.$qmlJsIncludes === undefined) {\n      QmlWeb.executionContext.$qmlJsIncludes = [];\n    }\n\n    if (QmlWeb.executionContext.$qmlJsIncludes.indexOf(uri) >= 0) {\n      return;\n    }\n\n    QmlWeb.executionContext.$qmlJsIncludes.push(uri);\n\n    var js = engine.loadJS(uri);\n\n    if (!js) {\n      console.error(\"Unable to load JavaScript module:\", uri, path);\n      return;\n    }\n\n    QmlWeb.importJavascriptInContext(js, QmlWeb.executionContext);\n  },\n\n\n  platform: {\n    os: \"qmlweb\"\n  },\n\n  // Buttons masks\n  LeftButton: 1,\n  RightButton: 2,\n  MiddleButton: 4,\n  // Modifiers masks\n  NoModifier: 0,\n  ShiftModifier: 1,\n  ControlModifier: 2,\n  AltModifier: 4,\n  MetaModifier: 8,\n  KeypadModifier: 16, // Note: Not available in web\n  // Layout directions\n  LeftToRight: 0,\n  RightToLeft: 1,\n  // Orientations\n  Vertical: 0,\n  Horizontal: 1,\n  // Keys\n  Key_Escape: 27,\n  Key_Tab: 9,\n  Key_Backtab: 245,\n  Key_Backspace: 8,\n  Key_Return: 13,\n  Key_Enter: 13,\n  Key_Insert: 45,\n  Key_Delete: 46,\n  Key_Pause: 19,\n  Key_Print: 42,\n  Key_SysReq: 0,\n  Key_Clear: 12,\n  Key_Home: 36,\n  Key_End: 35,\n  Key_Left: 37,\n  Key_Up: 38,\n  Key_Right: 39,\n  Key_Down: 40,\n  Key_PageUp: 33,\n  Key_PageDown: 34,\n  Key_Shift: 16,\n  Key_Control: 17,\n  Key_Meta: 91,\n  Key_Alt: 18,\n  Key_AltGr: 0,\n  Key_CapsLock: 20,\n  Key_NumLock: 144,\n  Key_ScrollLock: 145,\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117,\n  Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122,\n  Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127,\n  Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132,\n  Key_F22: 133, Key_F23: 134, Key_F24: 135,\n  Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0,\n  Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n  Key_Super_L: 0,\n  Key_Super_R: 0,\n  Key_Menu: 0,\n  Key_Hyper_L: 0,\n  Key_Hyper_R: 0,\n  Key_Help: 6,\n  Key_Direction_L: 0,\n  Key_Direction_R: 0,\n  Key_Space: 32,\n  Key_Any: 32,\n  Key_Exclam: 161,\n  Key_QuoteDbl: 162,\n  Key_NumberSign: 163,\n  Key_Dollar: 164,\n  Key_Percent: 165,\n  Key_Ampersant: 166,\n  Key_Apostrophe: 222,\n  Key_ParenLeft: 168,\n  Key_ParenRight: 169,\n  Key_Asterisk: 170,\n  Key_Plus: 171,\n  Key_Comma: 188,\n  Key_Minus: 173,\n  Key_Period: 190,\n  Key_Slash: 191,\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52,\n  Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n  Key_Colon: 58,\n  Key_Semicolon: 59,\n  Key_Less: 60,\n  Key_Equal: 61,\n  Key_Greater: 62,\n  Key_Question: 63,\n  Key_At: 64,\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71,\n  Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78,\n  Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85,\n  Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n  Key_BracketLeft: 219,\n  Key_Backslash: 220,\n  Key_BracketRight: 221,\n  Key_AsciiCircum: 160,\n  Key_Underscore: 167,\n  Key_QuoteLeft: 0,\n  Key_BraceLeft: 174,\n  Key_Bar: 172,\n  Key_BraceRight: 175,\n  Key_AsciiTilde: 176,\n  Key_Back: 0,\n  Key_Forward: 0,\n  Key_Stop: 0,\n  Key_VolumeDown: 182,\n  Key_VolumeUp: 183,\n  Key_VolumeMute: 181,\n  Key_multiply: 106,\n  Key_add: 107,\n  Key_substract: 109,\n  Key_divide: 111,\n  Key_News: 0,\n  Key_OfficeHome: 0,\n  Key_Option: 0,\n  Key_Paste: 0,\n  Key_Phone: 0,\n  Key_Calendar: 0,\n  Key_Reply: 0,\n  Key_Reload: 0,\n  Key_RotateWindows: 0,\n  Key_RotationPB: 0,\n  Key_RotationKB: 0,\n  Key_Save: 0,\n  Key_Send: 0,\n  Key_Spell: 0,\n  Key_SplitScreen: 0,\n  Key_Support: 0,\n  Key_TaskPane: 0,\n  Key_Terminal: 0,\n  Key_Tools: 0,\n  Key_Travel: 0,\n  Key_Video: 0,\n  Key_Word: 0,\n  Key_Xfer: 0,\n  Key_ZoomIn: 0,\n  Key_ZoomOut: 0,\n  Key_Away: 0,\n  Key_Messenger: 0,\n  Key_WebCam: 0,\n  Key_MailForward: 0,\n  Key_Pictures: 0,\n  Key_Music: 0,\n  Key_Battery: 0,\n  Key_Bluetooth: 0,\n  Key_WLAN: 0,\n  Key_UWB: 0,\n  Key_AudioForward: 0,\n  Key_AudioRepeat: 0,\n  Key_AudioRandomPlay: 0,\n  Key_Subtitle: 0,\n  Key_AudioCycleTrack: 0,\n  Key_Time: 0,\n  Key_Hibernate: 0,\n  Key_View: 0,\n  Key_TopMenu: 0,\n  Key_PowerDown: 0,\n  Key_Suspend: 0,\n  Key_ContrastAdjust: 0,\n  Key_MediaLast: 0,\n  Key_unknown: -1,\n  Key_Call: 0,\n  Key_Camera: 0,\n  Key_CameraFocus: 0,\n  Key_Context1: 0,\n  Key_Context2: 0,\n  Key_Context3: 0,\n  Key_Context4: 0,\n  Key_Flip: 0,\n  Key_Hangup: 0,\n  Key_No: 0,\n  Key_Select: 93,\n  Key_Yes: 0,\n  Key_ToggleCallHangup: 0,\n  Key_VoiceDial: 0,\n  Key_LastNumberRedial: 0,\n  Key_Execute: 43,\n  Key_Printer: 42,\n  Key_Play: 250,\n  Key_Sleep: 95,\n  Key_Zoom: 251,\n  Key_Cancel: 3,\n  // Align\n  AlignLeft: 0x0001,\n  AlignRight: 0x0002,\n  AlignHCenter: 0x0004,\n  AlignJustify: 0x0008,\n  AlignTop: 0x0020,\n  AlignBottom: 0x0040,\n  AlignVCenter: 0x0080,\n  AlignCenter: 0x0084,\n  AlignBaseline: 0x0100,\n  AlignAbsolute: 0x0010,\n  AlignLeading: 0x0001,\n  AlignTrailing: 0x0002,\n  AlignHorizontal_Mask: 0x001f,\n  AlignVertical_Mask: 0x01e0,\n  // Screen\n  PrimaryOrientation: 0,\n  PortraitOrientation: 1,\n  LandscapeOrientation: 2,\n  InvertedPortraitOrientation: 4,\n  InvertedLandscapeOrientation: 8,\n  // CursorShape\n  ArrowCursor: 0,\n  UpArrowCursor: 1,\n  CrossCursor: 2,\n  WaitCursor: 3,\n  IBeamCursor: 4,\n  SizeVerCursor: 5,\n  SizeHorCursor: 6,\n  SizeBDiagCursor: 7,\n  SizeFDiagCursor: 8,\n  SizeAllCursor: 9,\n  BlankCursor: 10,\n  SplitVCursor: 11,\n  SplitHCursor: 12,\n  PointingHandCursor: 13,\n  ForbiddenCursor: 14,\n  WhatsThisCursor: 15,\n  BusyCursor: 16,\n  OpenHandCursor: 17,\n  ClosedHandCursor: 18,\n  DragCopyCursor: 19,\n  DragMoveCursor: 20,\n  DragLinkCursor: 21,\n  LastCursor: 21, //DragLinkCursor,\n  BitmapCursor: 24,\n  CustomCursor: 25,\n  // ScrollBar Policy\n  ScrollBarAsNeeded: 0,\n  ScrollBarAlwaysOff: 1,\n  ScrollBarAlwaysOn: 2\n};\n\nQmlWeb.Qt = Qt;\n\nvar QMLBinding = function () {\n  /**\r\n   * Create QML binding.\r\n   * @param {Variant} val Sourcecode or function representing the binding\r\n   * @param {Array} tree Parser tree of the binding\r\n   * @return {Object} Object representing the binding\r\n   */\n  function QMLBinding(val, tree) {\n    _classCallCheck(this, QMLBinding);\n\n    // this.isFunction states whether the binding is a simple js statement or a\n    // function containing a return statement. We decide this on whether it is a\n    // code block or not. If it is, we require a return statement. If it is a\n    // code block it could though also be a object definition, so we need to\n    // check that as well (it is, if the content is labels).\n    this.isFunction = tree && tree[0] === \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\n    this.src = val;\n    this.compiled = false;\n  }\n\n  _createClass(QMLBinding, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        src: this.src,\n        deps: JSON.stringify(this.deps),\n        tree: JSON.stringify(this.tree)\n      };\n    }\n  }, {\n    key: \"eval\",\n    value: function _eval(object, context, basePath) {\n      QmlWeb.executionContext = context;\n      if (basePath) {\n        QmlWeb.engine.$basePath = basePath;\n      }\n      // .call is needed for `this` support\n      return this.impl.call(object, object, context);\n    }\n\n    /**\r\n     * Compile binding. Afterwards you may call binding.eval to evaluate.\r\n     */\n\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      this.src = this.src.trim();\n      this.impl = QMLBinding.bindSrc(this.src, this.isFunction);\n      this.compiled = true;\n    }\n  }], [{\n    key: \"bindSrc\",\n    value: function bindSrc(src, isFunction) {\n      return new Function(\"__executionObject\", \"__executionContext\", \"\\n      with(QmlWeb) with(__executionContext) with(__executionObject) {\\n        \" + (isFunction ? \"\" : \"return\") + \" \" + src + \"\\n      }\\n    \");\n    }\n  }]);\n\n  return QMLBinding;\n}();\n\nQmlWeb.QMLBinding = QMLBinding;\n\nfunction QMLBoolean(val) {\n  return !!val;\n}\nQMLBoolean.plainType = true;\nQmlWeb.qmlBoolean = QMLBoolean;\n\n// There can only be one running QMLEngine.\n// This variable points to the currently running engine.\nQmlWeb.engine = null;\n\nQmlWeb.useShadowDom = true;\n\nvar geometryProperties = [\"width\", \"height\", \"fill\", \"x\", \"y\", \"left\", \"right\", \"top\", \"bottom\"];\n\n// QML engine. EXPORTED.\n\nvar QMLEngine = function () {\n  function QMLEngine(element) {\n    var _this13 = this;\n\n    _classCallCheck(this, QMLEngine);\n\n    //----------Public Members----------\n\n    this.fps = 60;\n    // Math.floor, causes bugs to timing?\n    this.$interval = Math.floor(1000 / this.fps);\n    this.dom = element || document.body;\n\n    // Target for the DOM children\n    this.domTarget = this.dom;\n    if (QmlWeb.useShadowDom && this.dom.attachShadow) {\n      this.domTarget = this.dom.attachShadow({ mode: \"open\" });\n    }\n\n    // Cached component trees (post-QmlWeb.convertToEngine)\n    this.components = {};\n\n    // Cached parsed JS files (post-QmlWeb.jsparse)\n    this.js = {};\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n    // Module import paths overrides\n    this.userAddedModulePaths = {};\n\n    // Stores data for setImportPathList(), importPathList(), and addImportPath\n    this.userAddedImportPaths = [];\n\n    //----------Private Members---------\n\n    // Ticker resource id and ticker callbacks\n    this._tickers = [];\n    this._lastTick = Date.now();\n\n    // Callbacks for stopping or starting the engine\n    this._whenStop = [];\n    this._whenStart = [];\n\n    // Keyboard management\n    this.$initKeyboard();\n\n    //----------Construct----------\n\n    // No QML stuff should stand out the root element\n    this.dom.style.overflow = \"hidden\";\n\n    // Needed to make absolute positioning work\n    if (!this.dom.style.position) {\n      var style = window.getComputedStyle(this.dom);\n      if (style.getPropertyValue(\"position\") === \"static\") {\n        this.dom.style.position = \"relative\";\n        this.dom.style.top = \"0\";\n        this.dom.style.left = \"0\";\n      }\n    }\n\n    window.addEventListener(\"resize\", function () {\n      return _this13.updateGeometry();\n    });\n  }\n\n  //---------- Public Methods ----------\n\n  _createClass(QMLEngine, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      // we have to call `this.implicitHeight =` and `this.implicitWidth =`\n      // each time the root element changes it's geometry\n      // to reposition child elements of qml scene\n      var width = void 0;\n      var height = void 0;\n      if (this.dom === document.body) {\n        width = window.innerWidth;\n        height = window.innerHeight;\n      } else {\n        var style = window.getComputedStyle(this.dom);\n        width = parseFloat(style.getPropertyValue(\"width\"), 10);\n        height = parseFloat(style.getPropertyValue(\"height\"), 10);\n      }\n      if (width) {\n        this.rootObject.width = width;\n      }\n      if (height) {\n        this.rootObject.height = height;\n      }\n    }\n\n    // Start the engine\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      QmlWeb.engine = this;\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      if (this.operationState !== QMLOperationState.Running) {\n        this.operationState = QMLOperationState.Running;\n        this._tickerId = setInterval(this._tick.bind(this), this.$interval);\n        this._whenStart.forEach(function (callback) {\n          return callback();\n        });\n      }\n    }\n\n    // Stop the engine\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      if (this.operationState === QMLOperationState.Running) {\n        clearInterval(this._tickerId);\n        this.operationState = QMLOperationState.Idle;\n        this._whenStop.forEach(function (callback) {\n          return callback();\n        });\n      }\n    }\n\n    // eslint-disable-next-line max-len\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\r\n     *\r\n     * Removes dot segments in given path component, as described in\r\n     * RFC 3986, section 5.2.4.\r\n     *\r\n     * @param {string} path A non-empty path component.\r\n     * @return {string} Path component with removed dot segments.\r\n     */\n\n  }, {\n    key: \"removeDotSegments\",\n    value: function removeDotSegments(path) {\n      // path.startsWith(\"/\") is not supported in some browsers\n      var leadingSlash = path && path[0] === \"/\";\n      var segments = path.split(\"/\");\n      var out = [];\n\n      for (var pos = 0; pos < segments.length;) {\n        var segment = segments[pos++];\n\n        if (segment === \".\") {\n          if (leadingSlash && pos === segments.length) {\n            out.push(\"\");\n          }\n        } else if (segment === \"..\") {\n          if (out.length > 1 || out.length === 1 && out[0] !== \"\") {\n            out.pop();\n          }\n          if (leadingSlash && pos === segments.length) {\n            out.push(\"\");\n          }\n        } else {\n          out.push(segment);\n          leadingSlash = true;\n        }\n      }\n\n      return out.join(\"/\");\n    }\n  }, {\n    key: \"extractBasePath\",\n    value: function extractBasePath(file) {\n      // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n      var basePath = file.split(/[/\\\\]/);\n      basePath[basePath.length - 1] = \"\";\n      return basePath.join(\"/\");\n    }\n  }, {\n    key: \"extractFileName\",\n    value: function extractFileName(file) {\n      return file.split(/[/\\\\]/).pop();\n    }\n\n    // Load file, parse and construct (.qml or .qml.js)\n\n  }, {\n    key: \"loadFile\",\n    value: function loadFile(file) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      // Create an anchor element to get the absolute path from the DOM\n      if (!this.$basePathA) {\n        this.$basePathA = document.createElement(\"a\");\n      }\n      this.$basePathA.href = this.extractBasePath(file);\n      this.$basePath = this.$basePathA.href;\n      var fileName = this.extractFileName(file);\n      var tree = this.loadComponent(this.$resolvePath(fileName));\n      return this.loadQMLTree(tree, parentComponent, file);\n    }\n\n    // parse and construct qml\n    // file is not required; only for debug purposes\n    // This function is only used by the QmlWeb tests\n\n  }, {\n    key: \"loadQML\",\n    value: function loadQML(src) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      return this.loadQMLTree(QmlWeb.parseQML(src, file), parentComponent, file);\n    }\n  }, {\n    key: \"loadQMLTree\",\n    value: function loadQMLTree(tree) {\n      var parentComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      QmlWeb.engine = this;\n\n      // Create and initialize objects\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var component = new QMLComponent({\n        object: tree,\n        parent: parentComponent\n      });\n\n      this.loadImports(tree.$imports, undefined, component.importContextId);\n      component.$basePath = this.$basePath;\n      component.$imports = tree.$imports; // for later use\n      component.$file = file; // just for debugging\n\n      this.rootObject = component.$createObject(parentComponent);\n      if (this.rootObject.dom) {\n        this.domTarget.appendChild(this.rootObject.dom);\n      }\n      this.$initializePropertyBindings();\n\n      this.start();\n\n      this.updateGeometry();\n\n      this.callCompletedSignals();\n\n      return component;\n    }\n  }, {\n    key: \"rootContext\",\n    value: function rootContext() {\n      return this.rootObject.$context;\n    }\n\n    // next 3 methods used in Qt.createComponent for qml files lookup\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n  }, {\n    key: \"addImportPath\",\n    value: function addImportPath(dirpath) {\n      this.userAddedImportPaths.push(dirpath);\n    }\n\n    /* Add this dirpath to be checked for components. This is the result of\r\n     * something like:\r\n     *\r\n     * import \"SomeDir/AnotherDirectory\"\r\n     *\r\n     * The importContextId ensures it is only accessible from the file in which\r\n     * it was imported. */\n\n  }, {\n    key: \"addComponentImportPath\",\n    value: function addComponentImportPath(importContextId, dirpath, qualifier) {\n      if (!this.componentImportPaths) {\n        this.componentImportPaths = {};\n      }\n      if (!this.componentImportPaths[importContextId]) {\n        this.componentImportPaths[importContextId] = {};\n      }\n\n      var paths = this.componentImportPaths[importContextId];\n\n      if (qualifier) {\n        if (!paths.qualified) {\n          paths.qualified = {};\n        }\n        paths.qualified[qualifier] = dirpath;\n      } else {\n        if (!paths.unqualified) {\n          paths.unqualified = [];\n        }\n        paths.unqualified.push(dirpath);\n      }\n    }\n  }, {\n    key: \"importSearchPaths\",\n    value: function importSearchPaths(importContextId) {\n      if (!this.componentImportPaths) {\n        return [];\n      }\n      var paths = this.componentImportPaths[importContextId];\n      if (!paths) {\n        return [];\n      }\n      return paths.unqualified || [];\n    }\n  }, {\n    key: \"qualifiedImportPath\",\n    value: function qualifiedImportPath(importContextId, qualifier) {\n      if (!this.componentImportPaths) {\n        return \"\";\n      }\n      var paths = this.componentImportPaths[importContextId];\n      if (!paths || !paths.qualified) {\n        return \"\";\n      }\n      return paths.qualified[qualifier] || \"\";\n    }\n  }, {\n    key: \"setImportPathList\",\n    value: function setImportPathList(arrayOfDirs) {\n      this.userAddedImportPaths = arrayOfDirs;\n    }\n  }, {\n    key: \"importPathList\",\n    value: function importPathList() {\n      return this.userAddedImportPaths;\n    }\n\n    // `addModulePath` defines conrete path for module lookup\n    // e.g. addModulePath(\"QtQuick.Controls\", \"http://example.com/controls\")\n    // will force system to `import QtQuick.Controls` module from\n    // `http://example.com/controls/qmldir`\n\n  }, {\n    key: \"addModulePath\",\n    value: function addModulePath(moduleName, dirPath) {\n      // Keep the mapping. It will be used in loadImports() function.\n      // Remove trailing slash as it required for `readQmlDir`.\n      this.userAddedModulePaths[moduleName] = dirPath.replace(/\\/$/, \"\");\n    }\n  }, {\n    key: \"registerProperty\",\n    value: function registerProperty(obj, propName) {\n      var dependantProperties = [];\n      var value = obj[propName];\n\n      var getter = function getter() {\n        var QMLProperty = QmlWeb.QMLProperty;\n        if (QMLProperty.evaluatingProperty && dependantProperties.indexOf(QMLProperty.evaluatingProperty) === -1) {\n          dependantProperties.push(QMLProperty.evaluatingProperty);\n        }\n        return value;\n      };\n\n      var setter = function setter(newVal) {\n        value = newVal;\n        for (var i in dependantProperties) {\n          dependantProperties[i].update();\n        }\n      };\n\n      QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n    }\n  }, {\n    key: \"loadImports\",\n    value: function loadImports(importsArray) {\n      var currentFileDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;\n      var importContextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n\n      if (!this.qmldirsContents) {\n        this.qmldirsContents = {}; // cache\n\n        // putting initial keys in qmldirsContents - is a hack. We should find a\n        // way to explain to qmlweb, is this built-in module or qmldir-style\n        // module.\n        for (var module in QmlWeb.modules) {\n          if (module !== \"Main\") {\n            this.qmldirsContents[module] = {};\n          }\n        }\n      }\n\n      if (!this.qmldirs) {\n        this.qmldirs = {}; // resulting components lookup table\n      }\n\n      if (!importsArray || importsArray.length === 0) {\n        return;\n      }\n\n      for (var i = 0; i < importsArray.length; i++) {\n        this.loadImport(importsArray[i], currentFileDir, importContextId);\n      }\n    }\n  }, {\n    key: \"loadImport\",\n    value: function loadImport(entry, currentFileDir, importContextId) {\n      var name = entry[1];\n\n      // is it url to remote resource\n      var nameIsUrl = name.indexOf(\"//\") === 0 || name.indexOf(\"://\") >= 0;\n      // is it a module name, e.g. QtQuick, QtQuick.Controls, etc\n      var nameIsQualifiedModuleName = entry[4];\n      // is it a js file\n      var nameIsJs = name.slice(-3) === \".js\";\n      // local [relative] dir\n      var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl && !nameIsJs;\n\n      if (nameIsDir) {\n        name = this.$resolvePath(name, currentFileDir);\n        if (name[name.length - 1] === \"/\") {\n          // remove trailing slash as it required for `readQmlDir`\n          name = name.substr(0, name.length - 1);\n        }\n      }\n\n      var content = this.qmldirsContents[name];\n      // check if we have already loaded that qmldir file\n      if (!content) {\n        if (nameIsQualifiedModuleName && this.userAddedModulePaths[name]) {\n          // 1. we have qualified module and user had configured path for that\n          // module with this.addModulePath\n          content = QmlWeb.readQmlDir(this.userAddedModulePaths[name]);\n        } else if (nameIsUrl || nameIsDir) {\n          // 2. direct load\n          // nameIsUrl => url do not need dirs\n          // nameIsDir => already computed full path above\n          content = QmlWeb.readQmlDir(name);\n        } else if (nameIsJs) {\n          // 3. Js file, don't need qmldir\n        } else {\n          // 4. qt-style lookup for qualified module\n          var probableDirs = [currentFileDir].concat(this.importPathList());\n          var diredName = name.replace(/\\./g, \"/\");\n\n          for (var k = 0; k < probableDirs.length; k++) {\n            var file = probableDirs[k] + diredName;\n            content = QmlWeb.readQmlDir(file);\n            if (content) {\n              break;\n            }\n          }\n        }\n        this.qmldirsContents[name] = content;\n      }\n\n      /* If there is no qmldir, add these directories to the list of places to\r\n        * search for components (within this import scope). \"noqmldir\" is\r\n        * inserted into the qmldir cache to avoid future attempts at fetching\r\n        * the qmldir file, but we always need to the call to\r\n        * \"addComponentImportPath\" for these sorts of directories. */\n      if (!content || content === \"noqmldir\") {\n        if (nameIsDir) {\n          if (entry[3]) {\n            /* Use entry[1] directly, as we don't want to include the\r\n              * basePath, otherwise it gets prepended twice in\r\n              * createComponent. */\n            this.addComponentImportPath(importContextId, entry[1] + \"/\", entry[3]);\n          } else {\n            this.addComponentImportPath(importContextId, name + \"/\");\n          }\n        }\n\n        this.qmldirsContents[name] = \"noqmldir\";\n        return;\n      }\n\n      // copy founded externals to global var\n      // TODO actually we have to copy it to current component\n      for (var attrname in content.externals) {\n        this.qmldirs[attrname] = content.externals[attrname];\n      }\n\n      // keep already loaded qmldir files\n      this.qmldirsContents[name] = content;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return {\n        width: this.rootObject.getWidth(),\n        height: this.rootObject.getHeight()\n      };\n    }\n  }, {\n    key: \"focusedElement\",\n    value: function focusedElement() {\n      return this.rootContext().activeFocus;\n    }\n\n    //---------- Private Methods ----------\n\n  }, {\n    key: \"$initKeyboard\",\n    value: function $initKeyboard() {\n      var _this14 = this;\n\n      document.onkeypress = function (e) {\n        var focusedElement = _this14.focusedElement();\n        var event = QmlWeb.eventToKeyboard(e || window.event);\n        var eventName = QmlWeb.keyboardSignals[event.key];\n\n        while (focusedElement && !event.accepted) {\n          var backup = focusedElement.$context.event;\n          focusedElement.$context.event = event;\n          focusedElement.Keys.pressed(event);\n          if (eventName) {\n            focusedElement.Keys[eventName](event);\n          }\n          focusedElement.$context.event = backup;\n          if (event.accepted) {\n            e.preventDefault();\n          } else {\n            focusedElement = focusedElement.$parent;\n          }\n        }\n      };\n\n      document.onkeyup = function (e) {\n        var focusedElement = _this14.focusedElement();\n        var event = QmlWeb.eventToKeyboard(e || window.event);\n\n        while (focusedElement && !event.accepted) {\n          var backup = focusedElement.$context.event;\n          focusedElement.$context.event = event;\n          focusedElement.Keys.released(event);\n          focusedElement.$context.event = backup;\n          if (event.accepted) {\n            e.preventDefault();\n          } else {\n            focusedElement = focusedElement.$parent;\n          }\n        }\n      };\n    }\n  }, {\n    key: \"_tick\",\n    value: function _tick() {\n      var now = Date.now();\n      var elapsed = now - this._lastTick;\n      this._lastTick = now;\n      this._tickers.forEach(function (ticker) {\n        return ticker(now, elapsed);\n      });\n    }\n\n    // Load resolved file, parse and construct as Component (.qml)\n\n  }, {\n    key: \"loadComponent\",\n    value: function loadComponent(file) {\n      if (file in this.components) {\n        return this.components[file];\n      }\n\n      var uri = this.$parseURI(file);\n      if (!uri) {\n        return undefined;\n      }\n\n      var tree = void 0;\n      if (uri.scheme === \"qrc://\") {\n        tree = QmlWeb.qrc[uri.path];\n        if (!tree) {\n          return undefined;\n        }\n        // QmlWeb.qrc contains pre-parsed Component objects, but they still need\n        // convertToEngine called on them.\n        tree = QmlWeb.convertToEngine(tree);\n      } else {\n        var src = QmlWeb.getUrlContents(file, true);\n        if (!src) {\n          console.error(\"QMLEngine.loadComponent: Failed to load:\", file);\n          return undefined;\n        }\n\n        console.log(\"QMLEngine.loadComponent: Loading file:\", file);\n        tree = QmlWeb.parseQML(src, file);\n      }\n\n      if (!tree) {\n        return undefined;\n      }\n\n      if (tree.$children.length !== 1) {\n        console.error(\"QMLEngine.loadComponent: Failed to load:\", file, \": A QML component must only contain one root element!\");\n        return undefined;\n      }\n\n      tree.$file = file;\n      this.components[file] = tree;\n      return tree;\n    }\n\n    // Load resolved file and parse as JavaScript\n\n  }, {\n    key: \"loadJS\",\n    value: function loadJS(file) {\n      if (file in this.js) {\n        return this.js[file];\n      }\n\n      var uri = this.$parseURI(file);\n      if (!uri) {\n        return undefined;\n      }\n\n      var jsData = void 0;\n      if (uri.scheme === \"qrc://\") {\n        jsData = QmlWeb.qrc[uri.path];\n      } else {\n        QmlWeb.loadParser();\n        jsData = QmlWeb.jsparse(QmlWeb.getUrlContents(file));\n      }\n\n      if (!jsData) {\n        return undefined;\n      }\n\n      // Remove any \".pragma\" statements, as they are not valid JavaScript\n      jsData.source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\n\n      var contextSetter = new Function(\"$context\", \"\\n      with(QmlWeb) with ($context) {\\n        \" + jsData.source + \"\\n      }\\n      \" + jsData.exports.map(function (sym) {\n        return \"$context.\" + sym + \" = \" + sym + \";\";\n      }).join(\"\") + \"\\n    \");\n\n      this.js[file] = contextSetter;\n\n      return contextSetter;\n    }\n  }, {\n    key: \"$registerStart\",\n    value: function $registerStart(f) {\n      this._whenStart.push(f);\n    }\n  }, {\n    key: \"$registerStop\",\n    value: function $registerStop(f) {\n      this._whenStop.push(f);\n    }\n  }, {\n    key: \"$addTicker\",\n    value: function $addTicker(t) {\n      this._tickers.push(t);\n    }\n  }, {\n    key: \"$removeTicker\",\n    value: function $removeTicker(t) {\n      var index = this._tickers.indexOf(t);\n      if (index !== -1) {\n        this._tickers.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"$initializePropertyBindings\",\n    value: function $initializePropertyBindings() {\n      // Initialize property bindings\n      // we use `while`, because $initializePropertyBindings may be called\n      // recursive (because of Loader and/or createQmlObject )\n      while (this.bindedProperties.length > 0) {\n        var property = this.bindedProperties.shift();\n\n        if (!property.binding) {\n          // Probably, the binding was overwritten by an explicit value. Ignore.\n          continue;\n        }\n\n        if (property.needsUpdate) {\n          property.update();\n        } else if (geometryProperties.indexOf(property.name) >= 0) {\n          // It is possible that bindings with these names was already evaluated\n          // during eval of other bindings but in that case $updateHGeometry and\n          // $updateVGeometry could be blocked during their eval.\n          // So we call them explicitly, just in case.\n          var obj = property.obj,\n              changed = property.changed;\n\n          if (obj.$updateHGeometry && changed.isConnected(obj, obj.$updateHGeometry)) {\n            obj.$updateHGeometry(property.val, property.val, property.name);\n          }\n          if (obj.$updateVGeometry && changed.isConnected(obj, obj.$updateVGeometry)) {\n            obj.$updateVGeometry(property.val, property.val, property.name);\n          }\n        }\n      }\n\n      this.$initializeAliasSignals();\n    }\n\n    // This parses the full URL into scheme, authority and path\n\n  }, {\n    key: \"$parseURI\",\n    value: function $parseURI(uri) {\n      var match = uri.match(/^([^/]*?:\\/\\/)(.*?)(\\/.*)$/);\n      if (match) {\n        return {\n          scheme: match[1],\n          authority: match[2],\n          path: match[3]\n        };\n      }\n      return undefined;\n    }\n\n    // Return a path to load the file\n\n  }, {\n    key: \"$resolvePath\",\n    value: function $resolvePath(file) {\n      var basePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.$basePath;\n\n      // probably, replace :// with :/ ?\n      if (!file || file.indexOf(\"://\") !== -1) {\n        return file;\n      }\n\n      var schemes = [\"data:\", \"blob:\", \"about:\"];\n      for (var i = 0; i < schemes.length; i++) {\n        if (file.lastIndexOf(schemes[i], 0) === 0) {\n          return file;\n        }\n      }\n\n      var basePathURI = this.$parseURI(basePath);\n      if (!basePathURI) {\n        return file;\n      }\n\n      var path = basePathURI.path;\n      if (file.indexOf(\"/\") === 0) {\n        path = file;\n      } else {\n        path = \"\" + path + file;\n      }\n\n      // Remove duplicate slashes and dot segments in the path\n      path = this.removeDotSegments(path.replace(/([^:]\\/)\\/+/g, \"$1\"));\n\n      return \"\" + basePathURI.scheme + basePathURI.authority + path;\n    }\n\n    // Return a DOM-valid path to load the image (fileURL is an already-resolved\n    // URL)\n\n  }, {\n    key: \"$resolveImageURL\",\n    value: function $resolveImageURL(fileURL) {\n      var uri = this.$parseURI(fileURL);\n      // If we are within the resource system, look up a \"real\" path that can be\n      // used by the DOM. If not found, return the path itself without the\n      // \"qrc://\" scheme.\n      if (uri && uri.scheme === \"qrc://\") {\n        return QmlWeb.qrc[uri.path] || uri.path;\n      }\n\n      // Something we can't parse, just pass it through\n      return fileURL;\n    }\n  }, {\n    key: \"$initializeAliasSignals\",\n    value: function $initializeAliasSignals() {\n      // Perform pending operations. Now we use it only to init alias's \"changed\"\n      // handlers, that's why we have such strange function name.\n      while (this.pendingOperations.length > 0) {\n        var op = this.pendingOperations.shift();\n        op[0](op[1], op[2], op[3]);\n      }\n      this.pendingOperations = [];\n    }\n  }, {\n    key: \"callCompletedSignals\",\n    value: function callCompletedSignals() {\n      // the while loop is better than for..in loop, because completedSignals\n      // array might change dynamically when some completed signal handlers will\n      // create objects dynamically via createQmlObject or Loader\n      while (this.completedSignals.length > 0) {\n        var handler = this.completedSignals.shift();\n        handler();\n      }\n    }\n  }]);\n\n  return QMLEngine;\n}();\n\nQmlWeb.QMLEngine = QMLEngine;\n\nfunction QMLInteger(val) {\n  return val | 0;\n}\nQMLInteger.plainType = true;\nQmlWeb.qmlInteger = QMLInteger;\n\nfunction QMLList(meta) {\n  var list = [];\n  if (meta.object instanceof Array) {\n    for (var i in meta.object) {\n      list.push(QmlWeb.construct({\n        object: meta.object[i],\n        parent: meta.parent,\n        context: meta.context\n      }));\n    }\n  } else if (meta.object instanceof QmlWeb.QMLMetaElement) {\n    list.push(QmlWeb.construct({\n      object: meta.object,\n      parent: meta.parent,\n      context: meta.context\n    }));\n  }\n\n  return list;\n}\nQMLList.plainType = true;\nQmlWeb.qmlList = QMLList;\n\nfunction QMLNumber(val) {\n  return +val;\n}\nQMLNumber.plainType = true;\nQmlWeb.qmlNumber = QMLNumber;\n\nvar QMLOperationState = {\n  Idle: 1,\n  Init: 2,\n  Running: 3\n};\n\nQmlWeb.QMLOperationState = QMLOperationState;\n\nvar QMLProperty = function () {\n  function QMLProperty(type, obj, name) {\n    _classCallCheck(this, QMLProperty);\n\n    this.obj = obj;\n    this.name = name;\n    this.changed = QmlWeb.Signal.signal([], { obj: obj });\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n    this.needsUpdate = true;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this\n    // object.\n    this.$tidyupList = [];\n  }\n\n  // Called by update and set to actually set this.val, performing any type\n  // conversion required.\n\n\n  _createClass(QMLProperty, [{\n    key: \"$setVal\",\n    value: function $setVal(val, componentScope) {\n      var _this15 = this;\n\n      var constructors = QmlWeb.constructors;\n      if (constructors[this.type] === QmlWeb.qmlList) {\n        this.val = QmlWeb.qmlList({\n          object: val,\n          parent: this.obj,\n          context: componentScope\n        });\n      } else if (val instanceof QmlWeb.QMLMetaElement) {\n        var _QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n        if (constructors[val.$class] === _QMLComponent || constructors[this.type] === _QMLComponent) {\n          this.val = new _QMLComponent({\n            object: val,\n            parent: this.obj,\n            context: componentScope\n          });\n          /* $basePath must be set here so that Components that are assigned to\r\n           * properties (e.g. Repeater delegates) can properly resolve child\r\n           * Components that live in the same directory in\r\n           * Component.createObject. */\n          this.val.$basePath = componentScope.$basePath;\n        } else {\n          this.val = QmlWeb.construct({\n            object: val,\n            parent: this.obj,\n            context: componentScope\n          });\n        }\n      } else if (!constructors[this.type]) {\n        this.val = val;\n      } else if (constructors[this.type].requireParent) {\n        this.val = new constructors[this.type](this.obj, val);\n      } else if (val === undefined && constructors[this.type].nonNullableType) {\n        this.val = new constructors[this.type]();\n      } else if (constructors[this.type].requireConstructor) {\n        this.val = new constructors[this.type](val);\n      } else if (val instanceof Object || val === undefined || val === null) {\n        this.val = val;\n      } else if (constructors[this.type].plainType) {\n        this.val = constructors[this.type](val);\n      } else {\n        this.val = new constructors[this.type](val);\n      }\n      if (this.val && this.val.$changed) {\n        this.val.$changed.connect(function () {\n          var oldVal = _this15.val; // TODO\n          _this15.changed(_this15.val, oldVal, _this15.name);\n        });\n      } else if (this.val && this.val.$properties) {\n        Object.keys(this.val.$properties).forEach(function (pname) {\n          var prop = _this15.val.$properties[pname];\n          if (!prop || !prop.connect) return;\n          // TODO: oldVal\n          prop.connect(function () {\n            return _this15.changed(_this15.val, _this15.val, _this15.name);\n          });\n        });\n      }\n    }\n\n    // Updater recalculates the value of a property if one of the dependencies\n    // changed\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.needsUpdate = false;\n\n      if (!this.binding) {\n        return;\n      }\n\n      var oldVal = this.val;\n\n      try {\n        QMLProperty.pushEvaluatingProperty(this);\n        if (!this.binding.compiled) {\n          this.binding.compile();\n        }\n        this.$setVal(this.binding.eval(this.objectScope, this.componentScope, this.componentScopeBasePath), this.componentScope);\n      } catch (e) {\n        console.log(\"QMLProperty.update binding error:\", e, Function.prototype.toString.call(this.binding.eval));\n      } finally {\n        QMLProperty.popEvaluatingProperty();\n      }\n\n      if (this.animation) {\n        this.animation.$actions = [{\n          target: this.animation.target || this.obj,\n          property: this.animation.property || this.name,\n          from: this.animation.from || oldVal,\n          to: this.animation.to || this.val\n        }];\n        this.animation.restart();\n      }\n\n      if (this.val !== oldVal) {\n        this.changed(this.val, oldVal, this.name);\n      }\n    }\n\n    // Define getter\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      //if (this.needsUpdate && !QMLProperty.evaluatingPropertyPaused) {\n      if (this.needsUpdate && QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n        this.update();\n      }\n\n      // If this call to the getter is due to a property that is dependant on this\n      // one, we need it to take track of changes\n      if (QMLProperty.evaluatingProperty) {\n        //console.log(this,QMLProperty.evaluatingPropertyStack.slice(0),this.val);\n        this.changed.connect(QMLProperty.evaluatingProperty, QMLProperty.prototype.update, QmlWeb.Signal.UniqueConnection);\n      }\n\n      return this.val;\n    }\n    // Define setter\n\n  }, {\n    key: \"set\",\n    value: function set(newVal, reason, objectScope, componentScope) {\n      var oldVal = this.val;\n\n      var val = newVal;\n      if (val instanceof QmlWeb.QMLBinding) {\n        if (!objectScope || !componentScope) {\n          throw new Error(\"Internal error: binding assigned without scope\");\n        }\n        this.binding = val;\n        this.objectScope = objectScope;\n        this.componentScope = componentScope;\n        this.componentScopeBasePath = componentScope.$basePath;\n\n        if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n          if (!val.compiled) {\n            val.compile();\n          }\n          try {\n            QMLProperty.pushEvaluatingProperty(this);\n            this.needsUpdate = false;\n            val = this.binding.eval(objectScope, componentScope, this.componentScopeBasePath);\n          } finally {\n            QMLProperty.popEvaluatingProperty();\n          }\n        } else {\n          QmlWeb.engine.bindedProperties.push(this);\n          return;\n        }\n      } else {\n        if (reason !== QMLProperty.ReasonAnimation) {\n          this.binding = null;\n        }\n        if (val instanceof Array) {\n          val = val.slice(); // Copies the array\n        }\n      }\n\n      if (reason === QMLProperty.ReasonInit && typeof val === \"undefined\") {\n        if (QMLProperty.typeInitialValues.hasOwnProperty(this.type)) {\n          val = QMLProperty.typeInitialValues[this.type];\n        }\n      }\n\n      this.$setVal(val, componentScope);\n\n      if (this.val !== oldVal) {\n        if (this.animation && reason === QMLProperty.ReasonUser) {\n          this.animation.running = false;\n          this.animation.$actions = [{\n            target: this.animation.target || this.obj,\n            property: this.animation.property || this.name,\n            from: this.animation.from || oldVal,\n            to: this.animation.to || this.val\n          }];\n          this.animation.running = true;\n        }\n        if (this.obj.$syncPropertyToRemote instanceof Function && reason === QMLProperty.ReasonUser) {\n          // is a remote object from e.g. a QWebChannel\n          this.obj.$syncPropertyToRemote(this.name, val);\n        } else {\n          this.changed(this.val, oldVal, this.name);\n        }\n      }\n    }\n  }], [{\n    key: \"pushEvalStack\",\n    value: function pushEvalStack() {\n      QMLProperty.evaluatingPropertyStackOfStacks.push(QMLProperty.evaluatingPropertyStack);\n      QMLProperty.evaluatingPropertyStack = [];\n      QMLProperty.evaluatingProperty = undefined;\n      //  console.log(\"evaluatingProperty=>undefined due to push stck \");\n    }\n  }, {\n    key: \"popEvalStack\",\n    value: function popEvalStack() {\n      QMLProperty.evaluatingPropertyStack = QMLProperty.evaluatingPropertyStackOfStacks.pop() || [];\n      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];\n    }\n  }, {\n    key: \"pushEvaluatingProperty\",\n    value: function pushEvaluatingProperty(prop) {\n      // TODO say warnings if already on stack. This means binding loop.\n      // BTW actually we do not loop because needsUpdate flag is reset before\n      // entering update again.\n      if (QMLProperty.evaluatingPropertyStack.indexOf(prop) >= 0) {\n        console.error(\"Property binding loop detected for property\", prop.name, [prop].slice(0));\n      }\n      QMLProperty.evaluatingProperty = prop;\n      QMLProperty.evaluatingPropertyStack.push(prop); //keep stack of props\n    }\n  }, {\n    key: \"popEvaluatingProperty\",\n    value: function popEvaluatingProperty() {\n      QMLProperty.evaluatingPropertyStack.pop();\n      QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[QMLProperty.evaluatingPropertyStack.length - 1];\n    }\n  }]);\n\n  return QMLProperty;\n}();\n\n// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\n\n\nQMLProperty.evaluatingProperty = undefined;\nQMLProperty.evaluatingPropertyPaused = false;\nQMLProperty.evaluatingPropertyStack = [];\nQMLProperty.evaluatingPropertyStackOfStacks = [];\n\nQMLProperty.typeInitialValues = {\n  int: 0,\n  real: 0,\n  double: 0,\n  string: \"\",\n  bool: false,\n  list: [],\n  enum: 0,\n  url: \"\"\n};\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\nQmlWeb.QMLProperty = QMLProperty;\n\nfunction QMLString(val) {\n  return \"\" + val;\n}\nQMLString.plainType = true;\nQmlWeb.qmlString = QMLString;\n\nfunction QMLUrl(val) {\n  return QmlWeb.engine.$resolvePath(\"\" + val);\n}\nQMLUrl.plainType = true;\nQmlWeb.qmlUrl = QMLUrl;\n\nfunction QMLVariant(val) {\n  return val;\n}\nQMLVariant.plainType = true;\nQmlWeb.qmlVariant = QMLVariant;\n\nwindow.addEventListener(\"load\", function () {\n  var metaTags = document.getElementsByTagName(\"body\");\n  for (var i = 0; i < metaTags.length; ++i) {\n    var metaTag = metaTags[i];\n    var source = metaTag.getAttribute(\"data-qml\");\n    if (source) {\n      QmlWeb.qmlEngine = new QmlWeb.QMLEngine();\n      QmlWeb.qmlEngine.loadFile(source);\n      QmlWeb.qmlEngine.start();\n      break;\n    }\n  }\n});\n\nvar anchorNames = [\"left\", \"right\", \"top\", \"bottom\", \"verticalCenter\", \"horizontalCenter\"];\n\nvar ignoreProps = [\"x\", \"y\", \"z\", \"scale\", \"rotation\", \"implicitWidth\", \"implicitHeight\"];\n\nfunction getProperties(file) {\n  // TODO: implement a cleaner way\n\n  var div = document.createElement(\"div\");\n  var engine = new QmlWeb.QMLEngine(div);\n  engine.loadFile(file);\n\n  var qml = engine.rootObject;\n  var properties = Object.keys(qml.$properties).filter(function (name) {\n    // Invalid names\n    if (!name.match(/^[a-z]+$/i) || name === \"is\") return false;\n\n    // We don't need anchors\n    if (anchorNames.indexOf(name) !== -1) return false;\n\n    // These properties are not supported in a good way on top-level items\n    if (ignoreProps.indexOf(name) !== -1) return false;\n\n    var type = qml.$properties[name].type;\n    return [\"real\", \"color\", \"int\", \"bool\", \"string\"].indexOf(type) !== -1;\n  });\n\n  engine.stop();\n  return properties;\n}\n\nfunction registerElement(name, file) {\n  // Delay until the document is fully loaded\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      registerElement(name, file);\n    });\n    return;\n  }\n\n  // Bail out if Custom Elements v1 are not present\n  if (!window.customElements) {\n    throw new Error(\"window.customElements are not supported. Consider installing a polyfill.\");\n  }\n\n  // We need attributes list at this point, those form a static property\n  var properties = getProperties(file);\n  var attributes = properties.map(function (pname) {\n    return pname.toLowerCase();\n  });\n  var attr2prop = properties.reduce(function (map, pname) {\n    map[pname.toLowerCase()] = pname;\n    return map;\n  }, {});\n\n  var QmlElement = function (_HTMLElement) {\n    _inherits(QmlElement, _HTMLElement);\n\n    function QmlElement() {\n      _classCallCheck(this, QmlElement);\n\n      return _possibleConstructorReturn(this, (QmlElement.__proto__ || Object.getPrototypeOf(QmlElement)).apply(this, arguments));\n    }\n\n    _createClass(QmlElement, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        var _this17 = this;\n\n        // Default wrapper display is inline-block to support native width/height\n        var computedStyle = window.getComputedStyle(this);\n        if (computedStyle.display === \"inline\") {\n          this.style.display = \"inline-block\";\n        }\n\n        var engine = this.engine = new QmlWeb.QMLEngine(this);\n        engine.loadFile(file);\n        engine.start();\n        var qml = this.qml = engine.rootObject;\n\n        // Bind attributes\n        attributes.forEach(function (attr) {\n          var pname = attr2prop[attr] || attr;\n          var val = _this17.getAttribute(attr);\n          if (typeof val === \"string\") {\n            qml[pname] = val;\n          }\n          _this17.applyAttribute(attr);\n          Object.defineProperty(_this17, attr, {\n            get: function get() {\n              return this.qml[pname];\n            },\n            set: function set(value) {\n              this.qml[pname] = value;\n              this.applyAttribute(attr);\n            }\n          });\n          qml.$properties[pname].changed.connect(function () {\n            return _this17.applyAttribute(attr);\n          });\n        });\n\n        // Set and update wrapper width/height\n        this.style.width = qml.width + \"px\";\n        this.style.height = qml.height + \"px\";\n        qml.$properties.width.changed.connect(function (width) {\n          _this17.style.width = width + \"px\";\n        });\n        qml.$properties.height.changed.connect(function (height) {\n          _this17.style.height = height + \"px\";\n        });\n      }\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(attr, oldValue, newValue) {\n        if (!this.qml) return;\n        var pname = attr2prop[attr] || attr;\n        var prop = this.qml.$properties[pname];\n        if (!prop) return;\n        switch (prop.type) {\n          case \"bool\":\n            this.qml[pname] = typeof newValue === \"string\";\n            break;\n          default:\n            this.qml[pname] = newValue;\n        }\n      }\n    }, {\n      key: \"applyAttribute\",\n      value: function applyAttribute(attr) {\n        var pname = attr2prop[attr] || attr;\n        var prop = this.qml.$properties[pname];\n        if (!prop) {\n          this.deleteAttribute(attr);\n          return;\n        }\n        var value = this.qml[pname];\n        switch (prop.type) {\n          case \"bool\":\n            if (value) {\n              this.setAttribute(attr, \"\");\n            } else {\n              this.removeAttribute(attr);\n            }\n            break;\n          default:\n            this.setAttribute(attr, this.qml[pname]);\n        }\n      }\n    }], [{\n      key: \"observedAttributes\",\n      get: function get() {\n        return attributes;\n      }\n    }]);\n\n    return QmlElement;\n  }(HTMLElement);\n\n  window.customElements.define(name, QmlElement);\n}\n\nQmlWeb.registerElement = registerElement;\n\nvar Easing = {\n  Linear: 1,\n  InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,\n  InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,\n  InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,\n  InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,\n  InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,\n  InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,\n  InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,\n  InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,\n  InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,\n  InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41\n};\n\n// eslint-disable-next-line complexity\nQmlWeb.$ease = function (type, period, amplitude, overshoot, t) {\n  switch (type) {\n    // Linear\n    case Easing.Linear:\n      return t;\n\n    // Quad\n    case Easing.InQuad:\n      return Math.pow(t, 2);\n    case Easing.OutQuad:\n      return -Math.pow(t - 1, 2) + 1;\n    case Easing.InOutQuad:\n      if (t < 0.5) {\n        return 2 * Math.pow(t, 2);\n      }\n      return -2 * Math.pow(t - 1, 2) + 1;\n    case Easing.OutInQuad:\n      if (t < 0.5) {\n        return -2 * Math.pow(t - 0.5, 2) + 0.5;\n      }\n      return 2 * Math.pow(t - 0.5, 2) + 0.5;\n\n    // Cubic\n    case Easing.InCubic:\n      return Math.pow(t, 3);\n    case Easing.OutCubic:\n      return Math.pow(t - 1, 3) + 1;\n    case Easing.InOutCubic:\n      if (t < 0.5) {\n        return 4 * Math.pow(t, 3);\n      }\n      return 4 * Math.pow(t - 1, 3) + 1;\n    case Easing.OutInCubic:\n      return 4 * Math.pow(t - 0.5, 3) + 0.5;\n\n    // Quart\n    case Easing.InQuart:\n      return Math.pow(t, 4);\n    case Easing.OutQuart:\n      return -Math.pow(t - 1, 4) + 1;\n    case Easing.InOutQuart:\n      if (t < 0.5) {\n        return 8 * Math.pow(t, 4);\n      }\n      return -8 * Math.pow(t - 1, 4) + 1;\n    case Easing.OutInQuart:\n      if (t < 0.5) {\n        return -8 * Math.pow(t - 0.5, 4) + 0.5;\n      }\n      return 8 * Math.pow(t - 0.5, 4) + 0.5;\n\n    // Quint\n    case Easing.InQuint:\n      return Math.pow(t, 5);\n    case Easing.OutQuint:\n      return Math.pow(t - 1, 5) + 1;\n    case Easing.InOutQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t, 5);\n      }\n      return 16 * Math.pow(t - 1, 5) + 1;\n    case Easing.OutInQuint:\n      if (t < 0.5) {\n        return 16 * Math.pow(t - 0.5, 5) + 0.5;\n      }\n      return 16 * Math.pow(t - 0.5, 5) + 0.5;\n\n    // Sine\n    case Easing.InSine:\n      return -Math.cos(0.5 * Math.PI * t) + 1;\n    case Easing.OutSine:\n      return Math.sin(0.5 * Math.PI * t);\n    case Easing.InOutSine:\n      return -0.5 * Math.cos(Math.PI * t) + 0.5;\n    case Easing.OutInSine:\n      if (t < 0.5) {\n        return 0.5 * Math.sin(Math.PI * t);\n      }\n      return -0.5 * Math.sin(Math.PI * t) + 1;\n\n    // Expo\n    case Easing.InExpo:\n      return 1 / 1023 * (Math.pow(2, 10 * t) - 1);\n    case Easing.OutExpo:\n      return -1024 / 1023 * (Math.pow(2, -10 * t) - 1);\n    case Easing.InOutExpo:\n      if (t < 0.5) {\n        return 1 / 62 * (Math.pow(2, 10 * t) - 1);\n      }\n      return -512 / 31 * Math.pow(2, -10 * t) + 63 / 62;\n    case Easing.OutInExpo:\n      if (t < 0.5) {\n        return -16 / 31 * (Math.pow(2, -10 * t) - 1);\n      }\n      return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;\n\n    // Circ\n    case Easing.InCirc:\n      return 1 - Math.sqrt(1 - t * t);\n    case Easing.OutCirc:\n      return Math.sqrt(1 - Math.pow(t - 1, 2));\n    case Easing.InOutCirc:\n      if (t < 0.5) {\n        return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));\n      }\n      return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n    case Easing.OutInCirc:\n      if (t < 0.5) {\n        return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n      }\n      return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n\n    // Elastic\n    case Easing.InElastic:\n      return -amplitude * Math.pow(2, 10 * t - 10) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude));\n    case Easing.OutElastic:\n      return amplitude * Math.pow(2, -10 * t) * Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude)) + 1;\n    case Easing.InOutElastic:\n      if (t < 0.5) {\n        return -0.5 * amplitude * Math.pow(2, 20 * t - 10) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude));\n      }\n      return -0.5 * amplitude * Math.pow(2, -20 * t + 10) * Math.sin(4 * t * Math.PI / period + Math.asin(1 / amplitude)) + 1;\n    case Easing.OutInElastic:\n      if (t < 0.5) {\n        return 0.5 * amplitude * Math.pow(2, -20 * t) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n      }\n      return -0.5 * amplitude * Math.pow(2, 20 * t - 20) * Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\n\n    // Back\n    case Easing.InBack:\n      return (overshoot + 1) * Math.pow(t, 3) - overshoot * Math.pow(t, 2);\n    case Easing.OutBack:\n      return (overshoot + 1) * Math.pow(t - 1, 3) + overshoot * Math.pow(t - 1, 2) + 1;\n    case Easing.InOutBack:\n      if (t < 0.5) {\n        return 4 * (overshoot + 1) * Math.pow(t, 3) - 2 * overshoot * Math.pow(t, 2);\n      }\n      return 0.5 * (overshoot + 1) * Math.pow(2 * t - 2, 3) + overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;\n    case Easing.OutInBack:\n      if (t < 0.5) {\n        return 0.5 * ((overshoot + 1) * Math.pow(2 * t - 1, 3) + overshoot * Math.pow(2 * t - 1, 2) + 1);\n      }\n      return 4 * (overshoot + 1) * Math.pow(t - 0.5, 3) - 2 * overshoot * Math.pow(t - 0.5, 2) + 0.5;\n    // Bounce\n    case Easing.InBounce:\n      if (t < 1 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 1 / 11 * t);\n      } else if (t < 3 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 4 / 11 * t + 3 / 121);\n      } else if (t < 7 / 11) {\n        return -amplitude * 121 / 16 * (t * t - 10 / 11 * t + 21 / 121);\n      }\n      return -(121 / 16) * (t * t - 2 * t + 1) + 1;\n    case Easing.OutBounce:\n      if (t < 4 / 11) {\n        return 121 / 16 * t * t;\n      } else if (t < 8 / 11) {\n        return amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;\n      } else if (t < 10 / 11) {\n        return amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;\n      }\n      return amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;\n    case Easing.InOutBounce:\n      if (t < 1 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 1 / 22 * t);\n      } else if (t < 3 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 2 / 11 * t + 3 / 484);\n      } else if (t < 7 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 5 / 11 * t + 21 / 484);\n      } else if (t < 11 / 22) {\n        return -121 / 8 * (t * t - t + 0.25) + 0.5;\n      } else if (t < 15 / 22) {\n        return 121 / 8 * (t * t - t) + 137 / 32;\n      } else if (t < 19 / 22) {\n        return amplitude * 121 / 8 * (t * t - 17 / 11 * t + 285 / 484) + 1;\n      } else if (t < 21 / 22) {\n        return amplitude * 121 / 8 * (t * t - 20 / 11 * t + 399 / 484) + 1;\n      }\n      return amplitude * 121 / 8 * (t * t - 43 / 22 * t + 21 / 22) + 1;\n    case Easing.OutInBounce:\n      if (t < 4 / 22) {\n        return 121 / 8 * t * t;\n      } else if (t < 8 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 6 / 11 * t + 8 / 121) + 0.5;\n      } else if (t < 10 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 9 / 11 * t + 20 / 121) + 0.5;\n      } else if (t < 11 / 22) {\n        return -amplitude * 121 / 8 * (t * t - 21 / 22 * t + 5 / 22) + 0.5;\n      } else if (t < 12 / 22) {\n        return amplitude * 121 / 8 * (t * t - 23 / 22 * t + 3 / 11) + 0.5;\n      } else if (t < 14 / 22) {\n        return amplitude * 121 / 8 * (t * t - 13 / 11 * t + 42 / 121) + 0.5;\n      } else if (t < 18 / 22) {\n        return amplitude * 121 / 8 * (t * t - 16 / 11 * t + 63 / 121) + 0.5;\n      }\n      return -121 / 8 * (t * t - 2 * t + 117 / 121) + 0.5;\n\n    // Default\n    default:\n      console.error(\"Unsupported animation type: \", type);\n      return t;\n  }\n};\n\nQmlWeb.Easing = Easing;\n\n/* eslint accessor-pairs: 0 */\n\nfunction setupGetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    get: func,\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction setupSetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    set: func,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n  Object.defineProperty(obj, propName, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nQmlWeb.setupGetter = setupGetter;\nQmlWeb.setupSetter = setupSetter;\nQmlWeb.setupGetterSetter = setupGetterSetter;\n\nvar QmlWebHelpers = function () {\n  function QmlWebHelpers() {\n    _classCallCheck(this, QmlWebHelpers);\n  }\n\n  _createClass(QmlWebHelpers, null, [{\n    key: \"arrayFindIndex\",\n    value: function arrayFindIndex(array, callback) {\n      // Note: does not support thisArg, we don't need that\n      if (!Array.prototype.findIndex) {\n        for (var key in array) {\n          if (callback(array[key], key, array)) {\n            return key;\n          }\n        }\n        return -1;\n      }\n      return Array.prototype.findIndex.call(array, callback);\n    }\n  }, {\n    key: \"mergeObjects\",\n    value: function mergeObjects() {\n      var merged = {};\n\n      for (var _len23 = arguments.length, args = Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n\n      for (var i in args) {\n        var arg = args[i];\n        if (!arg) {\n          continue;\n        }\n        for (var key in arg) {\n          merged[key] = arg[key];\n        }\n      }\n      return merged;\n    }\n  }]);\n\n  return QmlWebHelpers;\n}();\n\nQmlWeb.helpers = QmlWebHelpers;\n\n/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\r\n                                                         import implementation.\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\n/**\r\n * Get URL contents.\r\n * @param url {String} Url to fetch.\r\n * @param skipExceptions {bool} when turned on, ignore exeptions and return\r\n *        false. This feature is used by readQmlDir.\r\n * @private\r\n * @return {mixed} String of contents or false in errors.\r\n */\nfunction getUrlContents(url, skipExceptions) {\n  if (typeof QmlWeb.urlContentCache[url] === \"undefined\") {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n\n    if (skipExceptions) {\n      try {\n        xhr.send(null);\n      } catch (e) {\n        return false;\n      }\n      // it is OK to not have logging here, because DeveloperTools already will\n      // have red log record\n    } else {\n      xhr.send(null);\n    }\n\n    if (xhr.status !== 200 && xhr.status !== 0) {\n      // 0 if accessing with file://\n      console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\n      return false;\n    }\n    QmlWeb.urlContentCache[url] = xhr.responseText;\n  }\n  return QmlWeb.urlContentCache[url];\n}\nif (typeof QmlWeb.urlContentCache === \"undefined\") {\n  QmlWeb.urlContentCache = {};\n}\n\n/**\r\n * Read qmldir spec file at directory.\r\n * @param url Url of the directory\r\n * @return {Object} Object, where .internals lists qmldir internal references\r\n *                          and .externals lists qmldir external references.\r\n */\n\n/*  Note on how importing works.\r\n\r\nparseQML gives us `tree.$imports` variable, which contains information from\r\n`import` statements.\r\n\r\nAfter each call to parseQML, we call engine.loadImports(tree.$imports).\r\nIt in turn invokes readQmlDir() calls for each import, with respect to current\r\ncomponent base path and engine.importPathList().\r\n\r\nWe keep all component names from all qmldir files in global variable\r\n`engine.qmldir`.\r\n\r\nIn construct() function, we use `engine.qmldir` for component url lookup.\r\n\r\nReference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html\r\nAlso please look at notes and TODO's in qtcore.js::loadImports() and\r\nqtcore.js::construct() methods.\r\n*/\n\nfunction readQmlDir(url) {\n  // in case 'url' is empty, do not attach \"/\"\n  // Q1: when this happen?\n  var qmldirFileUrl = url.length > 0 ? url + \"/qmldir\" : \"qmldir\";\n\n  var parsedUrl = QmlWeb.engine.$parseURI(qmldirFileUrl);\n\n  var qmldir = void 0;\n  if (parsedUrl.scheme === \"qrc://\") {\n    qmldir = QmlWeb.qrc[parsedUrl.path];\n  } else {\n    qmldir = getUrlContents(qmldirFileUrl, true) || undefined;\n  }\n\n  var internals = {};\n  var externals = {};\n\n  if (qmldir === undefined) {\n    return false;\n  }\n\n  // we have to check for \"://\"\n  // In that case, item path is meant to be absolute, and we have no need to\n  // prefix it with base url\n  function makeurl(path) {\n    if (path.indexOf(\"://\") > 0) {\n      return path;\n    }\n    return url + \"/\" + path;\n  }\n\n  var lines = qmldir.split(/\\r?\\n/);\n  for (var i = 0; i < lines.length; i++) {\n    // trim\n    var line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n    if (!line.length || line[0] === \"#\") {\n      // Empty line or comment\n      continue;\n    }\n    var match = line.split(/\\s+/);\n    if (match.length === 2 || match.length === 3) {\n      if (match[0] === \"plugin\") {\n        console.log(url + \": qmldir plugins are not supported!\");\n      } else if (match[0] === \"internal\") {\n        internals[match[1]] = { url: makeurl(match[2]) };\n      } else if (match.length === 2) {\n        externals[match[0]] = { url: makeurl(match[1]) };\n      } else {\n        externals[match[0]] = { url: makeurl(match[2]), version: match[1] };\n      }\n    } else {\n      console.log(url + \": unmatched: \" + line);\n    }\n  }\n  return { internals: internals, externals: externals };\n}\n\nQmlWeb.getUrlContents = getUrlContents;\nQmlWeb.readQmlDir = readQmlDir;\n\nfunction importJavascriptInContext(contextSetter, $context) {\n  /* Set the QmlWeb.executionContext so that any internal calls to Qt.include\r\n   * will have the proper context */\n  var oldExecutionContext = QmlWeb.executionContext;\n  QmlWeb.executionContext = $context;\n  contextSetter($context);\n  QmlWeb.executionContext = oldExecutionContext;\n}\n\nQmlWeb.importJavascriptInContext = importJavascriptInContext;\n\nQmlWeb.keyCodeToQt = function (e) {\n  var Qt = QmlWeb.Qt;\n  e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n  if (e.keyCode === Qt.Key_Tab && e.shiftKey) {\n    return Qt.Key_Backtab;\n  }\n  if (e.keyCode >= 97 && e.keyCode <= 122) {\n    return e.keyCode - (97 - Qt.Key_A);\n  }\n  return e.keyCode;\n};\n\nQmlWeb.eventToKeyboard = function (e) {\n  return {\n    accepted: false,\n    count: 1,\n    isAutoRepeat: false,\n    key: QmlWeb.keyCodeToQt(e),\n    modifiers: e.ctrlKey * QmlWeb.Qt.CtrlModifier | e.altKey * QmlWeb.Qt.AltModifier | e.shiftKey * QmlWeb.Qt.ShiftModifier | e.metaKey * QmlWeb.Qt.MetaModifier | e.keypad * QmlWeb.Qt.KeypadModifier,\n    text: String.fromCharCode(e.charCode)\n  };\n};\n\nQmlWeb.keyboardSignals = {};\n[\"asterisk\", \"back\", \"backtab\", \"call\", \"cancel\", \"delete\", \"escape\", \"flip\", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"hangup\", \"menu\", \"no\", \"return\", \"select\", \"space\", \"tab\", \"volumeDown\", \"volumeUp\", \"yes\", \"up\", \"right\", \"down\", \"left\"].forEach(function (key) {\n  var name = key.toString();\n  var qtName = \"Key_\" + name[0].toUpperCase() + name.slice(1);\n  var prefix = typeof key === \"number\" ? \"digit\" : \"\";\n  QmlWeb.keyboardSignals[QmlWeb.Qt[qtName]] = \"\" + prefix + name + \"Pressed\";\n});\n\nQmlWeb.executionContext = null;\n\nvar modules = {\n  Main: {\n    int: QmlWeb.qmlInteger,\n    real: QmlWeb.qmlNumber,\n    double: QmlWeb.qmlNumber,\n    string: QmlWeb.qmlString,\n    bool: QmlWeb.qmlBoolean,\n    list: QmlWeb.qmlList,\n    color: QmlWeb.QColor,\n    font: QmlWeb.QFont,\n    size: QmlWeb.QSizeF,\n    point: QmlWeb.QPointF,\n    rect: QmlWeb.QRectF,\n    vector2d: QmlWeb.QVector2D,\n    vector3d: QmlWeb.QVector3D,\n    vector4d: QmlWeb.QVector4D,\n    quaternion: QmlWeb.QQuaternion,\n    matrix4x4: QmlWeb.QMatrix4x4,\n    enum: QmlWeb.qmlNumber,\n    url: QmlWeb.qmlUrl,\n    variant: QmlWeb.qmlVariant,\n    var: QmlWeb.qmlVariant\n  }\n};\n\n// All object constructors\nQmlWeb.constructors = modules.Main;\n\nvar dependants = {};\n\nvar perImportContextConstructors = {};\nvar importContextIds = 0;\n\n// Helper. Adds a type to the constructor list\nfunction registerGlobalQmlType(name, type) {\n  QmlWeb[type.name] = type;\n  QmlWeb.constructors[name] = type;\n  modules.Main[name] = type;\n}\n\n// Helper. Register a type to a module\nfunction registerQmlType(options, constructor) {\n  if (constructor !== undefined) {\n    options.constructor = constructor;\n  }\n\n  if (typeof options.baseClass === \"string\") {\n    // TODO: Does not support version specification (yet?)\n    var baseModule = void 0;\n    var baseName = void 0;\n    var dot = options.baseClass.lastIndexOf(\".\");\n    if (dot === -1) {\n      baseModule = options.module;\n      baseName = options.baseClass;\n    } else {\n      baseModule = options.baseClass.substring(0, dot);\n      baseName = options.baseClass.substring(dot + 1);\n    }\n    var found = (modules[baseModule] || []).filter(function (descr) {\n      return descr.name === baseName;\n    });\n    if (found.length > 0) {\n      // Ok, we found our base class\n      options.baseClass = found[0].constructor;\n    } else {\n      // Base class not found, delay the loading\n      var baseId = [baseModule, baseName].join(\".\");\n      if (!dependants.hasOwnProperty(baseId)) {\n        dependants[baseId] = [];\n      }\n      dependants[baseId].push(options);\n      return;\n    }\n  }\n\n  var descriptor = typeof options === \"function\" ? {\n    module: options.module,\n    name: options.element,\n    versions: options.versions,\n    baseClass: options.baseClass,\n    enums: options.enums,\n    signals: options.signals,\n    defaultProperty: options.defaultProperty,\n    properties: options.properties,\n    constructor: options\n  } : options;\n\n  descriptor.constructor.$qmlTypeInfo = {\n    enums: descriptor.enums,\n    signals: descriptor.signals,\n    defaultProperty: descriptor.defaultProperty,\n    properties: descriptor.properties\n  };\n\n  if (descriptor.global) {\n    registerGlobalQmlType(descriptor.name, descriptor.constructor);\n  }\n\n  var moduleDescriptor = {\n    name: descriptor.name,\n    versions: descriptor.versions,\n    constructor: descriptor.constructor\n  };\n\n  if (typeof modules[descriptor.module] === \"undefined\") {\n    modules[descriptor.module] = [];\n  }\n  modules[descriptor.module].push(moduleDescriptor);\n\n  if (typeof descriptor.baseClass !== \"undefined\") {\n    inherit(descriptor.constructor, descriptor.baseClass);\n  }\n\n  var id = [descriptor.module, descriptor.name].join(\".\");\n  if (dependants.hasOwnProperty(id)) {\n    dependants[id].forEach(function (opt) {\n      return registerQmlType(opt);\n    });\n    dependants[id].length = 0;\n  }\n\n  // TODO: Move to module initialization?\n  /*\r\n    http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers\r\n      Some object treated as Attached. For example, Component.\r\n    Here, we set property to object `QMLBaseObject.prototype` with name of that\r\n    object, and with specific getter func.\r\n    E.g., we create \"someitem.Component\" here.\r\n    Later, if somebody will read that property, the getter will be invoked.\r\n    Here all getters are set to `getAttachedObject` only, which is actually\r\n    dedicated for Component attached object.\r\n    The code of `getAttachedObject` checks whether $Component internal\r\n    variable exist, and creates it if it absent.\r\n    Then, `getAttachedObject` adds self \"completed\" signal to global\r\n    `engine.completedSignals`.\r\n    That is how completed handlers gathered into global list. This list then\r\n    is called by `engine.callCompletedSignals`.\r\n      p.s. At the moment, Repeater and Loader manually call\r\n    `Component.completed` signals on objects they create.\r\n    At the same time, those signals are still pushed to\r\n    `engine.completedSignals` by getAttachedObject.\r\n  */\n  if (descriptor.constructor.getAttachedObject) {\n    var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n    QmlWeb.setupGetter(QMLBaseObject.prototype, descriptor.name, descriptor.constructor.getAttachedObject);\n  }\n}\n\nfunction getConstructor(moduleName, version, name) {\n  if (typeof modules[moduleName] !== \"undefined\") {\n    for (var i = 0; i < modules[moduleName].length; ++i) {\n      var type = modules[moduleName][i];\n      if (type.name === name && type.versions.test(version)) {\n        return type.constructor;\n      }\n    }\n  }\n  return null;\n}\n\nfunction getModuleConstructors(moduleName, version) {\n  var constructors = {};\n  if (typeof modules[moduleName] === \"undefined\") {\n    console.warn(\"module \\\"\" + moduleName + \"\\\" not found\");\n    return constructors;\n  }\n  for (var i = 0; i < modules[moduleName].length; ++i) {\n    var module = modules[moduleName][i];\n    if (module.versions.test(version)) {\n      constructors[module.name] = module.constructor;\n    }\n  }\n  return constructors;\n}\n\nfunction loadImports(self, imports) {\n  var mergeObjects = QmlWeb.helpers.mergeObjects;\n  var constructors = mergeObjects(modules.Main);\n  if (imports.filter(function (row) {\n    return row[1] === \"QtQml\";\n  }).length === 0 && imports.filter(function (row) {\n    return row[1] === \"QtQuick\";\n  }).length === 1) {\n    imports.push([\"qmlimport\", \"QtQml\", 2, \"\", true]);\n  }\n  for (var i = 0; i < imports.length; ++i) {\n    var _imports$i = _slicedToArray(imports[i], 4),\n        moduleName = _imports$i[1],\n        moduleVersion = _imports$i[2],\n        moduleAlias = _imports$i[3];\n\n    if (typeof moduleVersion !== \"number\") continue;\n    var versionString = moduleVersion % 1 === 0 ? moduleVersion.toFixed(1) : moduleVersion.toString();\n    var moduleConstructors = getModuleConstructors(moduleName, versionString);\n\n    if (moduleAlias !== \"\") {\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\n    } else {\n      constructors = mergeObjects(constructors, moduleConstructors);\n    }\n  }\n  self.importContextId = importContextIds++;\n  perImportContextConstructors[self.importContextId] = constructors;\n  QmlWeb.constructors = constructors; // TODO: why do we need this?\n}\n\nfunction inherit(constructor, baseClass) {\n  var oldProto = constructor.prototype;\n  constructor.prototype = Object.create(baseClass.prototype);\n  Object.getOwnPropertyNames(oldProto).forEach(function (prop) {\n    constructor.prototype[prop] = oldProto[prop];\n  });\n  constructor.prototype.constructor = baseClass;\n}\n\nfunction callSuper(self, meta) {\n  var info = meta.super.$qmlTypeInfo || {};\n  meta.super = meta.super.prototype.constructor;\n  meta.super.call(self, meta);\n\n  if (info.enums) {\n    // TODO: not exported to the whole file scope yet\n    Object.keys(info.enums).forEach(function (name) {\n      self[name] = info.enums[name];\n\n      if (!global[name]) {\n        global[name] = self[name]; // HACK\n      }\n    });\n  }\n  if (info.properties) {\n    QmlWeb.createProperties(self, info.properties);\n  }\n  if (info.signals) {\n    Object.keys(info.signals).forEach(function (name) {\n      var params = info.signals[name];\n      self[name] = QmlWeb.Signal.signal(params);\n    });\n  }\n  if (info.defaultProperty) {\n    self.$defaultProperty = info.defaultProperty;\n  }\n}\n\n/**\r\n * QML Object constructor.\r\n * @param {Object} meta Meta information about the object and the creation\r\n *                      context\r\n * @return {Object} New qml object\r\n */\nfunction construct(meta) {\n  var item = void 0;\n\n  var constructors = perImportContextConstructors[meta.context.importContextId];\n\n  var classComponents = meta.object.$class.split(\".\");\n  for (var ci = 0; ci < classComponents.length; ++ci) {\n    var c = classComponents[ci];\n    constructors = constructors[c];\n    if (constructors === undefined) {\n      break;\n    }\n  }\n\n  if (constructors !== undefined) {\n    var _constructor = constructors;\n    meta.super = _constructor;\n    item = new _constructor(meta);\n    meta.super = undefined;\n  } else {\n    // Load component from file. Please look at import.js for main notes.\n    // Actually, we have to use that order:\n    // 1) try to load component from current basePath\n    // 2) from importPathList\n    // 3) from directories in imports statements and then\n    // 4) from qmldir files\n    // Currently we support only 1,2 and 4 and use order: 4,1,2\n    // TODO: engine.qmldirs is global for all loaded components.\n    //       That's not qml's original behaviour.\n    var qdirInfo = QmlWeb.engine.qmldirs[meta.object.$class];\n    // Are we have info on that component in some imported qmldir files?\n\n    /* This will also be set in applyProperties, but needs to be set here\r\n     * for Qt.createComponent to have the correct context. */\n    QmlWeb.executionContext = meta.context;\n\n    var filePath = void 0;\n    if (qdirInfo) {\n      filePath = qdirInfo.url;\n    } else if (classComponents.length === 2) {\n      var qualified = QmlWeb.engine.qualifiedImportPath(meta.context.importContextId, classComponents[0]);\n      filePath = \"\" + qualified + classComponents[1] + \".qml\";\n    } else {\n      filePath = classComponents[0] + \".qml\";\n    }\n\n    var component = QmlWeb.Qt.createComponent(filePath);\n\n    if (!component) {\n      throw new Error(\"No constructor found for \" + meta.object.$class);\n    }\n\n    item = component.$createObject(meta.parent);\n    if (typeof item.dom !== \"undefined\") {\n      item.dom.className += \" \" + classComponents[classComponents.length - 1];\n      if (meta.object.id) {\n        item.dom.className += \"  \" + meta.object.id;\n      }\n    }\n    // Handle default properties\n  }\n\n  // id\n  if (meta.object.id) {\n    QmlWeb.setupGetterSetter(meta.context, meta.object.id, function () {\n      return item;\n    }, function () {});\n  }\n\n  // keep path in item for probale use it later in Qt.resolvedUrl\n  item.$context.$basePath = QmlWeb.engine.$basePath; //gut\n\n  // We want to use the item's scope, but this Component's imports\n  item.$context.importContextId = meta.context.importContextId;\n\n  // Apply properties (Bindings won't get evaluated, yet)\n  QmlWeb.applyProperties(meta.object, item, item, item.$context);\n\n  return item;\n}\n\nQmlWeb.modules = modules;\nQmlWeb.registerGlobalQmlType = registerGlobalQmlType;\nQmlWeb.registerQmlType = registerQmlType;\nQmlWeb.getConstructor = getConstructor;\nQmlWeb.loadImports = loadImports;\nQmlWeb.callSuper = callSuper;\nQmlWeb.construct = construct;\n\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {String} propName Property name\r\n * @param {Object} [options] Options that allow finetuning of the property\r\n */\nfunction createProperty(type, obj, propName) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var QMLProperty = QmlWeb.QMLProperty;\n  var prop = new QMLProperty(type, obj, propName);\n  obj[propName + \"Changed\"] = prop.changed;\n  obj.$properties[propName] = prop;\n  obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n\n  var getter = function getter() {\n    return obj.$properties[propName].get();\n  };\n  var setter = void 0;\n  if (options.readOnly) {\n    setter = function setter(newVal) {\n      if (!obj.$canEditReadOnlyProperties) {\n        throw new Error(\"property '\" + propName + \"' has read only access\");\n      }\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  } else {\n    setter = function setter(newVal) {\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n    };\n  }\n  QmlWeb.setupGetterSetter(obj, propName, getter, setter);\n  if (obj.$isComponentRoot) {\n    var skip = false;\n    if (options.noContextOverride) {\n      // Don't override context properties if options.noContextOverride is on\n      var descr = Object.getOwnPropertyDescriptor(obj.$context, propName);\n      skip = descr && (descr.get || descr.set);\n    }\n    if (!skip) {\n      QmlWeb.setupGetterSetter(obj.$context, propName, getter, setter);\n    }\n  }\n}\n\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {Object} properties An object containing properties descriptors\r\n */\nfunction createProperties(obj, properties) {\n  Object.keys(properties).forEach(function (name) {\n    var desc = properties[name];\n    if (typeof desc === \"string\") {\n      desc = { type: desc };\n    }\n    createProperty(desc.type, obj, name, desc);\n  });\n}\n\n/**\r\n * Apply properties from metaObject to item.\r\n * @param {Object} metaObject Source of properties\r\n * @param {Object} item Target of property apply\r\n * @param {Object} objectScope Scope in which properties should be evaluated\r\n * @param {Object} componentScope Component scope in which properties should be\r\n *                 evaluated\r\n */\nfunction applyProperties(metaObject, item, objectScopeIn, componentScope) {\n  var QMLProperty = QmlWeb.QMLProperty;\n  var objectScope = objectScopeIn || item;\n  QmlWeb.executionContext = componentScope;\n\n  if (metaObject.$children && metaObject.$children.length !== 0) {\n    if (item.$defaultProperty) {\n      item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);\n    } else {\n      throw new Error(\"Cannot assign to unexistant default property\");\n    }\n  }\n  // We purposefully set the default property AFTER using it, in order to only\n  // have it applied for instanciations of this component, but not for its\n  // internal children\n  if (metaObject.$defaultProperty) {\n    item.$defaultProperty = metaObject.$defaultProperty;\n  }\n\n  for (var i in metaObject) {\n    var value = metaObject[i];\n    if (i === \"id\" || i === \"$class\") {\n      // keep them\n      item[i] = value;\n      continue;\n    }\n\n    // skip global id's and internal values\n    if (i === \"id\" || i[0] === \"$\") {\n      // TODO: what? See above.\n      continue;\n    }\n\n    // slots\n    if (i.indexOf(\"on\") === 0 && i.length > 2 && /[A-Z]/.test(i[2])) {\n      var signalName = i[2].toLowerCase() + i.slice(3);\n      if (connectSignal(item, signalName, value, objectScope, componentScope)) {\n        continue;\n      }\n      if (item.$setCustomSlot) {\n        item.$setCustomSlot(signalName, value, objectScope, componentScope);\n        continue;\n      }\n    }\n\n    if (value instanceof Object) {\n      if (applyProperty(item, i, value, objectScope, componentScope)) {\n        continue;\n      }\n    }\n\n    if (item.$properties && i in item.$properties) {\n      item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);\n    } else if (i in item) {\n      item[i] = value;\n    } else if (item.$setCustomData) {\n      item.$setCustomData(i, value);\n    } else {\n      console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\n    }\n  }\n}\n\nfunction applyProperty(item, i, value, objectScope, componentScope) {\n  var QMLProperty = QmlWeb.QMLProperty;\n\n  if (value instanceof QmlWeb.QMLSignalDefinition) {\n    item[i] = QmlWeb.Signal.signal(value.parameters);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLMethod) {\n    value.compile();\n    item[i] = value.eval(objectScope, componentScope, componentScope.$basePath);\n    if (item.$isComponentRoot) {\n      componentScope[i] = item[i];\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLAliasDefinition) {\n    // TODO\n    // 1. Alias must be able to point to prop or id of local object,\n    //    eg: property alias q: t\n    // 2. Alias may have same name as id it points to: property alias\n    //    someid: someid\n    // 3. Alias proxy (or property proxy) to proxy prop access to selected\n    //    incapsulated object. (think twice).\n    createProperty(\"alias\", item, i, { noContextOverride: true });\n    item.$properties[i].componentScope = componentScope;\n    item.$properties[i].componentScopeBasePath = componentScope.$basePath;\n    item.$properties[i].val = value;\n    item.$properties[i].get = function () {\n      var obj = this.componentScope[this.val.objectName];\n      var propertyName = this.val.propertyName;\n      return propertyName ? obj.$properties[propertyName].get() : obj;\n    };\n    item.$properties[i].set = function (newVal, reason, _objectScope, _componentScope) {\n      if (!this.val.propertyName) {\n        throw new Error(\"Cannot set alias property pointing to an QML object.\");\n      }\n      var obj = this.componentScope[this.val.objectName];\n      var prop = obj.$properties[this.val.propertyName];\n      prop.set(newVal, reason, _objectScope, _componentScope);\n    };\n\n    if (value.propertyName) {\n      var con = function con(prop) {\n        var obj = prop.componentScope[prop.val.objectName];\n        if (!obj) {\n          console.error(\"qtcore: target object \", prop.val.objectName, \" not found for alias \", prop);\n          return;\n        }\n        var targetProp = obj.$properties[prop.val.propertyName];\n        if (!targetProp) {\n          console.error(\"qtcore: target property [\", prop.val.objectName, \"].\", prop.val.propertyName, \" not found for alias \", prop.name);\n          return;\n        }\n        // targetProp.changed.connect( prop.changed );\n        // it is not sufficient to connect to `changed` of source property\n        // we have to propagate own changed to it too\n        // seems the best way to do this is to make them identical?..\n        // prop.changed = targetProp.changed;\n        // obj[`${i}Changed`] = prop.changed;\n        // no. because those object might be destroyed later.\n        var loopWatchdog = false;\n        targetProp.changed.connect(item, function () {\n          for (var _len24 = arguments.length, args = Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n            args[_key24] = arguments[_key24];\n          }\n\n          if (loopWatchdog) return;\n          loopWatchdog = true;\n          prop.changed.apply(item, args);\n          loopWatchdog = false;\n        });\n        prop.changed.connect(obj, function () {\n          for (var _len25 = arguments.length, args = Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n            args[_key25] = arguments[_key25];\n          }\n\n          if (loopWatchdog) return;\n          loopWatchdog = true;\n          targetProp.changed.apply(obj, args);\n          loopWatchdog = false;\n        });\n      };\n      QmlWeb.engine.pendingOperations.push([con, item.$properties[i]]);\n    }\n    return true;\n  }\n\n  if (value instanceof QmlWeb.QMLPropertyDefinition) {\n    createProperty(value.type, item, i);\n    item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);\n    return true;\n  }\n\n  if (item[i] && value instanceof QmlWeb.QMLMetaPropertyGroup) {\n    // Apply properties one by one, otherwise apply at once\n    applyProperties(value, item[i], objectScope, componentScope);\n    return true;\n  }\n\n  return false;\n}\n\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\n  if (!item[signalName]) {\n    console.warn(\"No signal called \" + signalName + \" found!\");\n    return undefined;\n  } else if (typeof item[signalName].connect !== \"function\") {\n    console.warn(signalName + \" is not a signal!\");\n    return undefined;\n  }\n\n  if (!value.compiled) {\n    var params = [];\n    for (var j in item[signalName].parameters) {\n      params.push(item[signalName].parameters[j].name);\n    }\n    // Wrap value.src in IIFE in case it includes a \"return\"\n    value.src = \"(\\n      function(\" + params.join(\", \") + \") {\\n        QmlWeb.executionContext = __executionContext;\\n        const bp = QmlWeb.engine.$basePath;\\n        QmlWeb.engine.$basePath = \\\"\" + componentScope.$basePath + \"\\\";\\n        try {\\n          (function() {\\n            \" + value.src + \"\\n          })();\\n        } finally {\\n          QmlWeb.engine.$basePath = bp;\\n        }\\n      }\\n    )\";\n    value.isFunction = false;\n    value.compile();\n  }\n  // Don't pass in __basePath argument, as QMLEngine.$basePath is set in the\n  // value.src, as we need it set at the time the slot is called.\n  var slot = value.eval(objectScope, componentScope);\n  item[signalName].connect(item, slot);\n  return slot;\n}\n\nQmlWeb.createProperty = createProperty;\nQmlWeb.createProperties = createProperties;\nQmlWeb.applyProperties = applyProperties;\nQmlWeb.connectSignal = connectSignal;\n\n/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\nvar QMLMethod = function (_QmlWeb$QMLBinding) {\n  _inherits(QMLMethod, _QmlWeb$QMLBinding);\n\n  function QMLMethod() {\n    _classCallCheck(this, QMLMethod);\n\n    return _possibleConstructorReturn(this, (QMLMethod.__proto__ || Object.getPrototypeOf(QMLMethod)).apply(this, arguments));\n  }\n\n  return QMLMethod;\n}(QmlWeb.QMLBinding);\n\n/**\r\n * Create an object representing a QML property definition.\r\n * @param {String} type The type of the property\r\n * @param {Array} value The default value of the property\r\n * @return {Object} Object representing the defintion\r\n */\n\n\nvar QMLPropertyDefinition = function QMLPropertyDefinition(type, value) {\n  _classCallCheck(this, QMLPropertyDefinition);\n\n  this.type = type;\n  this.value = value;\n};\n\nvar QMLAliasDefinition = function QMLAliasDefinition(objName, propName) {\n  _classCallCheck(this, QMLAliasDefinition);\n\n  this.objectName = objName;\n  this.propertyName = propName;\n};\n\n/**\r\n * Create an object representing a QML signal definition.\r\n * @param {Array} params The parameters the signal ships\r\n * @return {Object} Object representing the defintion\r\n */\n\n\nvar QMLSignalDefinition = function QMLSignalDefinition(params) {\n  _classCallCheck(this, QMLSignalDefinition);\n\n  this.parameters = params;\n};\n\n/**\r\n * Create an object representing a group of QML properties (like anchors).\r\n * @return {Object} Object representing the group\r\n */\n\n\nvar QMLMetaPropertyGroup = function QMLMetaPropertyGroup() {\n  _classCallCheck(this, QMLMetaPropertyGroup);\n};\n\n/**\r\n * Create an object representing a QML element.\r\n * @param {String} type Type of the element\r\n * @param {String} onProp Name of the property specified with the \"on\" keyword\r\n */\n\n\nvar QMLMetaElement = function QMLMetaElement(type, onProp) {\n  _classCallCheck(this, QMLMetaElement);\n\n  this.$class = type;\n  this.$children = [];\n  this.$on = onProp;\n};\n\n// Convert parser tree to the format understood by engine\n\n\nfunction convertToEngine(tree) {\n  return convertToEngine.walk(tree);\n}\n\nfunction stringifyDots(elem) {\n  var sub = elem;\n  var path = [];\n  while (sub[0] === \"dot\") {\n    path.push(sub[1]);\n    sub = sub[2];\n  }\n  path.push(sub);\n  return path.join(\".\");\n}\n\nfunction applyProp(item, name, val) {\n  var curr = item; // output structure\n  var sub = name; // input structure\n  while (sub[0] === \"dot\") {\n    if (!curr[sub[1]]) {\n      curr[sub[1]] = new QMLMetaPropertyGroup();\n    }\n    curr = curr[sub[1]];\n    sub = sub[2];\n  }\n  curr[sub] = val;\n}\n\nconvertToEngine.walkers = {\n  toplevel: function toplevel(imports, statement) {\n    var item = { $class: \"Component\" };\n    item.$imports = imports;\n    item.$children = [convertToEngine.walk(statement)];\n    return item;\n  },\n  qmlelem: function qmlelem(elem, onProp, statements) {\n    var item = new QMLMetaElement(stringifyDots(elem), onProp);\n\n    for (var i in statements) {\n      var statement = statements[i];\n      var name = statement[1];\n      var val = convertToEngine.walk(statement);\n      switch (statement[0]) {\n        case \"qmldefaultprop\":\n          item.$defaultProperty = name;\n          item[name] = val;\n          break;\n        case \"qmlprop\":\n        case \"qmlpropdef\":\n        case \"qmlaliasdef\":\n        case \"qmlmethod\":\n        case \"qmlsignaldef\":\n          applyProp(item, name, val);\n          break;\n        case \"qmlelem\":\n          item.$children.push(val);\n          break;\n        case \"qmlobjdef\":\n          throw new Error(\"qmlobjdef support was removed, update qmlweb-parser to ^0.3.0.\");\n        case \"qmlobj\":\n          // Create object to item\n          item[name] = item[name] || new QMLMetaPropertyGroup();\n          for (var j in val) {\n            item[name][j] = val[j];\n          }\n          break;\n        default:\n          console.log(\"Unknown statement\", statement);\n      }\n    }\n    // Make $children be either a single item or an array, if it's more than one\n    if (item.$children.length === 1) {\n      item.$children = item.$children[0];\n    }\n\n    return item;\n  },\n  qmlprop: function qmlprop(name, tree, src) {\n    if (name === \"id\") {\n      // id property\n      return tree[1][1];\n    }\n    return convertToEngine.bindout(tree, src);\n  },\n  qmlobjdef: function qmlobjdef(name, property, tree, src) {\n    return convertToEngine.bindout(tree, src);\n  },\n  qmlobj: function qmlobj(elem, statements) {\n    var item = {};\n    for (var i in statements) {\n      var statement = statements[i];\n      var name = statement[1];\n      var val = convertToEngine.walk(statement);\n      if (statement[0] === \"qmlprop\") {\n        applyProp(item, name, val);\n      }\n    }\n    return item;\n  },\n  qmlmethod: function qmlmethod(name, tree, src) {\n    return new QMLMethod(src);\n  },\n  qmlpropdef: function qmlpropdef(name, type, tree, src) {\n    return new QMLPropertyDefinition(type, tree ? convertToEngine.bindout(tree, src) : undefined);\n  },\n  qmlaliasdef: function qmlaliasdef(name, objName, propName) {\n    return new QMLAliasDefinition(objName, propName);\n  },\n  qmlsignaldef: function qmlsignaldef(name, params) {\n    return new QMLSignalDefinition(params);\n  },\n  qmldefaultprop: function qmldefaultprop(tree) {\n    return convertToEngine.walk(tree);\n  },\n  name: function name(src) {\n    if (src === \"true\" || src === \"false\") {\n      return src === \"true\";\n    } else if (typeof src === \"boolean\") {\n      // TODO: is this needed? kept for compat with ==\n      return src;\n    }\n    return new QmlWeb.QMLBinding(src, [\"name\", src]);\n  },\n  num: function num(src) {\n    return +src;\n  },\n  string: function string(src) {\n    return String(src);\n  },\n  array: function array(tree, src) {\n    var a = [];\n    var isList = false;\n    var hasBinding = false;\n    for (var i in tree) {\n      var val = convertToEngine.bindout(tree[i]);\n      a.push(val);\n\n      if (val instanceof QMLMetaElement) {\n        isList = true;\n      } else if (val instanceof QmlWeb.QMLBinding) {\n        hasBinding = true;\n      }\n    }\n\n    if (hasBinding) {\n      if (isList) {\n        throw new TypeError(\"An array may either contain bindings or Element definitions.\");\n      }\n      return new QmlWeb.QMLBinding(src, tree);\n    }\n\n    return a;\n  }\n};\n\nconvertToEngine.walk = function (tree) {\n  var type = tree[0];\n  var walker = convertToEngine.walkers[type];\n  if (!walker) {\n    console.log(\"No walker for \" + type);\n    return undefined;\n  }\n  return walker.apply(type, tree.slice(1));\n};\n\n// Try to bind out tree and return static variable instead of binding\nconvertToEngine.bindout = function (statement, binding) {\n  // We want to process the content of the statement\n  // (but still handle the case, we get the content directly)\n  var tree = statement[0] === \"stat\" ? statement[1] : statement;\n\n  var type = tree[0];\n  var walker = convertToEngine.walkers[type];\n  if (walker) {\n    return walker.apply(type, tree.slice(1));\n  }\n  return new QmlWeb.QMLBinding(binding, tree);\n};\n\n// Help logger\nconvertToEngine.amIn = function (str, tree) {\n  console.log(str);\n  if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n};\n\nfunction loadParser() {\n  if (typeof QmlWeb.parse !== \"undefined\") {\n    return;\n  }\n\n  console.log(\"Loading parser...\");\n  var tags = document.getElementsByTagName(\"script\");\n  for (var i in tags) {\n    if (tags[i].src && tags[i].src.match(/\\/(qt|qmlweb)\\./)) {\n      var src = tags[i].src.replace(/\\/(qt|qmlweb)\\.(es201.\\.)?/, \"/qmlweb.parser.\");\n      // TODO: rewrite to async loading\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", src, false);\n      xhr.send(null);\n      if (xhr.status !== 200 && xhr.status !== 0) {\n        // xhr.status === 0 if accessing with file://\n        throw new Error(\"Could not load QmlWeb parser!\");\n      }\n      new Function(xhr.responseText)();\n      QmlWeb.parse = QmlWeb.parse;\n      QmlWeb.jsparse = QmlWeb.jsparse;\n      return;\n    }\n  }\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n  loadParser();\n  QmlWeb.parse.nowParsingFile = file;\n  var parsetree = QmlWeb.parse(src, QmlWeb.parse.QmlDocument);\n  return convertToEngine(parsetree);\n}\n\nQmlWeb.QMLMethod = QMLMethod;\nQmlWeb.QMLPropertyDefinition = QMLPropertyDefinition;\nQmlWeb.QMLAliasDefinition = QMLAliasDefinition;\nQmlWeb.QMLSignalDefinition = QMLSignalDefinition;\nQmlWeb.QMLMetaPropertyGroup = QMLMetaPropertyGroup;\nQmlWeb.QMLMetaElement = QMLMetaElement;\nQmlWeb.convertToEngine = convertToEngine;\nQmlWeb.loadParser = loadParser;\nQmlWeb.parseQML = parseQML;\n\n/*\r\n\r\nQmlWeb.qrc is analogous to the Qt Resource System. It is expected to map a path\r\nwithin the resource system to the following pieces of data:\r\n\r\n1) For a QML Component, it is the return value of QmlWeb.parse\r\n2) For a JavaScript file, it is the return value of QmlWeb.jsparse\r\n2) For an image, it is any URL that an <img> tag can accept (e.g. a standard\r\n   URL to an image resource, or a \"data:\" URI). If there is no entry for a\r\n   given qrc image path, it will fall back to passing the path right through to\r\n   the DOM. This is mainly a convenience until support for images is added to\r\n   gulp-qmlweb.\r\n\r\nThe \"data-qml\" tag on <body> can be set to a \"qrc://\" URL like\r\n\"qrc:///root.qml\" to use a pre-parsed \"/root.qml\" from QmlWeb.qrc.\r\n\r\nSince relative URLs are resolved relative to the URL of the containing\r\ncomponent, any relative URL set within a file in the resource system will also\r\nresolve within the resource system. To access a Component, JavaScript or image\r\nfile that is stored outside of the resources system from within the resource\r\nsystem, a full URL must be used (e.g. \"http://www.example.com/images/foo.png\").\r\n\r\nVice-versa, in order to access a Component, JavaScript or image file that is\r\nstored within the resource system from outside of the resource system, a full\r\n\"qrc://\" URL must be used (e.g. \"qrc:///images/foo.png\").\r\n\r\nMore details here: http://doc.qt.io/qt-5/qml-url.html\r\n\r\n*/\nQmlWeb.qrc = {};\n\nQmlWeb.registerQmlType({\n  module: \"QmlWeb.Dom\",\n  name: \"DomElement\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    tagName: { type: \"string\", initialValue: \"div\" }\n  }\n}, function () {\n  function _class(meta) {\n    _classCallCheck(this, _class);\n\n    meta.tagName = meta.object.tagName;\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: support properties, styles, perhaps changing the tagName\n  }\n\n  return _class;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QmlWeb\",\n  name: \"RestModel\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    url: \"string\",\n    isLoading: \"bool\",\n    mimeType: { type: \"string\", initialValue: \"application/json\" },\n    queryMimeType: {\n      type: \"string\",\n      initialValue: \"application/x-www-urlencoded\"\n    }\n  },\n  signals: {\n    fetched: [],\n    saved: []\n  }\n}, function () {\n  function _class2(meta) {\n    _classCallCheck(this, _class2);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.attributes = this.getAttributes();\n    this.runningRequests = 0;\n  }\n\n  _createClass(_class2, [{\n    key: \"fetch\",\n    value: function fetch() {\n      var _this19 = this;\n\n      this.$ajax({\n        method: \"GET\",\n        mimeType: this.mimetype,\n        success: function success(xhr) {\n          _this19.$xhrReadResponse(xhr);\n          _this19.fetched();\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this20 = this;\n\n      this.$ajax({\n        method: \"DELETE\",\n        success: function success() {\n          _this20.destroy();\n        }\n      });\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      this.$sendToServer(\"POST\");\n    }\n  }, {\n    key: \"save\",\n    value: function save() {\n      this.$sendToServer(\"PUT\");\n    }\n  }, {\n    key: \"$sendToServer\",\n    value: function $sendToServer(method) {\n      var _this21 = this;\n\n      this.$ajax({\n        method: method,\n        mimeType: this.queryMimeType,\n        body: this.$generateBodyForPostQuery(),\n        success: function success(xhr) {\n          _this21.$xhrReadResponse(xhr);\n          _this21.saved();\n        }\n      });\n    }\n  }, {\n    key: \"$generateBodyForPostQuery\",\n    value: function $generateBodyForPostQuery() {\n      var object = {};\n      for (var i = 0; i < this.attributes.length; ++i) {\n        object[this.attributes[i]] = this.$properties[this.attributes[i]].get();\n      }\n      console.log(object);\n      switch (this.queryMimeType) {\n        case \"application/json\":\n        case \"text/json\":\n          return JSON.stringify(object);\n        case \"application/x-www-urlencoded\":\n          return this.$objectToUrlEncoded(object);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"$objectToUrlEncoded\",\n    value: function $objectToUrlEncoded(object, prefix) {\n      var parts = [];\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = object[key];\n          if (typeof prefix !== \"undefined\") {\n            key = prefix + \"[\" + key + \"]\";\n          }\n          if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\") {\n            parts.push(this.$objectToUrlEncoded(value, key));\n          } else {\n            var ekey = this.$myEncodeURIComponent(key);\n            var evalue = this.$myEncodeURIComponent(value);\n            parts.push(ekey + \"=\" + evalue);\n          }\n        }\n      }\n      return parts.join(\"&\");\n    }\n  }, {\n    key: \"$myEncodeURIComponent\",\n    value: function $myEncodeURIComponent(str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return \"%\" + c.charCodeAt(0).toString(16);\n      });\n    }\n  }, {\n    key: \"$ajax\",\n    value: function $ajax(options) {\n      var _this22 = this;\n\n      var xhr = new XMLHttpRequest();\n      xhr.overrideMimeType(this.mimeType);\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          if (xhr.status === 200) {\n            options.success(xhr);\n          } else {\n            options.failure(xhr);\n          }\n          _this22.runningRequests -= 1;\n          if (_this22.runningRequests <= 0) {\n            _this22.isLoading = false;\n          }\n        }\n      };\n      xhr.open(options.method, this.url, true);\n      if (typeof options.body !== \"undefined\") {\n        xhr.setRequestHeader(\"Content-Type\", this.queryMimeType);\n        xhr.send(options.body);\n      } else {\n        xhr.send(null);\n      }\n      this.runningRequests += 1;\n      this.isLoading = true;\n    }\n  }, {\n    key: \"$xhrReadResponse\",\n    value: function $xhrReadResponse(xhr) {\n      var responseObject = void 0;\n      if (this.mimeType === \"application/json\" || this.mimeType === \"text/json\") {\n        responseObject = JSON.parse(xhr.responseText);\n      }\n      this.$updatePropertiesFromResponseObject(responseObject);\n    }\n  }, {\n    key: \"$updatePropertiesFromResponseObject\",\n    value: function $updatePropertiesFromResponseObject(responseObject) {\n      var QMLProperty = QmlWeb.QMLProperty;\n      for (var key in responseObject) {\n        if (responseObject.hasOwnProperty(key) && this.$hasProperty(key)) {\n          this.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n        }\n      }\n    }\n  }, {\n    key: \"$hasProperty\",\n    value: function $hasProperty(name) {\n      return typeof this.$properties[name] !== \"undefined\";\n    }\n  }]);\n\n  return _class2;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"Qt.labs.settings\",\n  name: \"Settings\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    category: \"string\"\n  }\n}, function () {\n  function _class3(meta) {\n    _classCallCheck(this, _class3);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (typeof window.localStorage === \"undefined\") {\n      return;\n    }\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class3, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$loadProperties();\n      this.$initializeProperties();\n    }\n  }, {\n    key: \"$getKey\",\n    value: function $getKey(attrName) {\n      return this.category + \"/\" + attrName;\n    }\n  }, {\n    key: \"$loadProperties\",\n    value: function $loadProperties() {\n      var _this23 = this;\n\n      this.$attributes.forEach(function (attrName) {\n        if (!_this23.$properties[attrName]) return;\n\n        var key = _this23.$getKey(attrName);\n        _this23[attrName] = localStorage.getItem(key);\n      });\n    }\n  }, {\n    key: \"$initializeProperties\",\n    value: function $initializeProperties() {\n      var _this24 = this;\n\n      this.$attributes.forEach(function (attrName) {\n        if (!_this24.$properties[attrName]) return;\n\n        var emitter = _this24;\n        var signalName = attrName + \"Changed\";\n\n        if (_this24.$properties[attrName].type === \"alias\") {\n          emitter = _this24.$context[_this24.$properties[attrName].val.objectName];\n          signalName = _this24.$properties[attrName].val.propertyName + \"Changed\";\n        }\n\n        emitter[signalName].connect(_this24, function () {\n          localStorage.setItem(_this24.$getKey(attrName), _this24[attrName]);\n        });\n      });\n    }\n  }]);\n\n  return _class3;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtBluetooth\",\n  name: \"BluetoothDiscoveryModel\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    BluetoothDiscoveryModel: {\n      FullServiceDiscovery: 1, MinimalServiceDiscovery: 0, DeviceDiscovery: 2,\n      NoError: 0, InputOutputError: 1, PoweredOffError: 2,\n      InvalidBluetoothAdapterError: 4, UnknownError: 3\n    }\n  },\n  properties: {\n    discoveryMode: { type: \"enum\", initialValue: 3 }, // MinimalServiceDiscovery\n    error: { type: \"enum\", initialValue: 0 }, // NoError\n    remoteAddress: \"string\",\n    running: \"bool\",\n    uuidFilter: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    deviceDiscovered: [{ type: \"string\", name: \"device\" }],\n    serviceDiscovered: [{ type: \"string\", name: \"device\" }]\n  }\n}, function () {\n  function _class4(meta) {\n    _classCallCheck(this, _class4);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implementation based on navigator.bluetooth\n  }\n\n  return _class4;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtGraphicalEffects\",\n  name: \"FastBlur\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    radius: \"real\",\n    source: { type: \"var\", initialValue: null }\n  }\n}, function () {\n  function _class5(meta) {\n    _classCallCheck(this, _class5);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$previousSource = null;\n    this.$filterObject = undefined;\n\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n  }\n\n  _createClass(_class5, [{\n    key: \"$onRadiusChanged\",\n    value: function $onRadiusChanged() {\n      this.$updateEffect(this.source);\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged() {\n      this.$updateEffect(this.source);\n    }\n  }, {\n    key: \"$updateFilterObject\",\n    value: function $updateFilterObject() {\n      this.$filterObject = {\n        transformType: \"filter\",\n        operation: \"blur\",\n        parameters: this.radius + \"px\"\n      };\n    }\n  }, {\n    key: \"$updateEffect\",\n    value: function $updateEffect(source) {\n      console.log(\"updating effect\");\n      if (this.$previousSource) {\n        var index = this.$previousSource.transform.indexOf(this.$filterObject);\n        this.$previousSource.transform.splice(index, 1);\n        this.$previousSource.$updateTransform();\n      }\n      if (source && source.transform) {\n        this.$updateFilterObject();\n        console.log(\"updating effect:\", this.$filterObject, source);\n        source.transform.push(this.$filterObject);\n        source.$updateTransform();\n        this.$previousSource = source;\n      } else {\n        this.$previousSource = null;\n      }\n    }\n  }]);\n\n  return _class5;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtGraphicalEffects\",\n  name: \"RectangularGlow\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    cached: \"bool\",\n    color: { type: \"color\", initialValue: \"white\" },\n    cornerRadius: \"real\",\n    glowRadius: \"real\",\n    spread: \"real\"\n  }\n}, function () {\n  function _class6(meta) {\n    _classCallCheck(this, _class6);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.impl = document.createElement(\"div\");\n    var style = this.impl.style;\n    style.pointerEvents = \"none\";\n    style.position = \"absolute\";\n    style.left = style.right = style.top = style.bottom = \"0px\";\n    style.border = \"none\";\n    style.backgroundColor = this.color.$css;\n    this.dom.appendChild(this.impl);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.glowRadiusChanged.connect(this, this.$updateBoxShadow);\n    this.cornerRadiusChanged.connect(this, this.$updateBoxShadow);\n    this.widthChanged.connect(this, this.$updateBoxShadow);\n    this.heightChanged.connect(this, this.$updateBoxShadow);\n    this.spreadChanged.connect(this, this.$onSpreadChanged);\n  }\n\n  _createClass(_class6, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.backgroundColor = newVal.$css;\n      this.$updateBoxShadow();\n    }\n  }, {\n    key: \"$onSpreadChanged\",\n    value: function $onSpreadChanged(newVal) {\n      if (newVal > 1) {\n        this.spread = 1;\n      } else if (newVal < 0) {\n        this.spread = 0;\n      }\n      this.$updateBoxShadow();\n    }\n  }, {\n    key: \"$updateBoxShadow\",\n    value: function $updateBoxShadow() {\n      var color = this.color,\n          glowRadius = this.glowRadius,\n          cornerRadius = this.cornerRadius,\n          spread = this.spread,\n          width = this.width,\n          height = this.height;\n\n      var style = this.impl.style;\n\n      // Calculate boxShadow\n      var totle = glowRadius + cornerRadius * (1 - spread);\n      var glow = (1 - spread) * totle;\n      var blur_radius = glow * 0.64;\n      var spread_radius = totle - blur_radius;\n      var glow2 = glowRadius / 5;\n      var blur_radius_2 = glow2 * 0.8;\n      var spread_radius_2 = glow2 - blur_radius_2;\n\n      style.boxShadow = color + \" 0px 0px \" + blur_radius + \"px \" + spread_radius + \"px,\" + (color + \" 0px 0px \" + blur_radius_2 + \"px \" + spread_radius_2 + \"px\");\n\n      // Calculate glow css\n      var spread_cornerR = cornerRadius * (1 - spread);\n      var rest_cornerR = cornerRadius - spread_cornerR;\n      var xScale = (width - spread_cornerR / 4) / width;\n      var yScale = (height - spread_cornerR / 4) / height;\n\n      style.width = width - spread_cornerR + \"px\";\n      style.height = height - spread_cornerR + \"px\";\n      style.top = spread_cornerR / 2 + \"px\";\n      style.left = spread_cornerR / 2 + \"px\";\n      style.filter = \"blur(\" + spread_cornerR / 2 + \"px)\";\n      style.borderRadius = rest_cornerR / 2 + \"px\";\n      style.transform = \"scale(\" + xScale + \",\" + yScale + \")\";\n    }\n  }]);\n\n  return _class6;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMobility\",\n  name: \"GeoLocation\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    accuracy: \"double\",\n    altitude: \"double\",\n    altitudeAccuracy: \"double\",\n    heading: \"double\",\n    latitude: \"double\",\n    longitude: \"double\",\n    speed: \"double\",\n    timestamp: \"date\",\n    label: \"string\"\n  }\n}, function () {\n  function _class7(meta) {\n    var _this25 = this;\n\n    _classCallCheck(this, _class7);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (!navigator.geolocation) {\n      return;\n    }\n\n    navigator.geolocation.getCurrentPosition(function (pos) {\n      return _this25.$updatePosition(pos);\n    });\n    navigator.geolocation.watchPosition(function (pos) {\n      return _this25.$updatePosition(pos);\n    });\n  }\n\n  _createClass(_class7, [{\n    key: \"$updatePosition\",\n    value: function $updatePosition(position) {\n      this.accuracy = position.coords.accuracy;\n      this.altitude = position.coords.altitude;\n      this.altitudeAccuracy = position.coords.altitudeAccuracy;\n      this.heading = position.coords.heading;\n      this.latitude = position.coords.latitude;\n      this.longitude = position.coords.longitude;\n      this.speed = position.coords.speed;\n      this.timestamp = position.timestamp;\n    }\n  }]);\n\n  return _class7;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Audio\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Audio: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // Audio.Available\n    duration: \"int\",\n    error: \"enum\", // Audio.NoError\n    errorString: \"string\",\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    loops: { type: \"int\", initialValue: 1 },\n    mediaObject: \"var\",\n    // TODO: metaData\n    muted: \"bool\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // Audio.StoppedState\n    playlinst: \"Playlist\",\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // Audio.NoMedia\n    volume: { type: \"real\", initialValue: 1 }\n  },\n  signals: {\n    error: [{ type: \"enum\", name: \"error\" }, { type: \"string\", name: \"errorString\" }],\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class8(meta) {\n    _classCallCheck(this, _class8);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class8, [{\n    key: \"pause\",\n    value: function pause() {\n      // TODO\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      // TODO\n    }\n  }, {\n    key: \"seek\",\n    value: function seek() /* offset */{\n      // TODO\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // TODO\n    }\n  }, {\n    key: \"supportedAudioRoles\",\n    value: function supportedAudioRoles() {\n      // TODO\n    }\n  }]);\n\n  return _class8;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Camera\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Camera: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      UnloadedState: 0, LoadedState: 1, ActiveState: 2\n    }\n  },\n  properties: {\n    availability: \"enum\", // Camera.Available\n    cameraState: { type: \"enum\", initialValue: 2 }, // Camera.ActiveState\n    cameraStatus: \"enum\", // TODO\n    captureMode: \"enum\", // TODO\n    deviceId: \"string\",\n    digitalZoom: { type: \"real\", initialValue: 1 },\n    displayName: \"string\",\n    errorCode: \"enum\", // TODO\n    errorString: \"string\",\n    lockStatus: \"enum\", // TODO\n    maximumDigitalZoom: \"real\",\n    maximumOpticalZoom: \"real\",\n    opticalZoom: { type: \"real\", initialValue: 1 },\n    orientation: \"int\",\n    position: \"enum\" },\n  signals: {\n    error: [{ type: \"enum\", name: \"errorCode\" }, { type: \"string\", name: \"errorString\" }]\n  }\n}, function () {\n  function _class9(meta) {\n    _classCallCheck(this, _class9);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class9;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"MediaPlayer\",\n  versions: /^5\\./,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    MediaPlayer: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // MediaPlayer.Available\n    bufferProgress: \"real\",\n    duration: \"int\",\n    error: \"enum\", // MediaPlayer.NoError\n    errorString: \"string\",\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    loops: \"int\",\n    muted: \"bool\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // MediaPlayer.StoppedState\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // MediaPlayer.NoMedia\n    volume: \"real\"\n  },\n  signals: {\n    error: [{ type: \"enum\", name: \"error\" }, { type: \"string\", name: \"errorString\" }],\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class10(meta) {\n    _classCallCheck(this, _class10);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class10;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"Video\",\n  versions: /^5\\./,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    MediaPlayer: {\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\n\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\n      AccessDenied: 8, ServiceMissing: 16,\n\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\n\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n    },\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\n  },\n  properties: {\n    audioRole: \"enum\", // TODO\n    autoLoad: { type: \"bool\", initialValue: true },\n    autoPlay: \"bool\",\n    availability: \"enum\", // MediaPlayer.Available\n    bufferProgress: \"real\",\n    duration: \"int\",\n    error: \"enum\", // MediaPlayer.NoError\n    errorString: \"string\",\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\n    hasAudio: \"bool\",\n    hasVideo: \"bool\",\n    muted: \"bool\",\n    orientation: \"int\",\n    playbackRate: { type: \"real\", initialValue: 1 },\n    playbackState: \"enum\", // MediaPlayer.StoppedState\n    position: \"int\",\n    seekable: \"bool\",\n    source: \"url\",\n    status: \"enum\", // MediaPlayer.NoMedia\n    volume: \"real\"\n  },\n  signals: {\n    paused: [],\n    playing: [],\n    stopped: []\n  }\n}, function () {\n  function _class11(meta) {\n    var _this26 = this;\n\n    _classCallCheck(this, _class11);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningEventListener = 0;\n\n    this.impl = document.createElement(\"video\");\n    this.impl.style.width = this.impl.style.height = \"100%\";\n    this.impl.style.margin = \"0\";\n    this.dom.appendChild(this.impl);\n\n    this.volume = this.impl.volume;\n    this.duration = this.impl.duration;\n\n    this.impl.addEventListener(\"play\", function () {\n      _this26.playing();\n      _this26.playbackState = _this26.MediaPlayer.PlayingState;\n    });\n\n    this.impl.addEventListener(\"pause\", function () {\n      _this26.paused();\n      _this26.playbackState = _this26.MediaPlayer.PausedState;\n    });\n\n    this.impl.addEventListener(\"timeupdate\", function () {\n      _this26.$runningEventListener++;\n      _this26.position = _this26.impl.currentTime * 1000;\n      _this26.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"ended\", function () {\n      _this26.stopped();\n      _this26.playbackState = _this26.MediaPlayer.StoppedState;\n    });\n\n    this.impl.addEventListener(\"progress\", function () {\n      if (_this26.impl.buffered.length > 0) {\n        _this26.progress = _this26.impl.buffered.end(0) / _this26.impl.duration;\n        _this26.status = _this26.progress < 1 ? _this26.MediaPlayer.Buffering : _this26.MediaPlayer.Buffered;\n      }\n    });\n\n    this.impl.addEventListener(\"stalled\", function () {\n      _this26.status = _this26.MediaPlayer.Stalled;\n    });\n\n    this.impl.addEventListener(\"canplaythrough\", function () {\n      _this26.status = _this26.MediaPlayer.Buffered;\n    });\n\n    this.impl.addEventListener(\"loadstart\", function () {\n      _this26.status = _this26.MediaPlayer.Loading;\n    });\n\n    this.impl.addEventListener(\"durationchanged\", function () {\n      _this26.duration = _this26.impl.duration;\n    });\n\n    this.impl.addEventListener(\"volumechanged\", function () {\n      _this26.$runningEventListener++;\n      _this26.volume = _this26.impl.volume;\n      _this26.$runningEventListener--;\n    });\n\n    this.impl.addEventListener(\"suspend\", function () {\n      _this26.error |= _this26.MediaPlayer.NetworkError;\n    });\n\n    this.impl.addEventListener(\"error\", function () {\n      _this26.error |= _this26.MediaPlayer.ResourceError;\n    });\n\n    this.impl.addEventListener(\"ratechange\", function () {\n      _this26.$runningEventListener++;\n      _this26.playbackRate = _this26.impl.playbackRate;\n      _this26.$runningEventListener--;\n    });\n\n    this.autoPlayChanged.connect(this, this.$onAutoPlayChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.positionChanged.connect(this, this.$onPositionChanged);\n    this.volumeChanged.connect(this, this.$onVolumeChanged);\n    this.playbackRateChanged.connect(this, this.$onPlaybackRateChanged);\n    this.mutedChanged.connect(this, this.$onMutedChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n  }\n\n  _createClass(_class11, [{\n    key: \"$onAutoPlayChanged\",\n    value: function $onAutoPlayChanged(newVal) {\n      this.impl.autoplay = newVal;\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      var parts = source.split(\".\");\n      var extension = parts[parts.length - 1].toLowerCase();\n      var mime = this.mimetypeFromExtension(extension);\n      this.impl.src = source;\n      if (!this.impl.canPlayType(mime)) {\n        this.error |= this.MediaPlayer.FormatError;\n      }\n    }\n  }, {\n    key: \"$onPositionChanged\",\n    value: function $onPositionChanged(currentTime) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.currentTime = currentTime / 1000;\n    }\n  }, {\n    key: \"$onVolumeChanged\",\n    value: function $onVolumeChanged(volume) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.volume = volume;\n    }\n  }, {\n    key: \"$onPlaybackRateChanged\",\n    value: function $onPlaybackRateChanged(playbackRate) {\n      if (this.$runningEventListener > 0) return;\n      this.impl.playbackRate = playbackRate;\n    }\n  }, {\n    key: \"$onMutedChanged\",\n    value: function $onMutedChanged(newValue) {\n      if (newValue) {\n        this.$volulmeBackup = this.impl.volume;\n        this.volume = 0;\n      } else {\n        this.volume = this.$volumeBackup;\n      }\n    }\n  }, {\n    key: \"$onFillModeChanged\",\n    value: function $onFillModeChanged(newValue) {\n      switch (newValue) {\n        case this.VideoOutput.Stretch:\n          this.impl.style.objectFit = \"fill\";\n          break;\n        case this.VideoOutput.PreserveAspectFit:\n          this.impl.style.objectFit = \"\";\n          break;\n        case this.VideoOutput.PreserveAspectCrop:\n          this.impl.style.objectFit = \"cover\";\n          break;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.impl.pause();\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      this.impl.play();\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(offset) {\n      this.impl.currentTime = offset * 1000;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"mimetypeFromExtension\",\n    value: function mimetypeFromExtension(extension) {\n      var mimetypes = {\n        ogg: \"video/ogg\",\n        ogv: \"video/ogg\",\n        ogm: \"video/ogg\",\n        mp4: \"video/mp4\",\n        webm: \"video/webm\"\n      };\n      return mimetypes[extension] || \"\";\n    }\n  }]);\n\n  return _class11;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtMultimedia\",\n  name: \"VideoOutput\",\n  versions: /^5\\./,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\n  },\n  properties: {\n    autoOrientation: \"bool\",\n    contentRect: \"rect\",\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\n    filters: \"list\",\n    orientation: \"int\",\n    source: \"variant\",\n    sourceRect: \"rect\"\n  }\n}, function () {\n  function _class12(meta) {\n    _classCallCheck(this, _class12);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: impl\n  }\n\n  return _class12;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtNfc\",\n  name: \"NearField\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    filter: \"list\",\n    messageRecords: \"list\",\n    orderMatch: \"bool\",\n    polling: \"bool\"\n  },\n  signals: {\n    tagFound: [],\n    tagRemoved: []\n  }\n}, function () {\n  function _class13(meta) {\n    _classCallCheck(this, _class13);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implementation based on Web NFC API\n  }\n\n  return _class13;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml.Modules\",\n  name: \"ListElement\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.ListElement\"\n}, function () {\n  function _class14(meta) {\n    _classCallCheck(this, _class14);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class14;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml.Modules\",\n  name: \"ListModel\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.ListModel\",\n  defaultProperty: \"$items\"\n}, function () {\n  function _class15(meta) {\n    _classCallCheck(this, _class15);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class15;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Binding\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: { type: \"QtObject\", initialValue: null },\n    property: { type: \"string\", initialValue: \"\" },\n    value: { type: \"var\", initialValue: undefined },\n    when: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class16(meta) {\n    _classCallCheck(this, _class16);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$property = undefined;\n\n    this.valueChanged.connect(this, this.$onValueChanged);\n    this.targetChanged.connect(this, this.$updateBinding);\n    this.propertyChanged.connect(this, this.$updateBinding);\n    this.whenChanged.connect(this, this.$updateBinding);\n  }\n\n  _createClass(_class16, [{\n    key: \"$updateBinding\",\n    value: function $updateBinding() {\n      if (!this.when || !this.target || !this.target.hasOwnProperty(this.property) || this.value === undefined) {\n        this.$property = undefined;\n        return;\n      }\n      this.$property = this.target.$properties[this.property];\n      this.$onValueChanged(this.value); // trigger value update\n    }\n  }, {\n    key: \"$onValueChanged\",\n    value: function $onValueChanged(value) {\n      if (value !== undefined && this.$property) {\n        this.$property.set(value);\n      }\n    }\n  }]);\n\n  return _class16;\n}());\n\nvar QMLContext = function () {\n  function QMLContext() {\n    _classCallCheck(this, QMLContext);\n  }\n\n  _createClass(QMLContext, [{\n    key: \"nameForObject\",\n    value: function nameForObject(obj) {\n      for (var name in this) {\n        if (this[name] === obj) {\n          return name;\n        }\n      }\n      return undefined;\n    }\n  }]);\n\n  return QMLContext;\n}();\n\nvar QMLComponent = function () {\n  function QMLComponent(meta) {\n    var _this27 = this;\n\n    _classCallCheck(this, QMLComponent);\n\n    if (QmlWeb.constructors[meta.object.$class] === QMLComponent) {\n      this.$metaObject = meta.object.$children[0];\n    } else {\n      this.$metaObject = meta.object;\n    }\n    this.$context = meta.context;\n\n    this.$jsImports = [];\n\n    if (meta.object.$imports instanceof Array) {\n      var moduleImports = [];\n      var loadImport = function loadImport(importDesc) {\n        if (/\\.js$/.test(importDesc[1])) {\n          _this27.$jsImports.push(importDesc);\n        } else {\n          moduleImports.push(importDesc);\n        }\n      };\n\n      for (var i = 0; i < meta.object.$imports.length; ++i) {\n        loadImport(meta.object.$imports[i]);\n      }\n      QmlWeb.loadImports(this, moduleImports);\n    }\n\n    /* If this Component does not have any imports, it is likely one that was\r\n     * created within another Component file. It should inherit the\r\n     * importContextId of the Component file it was created within. */\n    if (this.importContextId === undefined) {\n      this.importContextId = meta.context.importContextId;\n    }\n  }\n\n  _createClass(QMLComponent, [{\n    key: \"finalizeImports\",\n    value: function finalizeImports($context) {\n      var engine = QmlWeb.engine;\n      for (var i = 0; i < this.$jsImports.length; ++i) {\n        var importDesc = this.$jsImports[i];\n        var js = engine.loadJS(engine.$resolvePath(importDesc[1]));\n\n        if (!js) {\n          console.log(\"Component.finalizeImports: failed to import JavaScript\", importDesc[1]);\n          continue;\n        }\n\n        if (importDesc[3] !== \"\") {\n          $context[importDesc[3]] = {};\n          QmlWeb.importJavascriptInContext(js, $context[importDesc[3]]);\n        } else {\n          QmlWeb.importJavascriptInContext(js, $context);\n        }\n      }\n    }\n  }, {\n    key: \"$createObject\",\n    value: function $createObject(parent) {\n      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.$context;\n\n      var engine = QmlWeb.engine;\n      var oldState = engine.operationState;\n      engine.operationState = QmlWeb.QMLOperationState.Init;\n      // change base path to current component base path\n      var bp = engine.$basePath;\n      engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n      var newContext = context ? Object.create(context) : new QMLContext();\n\n      if (this.importContextId !== undefined) {\n        newContext.importContextId = this.importContextId;\n      }\n\n      var item = QmlWeb.construct({\n        object: this.$metaObject,\n        parent: parent,\n        context: newContext,\n        isComponentRoot: true\n      });\n\n      this.finalizeImports(item.$context);\n\n      Object.keys(properties).forEach(function (propname) {\n        item[propname] = properties.propname;\n      });\n\n      // change base path back\n      // TODO looks a bit hacky\n      engine.$basePath = bp;\n\n      engine.operationState = oldState;\n      return item;\n    }\n  }, {\n    key: \"createObject\",\n    value: function createObject(parent) {\n      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var item = this.$createObject(parent, properties);\n      var QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n\n      if (item instanceof QMLItem) {\n        item.$properties.parent.set(parent, QmlWeb.QMLProperty.ReasonInit);\n      }\n\n      return item;\n    }\n  }], [{\n    key: \"getAttachedObject\",\n    value: function getAttachedObject() {\n      // see QMLEngine.js for explanation how it is used.\n      if (!this.$Component) {\n        this.$Component = new QmlWeb.QObject(this);\n        this.$Component.completed = QmlWeb.Signal.signal([]);\n        QmlWeb.engine.completedSignals.push(this.$Component.completed);\n\n        this.$Component.destruction = QmlWeb.Signal.signal([]);\n      }\n      return this.$Component;\n    }\n  }]);\n\n  return QMLComponent;\n}();\n\nQmlWeb.registerQmlType({\n  global: true,\n  module: \"QtQml\",\n  name: \"Component\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  constructor: QMLComponent\n});\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Connections\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    target: \"QtObject\",\n    ignoreUnknownSignals: \"bool\"\n  }\n}, function () {\n  function _class17(meta) {\n    _classCallCheck(this, _class17);\n\n    QmlWeb.callSuper(this, meta);\n    this.target = this.$parent;\n    this.$connections = {};\n\n    this.$old_target = this.target;\n    this.targetChanged.connect(this, this.$onTargetChanged);\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class17, [{\n    key: \"$onTargetChanged\",\n    value: function $onTargetChanged() {\n      this.$reconnectTarget();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$reconnectTarget();\n    }\n  }, {\n    key: \"$reconnectTarget\",\n    value: function $reconnectTarget() {\n      var old_target = this.$old_target;\n      for (var i in this.$connections) {\n        var c = this.$connections[i];\n        if (c._currentConnection && old_target && old_target[i] && typeof old_target[i].disconnect === \"function\") {\n          old_target[i].disconnect(c._currentConnection);\n        }\n        if (this.target) {\n          c._currentConnection = QmlWeb.connectSignal(this.target, i, c.value, c.objectScope, c.componentScope);\n        }\n      }\n      this.$old_target = this.target;\n    }\n  }, {\n    key: \"$setCustomSlot\",\n    value: function $setCustomSlot(propName, value, objectScope, componentScope) {\n      this.$connections[propName] = { value: value, objectScope: objectScope, componentScope: componentScope };\n    }\n  }]);\n\n  return _class17;\n}());\n\n// Base object for all qml elements\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"QtObject\",\n  versions: /.*/\n}, function (_QmlWeb$QObject10) {\n  _inherits(_class18, _QmlWeb$QObject10);\n\n  function _class18(meta) {\n    _classCallCheck(this, _class18);\n\n    var _this28 = _possibleConstructorReturn(this, (_class18.__proto__ || Object.getPrototypeOf(_class18)).call(this, meta.parent));\n\n    _this28.$isComponentRoot = meta.isComponentRoot;\n    _this28.$context = meta.context;\n\n    // Component get own properties\n    _this28.$attributes = [];\n    for (var key in meta.object) {\n      if (!meta.object.hasOwnProperty(key) || !meta.object[key]) {\n        continue;\n      }\n      var name = meta.object[key].__proto__.constructor.name;\n      if (name === \"QMLPropertyDefinition\" || name === \"QMLAliasDefinition\") {\n        _this28.$attributes.push(key);\n      }\n    }\n\n    var Signal = QmlWeb.Signal;\n\n    _this28.Keys = new QmlWeb.QObject(_this28);\n    _this28.Keys.asteriskPresed = Signal.signal();\n    _this28.Keys.backPressed = Signal.signal();\n    _this28.Keys.backtabPressed = Signal.signal();\n    _this28.Keys.callPressed = Signal.signal();\n    _this28.Keys.cancelPressed = Signal.signal();\n    _this28.Keys.deletePressed = Signal.signal();\n    for (var i = 0; i < 10; ++i) {\n      _this28.Keys[\"digit\" + i + \"Pressed\"] = Signal.signal();\n    }\n    _this28.Keys.escapePressed = Signal.signal();\n    _this28.Keys.flipPressed = Signal.signal();\n    _this28.Keys.hangupPressed = Signal.signal();\n    _this28.Keys.leftPressed = Signal.signal();\n    _this28.Keys.menuPressed = Signal.signal();\n    _this28.Keys.noPressed = Signal.signal();\n    _this28.Keys.pressed = Signal.signal();\n    _this28.Keys.released = Signal.signal();\n    _this28.Keys.returnPressed = Signal.signal();\n    _this28.Keys.rightPressed = Signal.signal();\n    _this28.Keys.selectPressed = Signal.signal();\n    _this28.Keys.spacePressed = Signal.signal();\n    _this28.Keys.tabPressed = Signal.signal();\n    _this28.Keys.upPressed = Signal.signal();\n    _this28.Keys.volumeDownPressed = Signal.signal();\n    _this28.Keys.volumeUpPressed = Signal.signal();\n    _this28.Keys.yesPressed = Signal.signal();\n    return _this28;\n  }\n\n  _createClass(_class18, [{\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.$attributes;\n    }\n  }]);\n\n  return _class18;\n}(QmlWeb.QObject));\n\nQmlWeb.registerQmlType({\n  module: \"QtQml\",\n  name: \"Timer\",\n  versions: /.*/,\n  baseClass: \"QtObject\",\n  properties: {\n    interval: { type: \"int\", initialValue: 1000 },\n    parent: { type: \"QtObject\", readOnly: true },\n    repeat: \"bool\",\n    running: \"bool\",\n    triggeredOnStart: \"bool\"\n  },\n  signals: {\n    triggered: []\n  }\n}, function () {\n  function _class19(meta) {\n    var _this29 = this;\n\n    _classCallCheck(this, _class19);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$properties.parent.set(this.$parent, QmlWeb.QMLProperty.ReasonInit);\n\n    /* This ensures that if the user toggles the \"running\" property manually,\r\n     * the timer will trigger. */\n    this.runningChanged.connect(this, this.$onRunningChanged);\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this29.$ticker.apply(_this29, arguments);\n    });\n\n    QmlWeb.engine.$registerStart(function () {\n      if (_this29.running) {\n        _this29.restart();\n      }\n    });\n\n    QmlWeb.engine.$registerStop(function () {\n      return _this29.stop();\n    });\n  }\n\n  _createClass(_class19, [{\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.stop();\n      this.start();\n    }\n  }, {\n    key: \"$ticker\",\n    value: function $ticker(now) {\n      if (!this.running) return;\n      if (now - this.$prevTrigger >= this.interval) {\n        this.$prevTrigger = now;\n        this.$trigger();\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged() {\n      if (this.running) {\n        this.$prevTrigger = Date.now();\n        if (this.triggeredOnStart) {\n          this.$trigger();\n        }\n      }\n    }\n  }, {\n    key: \"$trigger\",\n    value: function $trigger() {\n      if (!this.repeat) {\n        // We set the value directly in order to be able to emit the\n        // runningChanged signal after triggered, like Qt does it.\n        this.$properties.running.val = false;\n      }\n\n      // Trigger this.\n      this.triggered();\n\n      if (!this.repeat) {\n        // Emit changed signal manually after setting the value manually above.\n        this.runningChanged();\n      }\n    }\n  }]);\n\n  return _class19;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ApplicationWindow\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Window.Window\",\n  properties: {\n    font: \"font\",\n    activeFocusControl: \"Control\",\n    background: \"Item\",\n    contentData: \"list\",\n    //contentItem: \"ContentItem\", // TODO\n    footer: \"Item\",\n    header: \"Item\",\n    overlay: \"Item\"\n  }\n}, function () {\n  function _class20(meta) {\n    _classCallCheck(this, _class20);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class20;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ApplicationWindow\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Window.Window\",\n  properties: {\n    //contentItem: \"ContentItem\", // TODO\n    menuBar: \"MenuBar\",\n    statusBar: \"Item\",\n    style: \"Component\",\n    toolBar: \"Item\"\n  }\n}, function () {\n  function _class21(meta) {\n    _classCallCheck(this, _class21);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class21;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"Button\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  signals: {\n    clicked: []\n  }\n}, function () {\n  function _class22(meta) {\n    var _this30 = this;\n\n    _classCallCheck(this, _class22);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n\n    var button = this.impl = document.createElement(\"button\");\n    button.style.pointerEvents = \"auto\";\n    this.dom.appendChild(button);\n\n    button.onclick = function () {\n      _this30.clicked();\n    };\n  }\n\n  _createClass(_class22, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.textContent = newVal;\n      //TODO: Replace those statically sized borders\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onEnabledChanged\",\n    value: function $onEnabledChanged(newVal) {\n      this.impl.disabled = !newVal;\n    }\n  }]);\n\n  return _class22;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"CheckBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    checked: \"bool\",\n    color: \"color\"\n  }\n}, function () {\n  function _class23(meta) {\n    var _this31 = this;\n\n    _classCallCheck(this, _class23);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.impl = document.createElement(\"label\");\n    this.impl.style.pointerEvents = \"auto\";\n\n    var checkbox = document.createElement(\"input\");\n    checkbox.type = \"checkbox\";\n    checkbox.style.verticalAlign = \"text-bottom\";\n    checkbox.addEventListener(\"change\", function () {\n      _this31.checked = checkbox.checked;\n    });\n    this.impl.appendChild(checkbox);\n\n    var span = document.createElement(\"span\");\n    this.impl.appendChild(span);\n\n    this.dom.appendChild(this.impl);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.checkedChanged.connect(this, this.$onCheckedChanged);\n  }\n\n  _createClass(_class23, [{\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.children[1].innerHTML = newVal;\n      this.implicitHeight = this.impl.offsetHeight;\n      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.children[1].style.color = newVal.$css;\n    }\n  }, {\n    key: \"$onCheckedChanged\",\n    value: function $onCheckedChanged() {\n      this.impl.children[0].checked = this.checked;\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitHeight = this.impl.offsetHeight;\n      this.implicitWidth = this.impl.offsetWidth > 0 ? this.impl.offsetWidth + 4 : 0;\n    }\n  }]);\n\n  return _class23;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ComboBox\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    count: \"int\",\n    currentIndex: \"int\",\n    currentText: \"string\",\n    menu: { type: \"array\", initialValue: [] },\n    model: { type: \"array\", initialValue: [] },\n    pressed: \"bool\"\n  },\n  signals: {\n    accepted: [],\n    activated: [{ type: \"int\", name: \"index\" }]\n  }\n}, function () {\n  function _class24(meta) {\n    var _this32 = this;\n\n    _classCallCheck(this, _class24);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    // TODO change innerHTML to DOM\n    this.dom.innerHTML = \"<select></select>\";\n    this.impl = this.dom.firstChild;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.modelChanged.connect(this, this.$onModelChanged);\n    this.currentIndexChanged.connect(this, this.$onCurrentIndexChanged);\n    this.heightChanged.connect(this, this.$onHeightChanged);\n    this.widthChanged.connect(this, this.$onWidthChanged);\n\n    this.dom.onclick = function () {\n      var index = _this32.dom.firstChild.selectedIndex;\n      _this32.currentIndex = index;\n      _this32.currentText = _this32.model[index];\n      _this32.accepted();\n      _this32.activated(index);\n    };\n  }\n\n  _createClass(_class24, [{\n    key: \"find\",\n    value: function find(text) {\n      return this.model.indexOf(text);\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      // TODO\n    }\n  }, {\n    key: \"textAt\",\n    value: function textAt(index) {\n      return this.model[index];\n    }\n  }, {\n    key: \"$updateImpl\",\n    value: function $updateImpl() {\n      this.count = this.model.length;\n\n      var k = this.count;var m = this.model;\n\n      this.impl.options.length = k;\n      for (var i = 0; i < k; i++) {\n        this.impl.options[i] = new Option(m[i]);\n      }\n\n      // should call this, because width()/heights() invoke updateV(H)Geometry,\n      // which in turn sets valid $useImplicitHeight flag\n      var h = this.height;var w = this.width;\n\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n\n      this.$onHeightChanged(h);\n      this.$onWidthChanged(w);\n\n      this.impl.selectedIndex = this.currentIndex;\n      this.$updateCurrentText();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$updateImpl();\n    }\n  }, {\n    key: \"$onModelChanged\",\n    value: function $onModelChanged() {\n      this.$updateImpl();\n    }\n  }, {\n    key: \"$onCurrentIndexChanged\",\n    value: function $onCurrentIndexChanged() {\n      var i = this.currentIndex;\n      if (this.impl.selectedIndex !== i) {\n        this.impl.selectedIndex = i;\n        this.$updateCurrentText();\n        this.activated(i);\n      }\n    }\n  }, {\n    key: \"$updateCurrentText\",\n    value: function $updateCurrentText() {\n      if (typeof this.currentIndex === \"undefined\" || !this.model) {\n        this.currentText = undefined;\n      } else if (this.currentIndex >= 0 && this.currentIndex < this.model.length) {\n        this.currentText = this.model[this.currentIndex];\n      }\n    }\n  }, {\n    key: \"$onHeightChanged\",\n    value: function $onHeightChanged() {\n      if (this.height > 0 && this.impl && this.height !== this.impl.offsetHeight) {\n        this.impl.style.height = this.height + \"px\";\n      }\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged() {\n      if (this.width > 0 && this.impl && this.width !== this.impl.offsetWidth) {\n        this.impl.style.width = this.width + \"px\";\n      }\n    }\n  }]);\n\n  return _class24;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"ScrollView\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    contentItem: \"Item\",\n    flickableItem: \"Item\", // TODO  0) implement it  1) make it read-only\n    viewport: \"Item\", // TODO\n    frameVisible: \"bool\",\n    highlightOnFocus: \"bool\", // TODO test\n    verticalScrollBarPolicy: \"enum\",\n    horizontalScrollBarPolicy: \"enum\",\n    style: \"Component\" // TODO\n  },\n  defaultProperty: \"contentItem\"\n}, function () {\n  function _class25(meta) {\n    _classCallCheck(this, _class25);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    this.contentItemChanged.connect(this, this.$onContentItemChanged);\n    this.flickableItemChanged.connect(this, this.$onFlickableItemChanged);\n    this.viewportChanged.connect(this, this.$onViewportChanged);\n    this.frameVisibleChanged.connect(this, this.$onFrameVisibleChanged);\n    this.highlightOnFocusChanged.connect(this, this.$onHighlightOnFocusChanged);\n    this.horizontalScrollBarPolicyChanged.connect(this, this.$onHorizontalScrollBarPolicyChanged);\n    this.verticalScrollBarPolicyChanged.connect(this, this.$onVerticalScrollBarPolicyChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.focusChanged.connect(this, this.$onFocusChanged);\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    var Qt = QmlWeb.Qt;\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n\n    this.$onVerticalScrollBarPolicyChanged(this.verticalScrollBarPolicy);\n    this.$onHorizontalScrollBarPolicyChanged(this.horizontalScrollBarPolicy);\n  }\n\n  _createClass(_class25, [{\n    key: \"$onContentItemChanged\",\n    value: function $onContentItemChanged(newItem) {\n      if ((typeof newItem === \"undefined\" ? \"undefined\" : _typeof(newItem)) !== undefined) {\n        newItem.parent = this;\n      }\n    }\n  }, {\n    key: \"$onFlickableItemChanged\",\n    value: function $onFlickableItemChanged() {}\n  }, {\n    key: \"$onHighlightOnFocusChanged\",\n    value: function $onHighlightOnFocusChanged() {}\n  }, {\n    key: \"$onViewportChanged\",\n    value: function $onViewportChanged() {}\n  }, {\n    key: \"$onFocusChanged\",\n    value: function $onFocusChanged(focus) {\n      this.css.outline = this.highlight && focus ? \"outline: lightblue solid 2px;\" : \"\";\n    }\n  }, {\n    key: \"$onFrameVisibleChanged\",\n    value: function $onFrameVisibleChanged(visible) {\n      this.css.border = visible ? \"1px solid gray\" : \"hidden\";\n    }\n  }, {\n    key: \"$onHorizontalScrollBarPolicyChanged\",\n    value: function $onHorizontalScrollBarPolicyChanged(newPolicy) {\n      this.css.overflowX = this.$scrollBarPolicyToCssOverflow(newPolicy);\n    }\n  }, {\n    key: \"$onVerticalScrollBarPolicyChanged\",\n    value: function $onVerticalScrollBarPolicyChanged(newPolicy) {\n      this.css.overflowY = this.$scrollBarPolicyToCssOverflow(newPolicy);\n    }\n  }, {\n    key: \"$onStyleChanged\",\n    value: function $onStyleChanged() {}\n  }, {\n    key: \"$onChildrenChanged\",\n    value: function $onChildrenChanged() {\n      if (typeof this.contentItem === \"undefined\" && this.children.length === 1) {\n        this.contentItem = this.children[0];\n      }\n    }\n  }, {\n    key: \"$scrollBarPolicyToCssOverflow\",\n    value: function $scrollBarPolicyToCssOverflow(policy) {\n      var Qt = QmlWeb.Qt;\n      switch (policy) {\n        case Qt.ScrollBarAsNeeded:\n          return \"auto\";\n        case Qt.ScrollBarAlwaysOff:\n          return \"hidden\";\n        case Qt.ScrollBarAlwaysOn:\n          return \"scroll\";\n      }\n      return \"auto\";\n    }\n  }]);\n\n  return _class25;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextArea\",\n  versions: /.*/,\n  baseClass: \"QtQuick.TextEdit\"\n}, function () {\n  function _class26(meta) {\n    _classCallCheck(this, _class26);\n\n    QmlWeb.callSuper(this, meta);\n    var textarea = this.impl;\n    textarea.style.padding = \"5px\";\n    textarea.style.borderWidth = \"1px\";\n    textarea.style.backgroundColor = \"#fff\";\n  }\n\n  return _class26;\n}());\n\n/**\r\n *\r\n * TextField is used to accept a line of text input.\r\n * Input constraints can be placed on a TextField item\r\n * (for example, through a validator or inputMask).\r\n * Setting echoMode to an appropriate value enables TextField\r\n * to be used for a password input field.\r\n *\r\n * Valid entries for echoMode and alignment are defined in TextInput.\r\n *\r\n */\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Controls\",\n  name: \"TextField\",\n  versions: /.*/,\n  baseClass: \"QtQuick.Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, function () {\n  function _class27(meta) {\n    var _this33 = this;\n\n    _classCallCheck(this, _class27);\n\n    QmlWeb.callSuper(this, meta);\n\n    var input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this33.$updateValue();\n    });\n  }\n\n  _createClass(_class27, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      // See TextInput for comments\n      if (this.impl.value !== newVal) {\n        this.impl.value = newVal;\n      }\n    }\n  }, {\n    key: \"$onEchoModeChanged\",\n    value: function $onEchoModeChanged(newVal) {\n      var TextInput = this.TextInput;\n      var input = this.impl;\n      switch (newVal) {\n        case TextInput.Normal:\n          input.type = \"text\";\n          break;\n        case TextInput.Password:\n          input.type = \"password\";\n          break;\n        case TextInput.NoEcho:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n        case TextInput.PasswordEchoOnEdit:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onMaximumLengthChanged\",\n    value: function $onMaximumLengthChanged(newVal) {\n      this.impl.maxLength = newVal < 0 ? null : newVal;\n    }\n  }, {\n    key: \"$onReadOnlyChanged\",\n    value: function $onReadOnlyChanged(newVal) {\n      this.impl.disabled = newVal;\n    }\n  }, {\n    key: \"Keys$onPressed\",\n    value: function Keys$onPressed(e) {\n      var Qt = QmlWeb.Qt;\n      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n      if (submit && this.$testValidator()) {\n        this.accepted();\n        e.accepted = true;\n      }\n    }\n  }, {\n    key: \"$testValidator\",\n    value: function $testValidator() {\n      if (this.validator) {\n        return this.validator.validate(this.text);\n      }\n      return true;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.$canEditReadOnlyProperties = true;\n        this.text = this.impl.value;\n        this.$canEditReadOnlyProperties = false;\n      }\n    }\n  }]);\n\n  return _class27;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"AngleDirection\",\n  versions: /^2\\./,\n  baseClass: \"Direction\",\n  properties: {\n    angle: \"real\",\n    angleVariation: \"real\",\n    magnitude: \"real\",\n    magnitudeVariation: \"real\"\n  }\n}, function () {\n  function _class28(meta) {\n    _classCallCheck(this, _class28);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class28;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"CustomParticle\",\n  versions: /^2\\./,\n  baseClass: \"ParticlePainter\",\n  properties: {\n    fragmentShader: \"string\",\n    vertexShader: \"string\"\n  }\n}, function () {\n  function _class29(meta) {\n    _classCallCheck(this, _class29);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class29;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"Direction\",\n  versions: /^2\\./,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function _class30(meta) {\n    _classCallCheck(this, _class30);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class30;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"Emitter\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    acceleration: \"StochasticDirection\",\n    emitRate: { type: \"real\", initialValue: 10 },\n    enabled: { type: \"bool\", initialValue: true },\n    endSize: { type: \"real\", initialValue: -1 },\n    group: \"string\",\n    lifeSpan: { type: \"int\", initialValue: 1000 },\n    lifeSpanVariation: \"int\",\n    maximumEmitted: { type: \"int\", initialValue: -1 },\n    shape: \"Shape\",\n    size: { type: \"real\", initialValue: 16 },\n    sizeVariation: \"real\",\n    startTime: \"int\",\n    system: \"ParticleSystem\",\n    velocity: \"StochasticDirection\",\n    velocityFromMovement: \"real\"\n  },\n  signals: {\n    emitParticles: [{ type: \"Array\", name: \"particles\" }]\n  }\n}, function () {\n  function _class31(meta) {\n    _classCallCheck(this, _class31);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class31, [{\n    key: \"burst\",\n    value: function burst() /*count, x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"pulse\",\n    value: function pulse(duration) {\n      var _this34 = this;\n\n      if (this.enabled) return;\n      this.enabled = true;\n      setTimeout(function () {\n        _this34.enabled = false;\n      }, duration);\n    }\n  }]);\n\n  return _class31;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"ParticlePainter\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    groups: \"list\",\n    system: \"ParticleSystem\"\n  }\n}, function () {\n  function _class32(meta) {\n    _classCallCheck(this, _class32);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class32;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Particles\",\n  name: \"ParticleSystem\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    empty: \"bool\",\n    particleStates: \"list\",\n    paused: \"bool\",\n    running: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class33(meta) {\n    _classCallCheck(this, _class33);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class33, [{\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      // TODO\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      this.running = false;\n      this.running = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }]);\n\n  return _class33;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Window\",\n  name: \"Screen\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function Screen(meta) {\n    _classCallCheck(this, Screen);\n\n    QmlWeb.callSuper(this, meta);\n    throw new Error(\"Screen can only be used via the attached property.\");\n  }\n\n  _createClass(Screen, null, [{\n    key: \"getAttachedObject\",\n    value: function getAttachedObject() {\n      if (!Screen.$Screen) {\n        var screen = Screen.$Screen = new QmlWeb.QObject();\n        // TODO: read-only\n        QmlWeb.createProperties(screen, {\n          name: \"string\",\n          orientation: \"enum\",\n          orientationUpdateMask: \"enum\",\n          primaryOrientation: \"enum\",\n          pixelDensity: \"real\",\n          devicePixelRatio: \"real\",\n          desktopAvailableHeight: \"int\",\n          desktopAvailableWidth: \"int\",\n          height: \"int\",\n          width: \"int\"\n        });\n        screen.name = window.navigator.appName;\n        screen.devicePixelRatio = window.devicePixelRatio;\n        screen.pixelDensity = window.devicePixelRatio * 96 / 25.4; // per mm\n        Screen.$populateScreen();\n        window.addEventListener(\"resize\", function () {\n          return Screen.$populateScreen();\n        });\n\n        // TODO: orientation\n        var _Qt = QmlWeb.Qt;\n        screen.orientationUpdateMask = 0;\n        screen.orientation = _Qt.PrimaryOrientation;\n        screen.primaryOrientation = _Qt.PrimaryOrientation;\n      }\n      return Screen.$Screen;\n    }\n  }, {\n    key: \"$populateScreen\",\n    value: function $populateScreen() {\n      var screen = Screen.$Screen;\n      screen.desktopAvailableHeight = window.outerHeight;\n      screen.desktopAvailableWidth = window.outerWidth;\n      screen.height = window.innerHeight;\n      screen.width = window.innerWidth;\n    }\n  }]);\n\n  return Screen;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick.Window\",\n  name: \"Window\",\n  versions: /^2\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    active: \"bool\",\n    activeFocusItem: \"Item\",\n    color: { type: \"color\", initialValue: \"#ffffff\" },\n    //contentItem: \"Item\", // TODO\n    contentOrientation: \"enum\",\n    flags: \"int\",\n    maximumHeight: \"int\",\n    maximumWidth: \"int\",\n    minimumHeight: \"int\",\n    minimumWidth: \"int\",\n    modality: \"enum\",\n    title: \"string\",\n    visibility: \"enum\"\n  },\n  signals: {\n    closing: [{ type: \"CloseEvent\", name: \"close\" }]\n  }\n}, function () {\n  function _class34(meta) {\n    _classCallCheck(this, _class34);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n  }\n\n  _createClass(_class34, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.dom.style.backgroundColor = newVal.$css;\n    }\n  }]);\n\n  return _class34;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"AnimatedImage\",\n  versions: /.*/,\n  baseClass: \"Image\"\n}, function () {\n  function _class35(meta) {\n    _classCallCheck(this, _class35);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class35;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Animation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    Animation: { Infinite: -1 },\n    Easing: QmlWeb.Easing\n  },\n  properties: {\n    alwaysRunToEnd: \"bool\",\n    loops: { type: \"int\", initialValue: 1 },\n    paused: \"bool\",\n    running: \"bool\"\n  }\n}, function () {\n  function _class36(meta) {\n    _classCallCheck(this, _class36);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class36, [{\n    key: \"restart\",\n    value: function restart() {\n      this.stop();\n      this.start();\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.running = false;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.paused = false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      // To be overridden\n      console.log(\"Unbound method for\", this);\n    }\n  }]);\n\n  return _class36;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Animator\",\n  versions: /^2\\./,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 },\n    from: \"real\",\n    target: \"Item\",\n    to: \"real\"\n  }\n}, function () {\n  function _class37(meta) {\n    _classCallCheck(this, _class37);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.easing = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.easing, {\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\n      amplitude: { type: \"real\", initialValue: 1 },\n      overshoot: { type: \"real\", initialValue: 1.70158 },\n      period: { type: \"real\", initialValue: 0.3 },\n      bezierCurve: \"list\"\n    });\n  }\n\n  return _class37;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Behavior\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animation: \"Animation\",\n    enabled: { type: \"bool\", initialValue: true }\n  },\n  defaultProperty: \"animation\"\n}, function () {\n  function _class38(meta) {\n    _classCallCheck(this, _class38);\n\n    QmlWeb.callSuper(this, meta);\n    this.$on = meta.object.$on;\n\n    this.animationChanged.connect(this, this.$onAnimationChanged);\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\n  }\n\n  _createClass(_class38, [{\n    key: \"$onAnimationChanged\",\n    value: function $onAnimationChanged(newVal) {\n      newVal.target = this.$parent;\n      newVal.property = this.$on;\n      this.$parent.$properties[this.$on].animation = newVal;\n    }\n  }, {\n    key: \"$onEnabledChanged\",\n    value: function $onEnabledChanged(newVal) {\n      this.$parent.$properties[this.$on].animation = newVal ? this.animation : null;\n    }\n  }]);\n\n  return _class38;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"BorderImage\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    BorderImage: {\n      Stretch: \"stretch\", Repeat: \"repeat\", Round: \"round\",\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    source: \"url\",\n    smooth: { type: \"bool\", initialValue: true },\n    // BorderImage.Stretch\n    horizontalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    // BorderImage.Stretch\n    verticalTileMode: { type: \"enum\", initialValue: \"stretch\" },\n    progress: \"real\",\n    status: { type: \"enum\", initialValue: 1 } // BorderImage.Null\n  }\n}, function () {\n  function _class39(meta) {\n    var _this35 = this;\n\n    _classCallCheck(this, _class39);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.border = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.border, {\n      left: \"int\",\n      right: \"int\",\n      top: \"int\",\n      bottom: \"int\"\n    });\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    bg.style.boxSizing = \"border-box\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", function () {\n      _this35.progress = 1;\n      _this35.status = _this35.BorderImage.Ready;\n    });\n    this.$img.addEventListener(\"error\", function () {\n      _this35.status = _this35.BorderImage.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.border.leftChanged.connect(this, this.$updateBorder);\n    this.border.rightChanged.connect(this, this.$updateBorder);\n    this.border.topChanged.connect(this, this.$updateBorder);\n    this.border.bottomChanged.connect(this, this.$updateBorder);\n    this.horizontalTileModeChanged.connect(this, this.$updateBorder);\n    this.verticalTileModeChanged.connect(this, this.$updateBorder);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n\n  _createClass(_class39, [{\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      this.progress = 0;\n      this.status = this.BorderImage.Loading;\n      var style = this.impl.style;\n      var imageURL = QmlWeb.engine.$resolveImageURL(source);\n      style.OBorderImageSource = \"url(\\\"\" + imageURL + \"\\\")\";\n      style.borderImageSource = \"url(\\\"\" + imageURL + \"\\\")\";\n      this.$img.src = imageURL;\n      if (this.$img.complete) {\n        this.progress = 1;\n        this.status = this.BorderImage.Ready;\n      }\n    }\n  }, {\n    key: \"$updateBorder\",\n    value: function $updateBorder() {\n      var style = this.impl.style;\n      var _border = this.border,\n          right = _border.right,\n          left = _border.left,\n          top = _border.top,\n          bottom = _border.bottom;\n\n      var slice = top + \" \" + right + \" \" + bottom + \" \" + left + \" fill\";\n      var width = top + \"px \" + right + \"px \" + bottom + \"px \" + left + \"px\";\n      var repeat = this.horizontalTileMode + \" \" + this.verticalTileMode;\n      style.OBorderImageSlice = slice;\n      style.OBorderImageRepeat = repeat;\n      style.OBorderImageWidth = width;\n      style.borderImageSlice = slice;\n      style.borderImageRepeat = repeat;\n      style.borderImageWidth = width;\n    }\n  }, {\n    key: \"$onSmoothChanged\",\n    value: function $onSmoothChanged(val) {\n      var style = this.impl.style;\n      if (val) {\n        style.imageRendering = \"auto\";\n      } else {\n        style.imageRendering = \"-webkit-optimize-contrast\";\n        style.imageRendering = \"-moz-crisp-edges\";\n        style.imageRendering = \"crisp-edges\";\n        style.imageRendering = \"pixelated\";\n      }\n    }\n  }]);\n\n  return _class39;\n}());\n\n// TODO\n// Currently only a skeleton implementation\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Canvas\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    available: { type: \"bool\", initialValue: true },\n    canvasSize: { type: \"var\", initialValue: [0, 0] },\n    canvasWindow: { type: \"var\", initialValue: [0, 0, 0, 0] },\n    context: { type: \"var\", initialValue: {} },\n    contextType: { type: \"string\", initialValue: \"contextType\" },\n    renderStrategy: \"enum\",\n    renderTarget: \"enum\",\n    tileSize: { type: \"var\", initialValue: [0, 0] }\n  },\n  signals: {\n    imageLoaded: [],\n    paint: [{ type: \"var\", name: \"region\" }],\n    painted: []\n  }\n}, function () {\n  function _class40(meta) {\n    _classCallCheck(this, _class40);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class40, [{\n    key: \"cancelRequestAnimationFrame\",\n    value: function cancelRequestAnimationFrame() /*handle*/{\n      return false;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() /*context_id, ...args*/{\n      return {};\n    }\n  }, {\n    key: \"isImageError\",\n    value: function isImageError() /*image*/{\n      return true;\n    }\n  }, {\n    key: \"isImageLoaded\",\n    value: function isImageLoaded() /*image*/{\n      return false;\n    }\n  }, {\n    key: \"isImageLoading\",\n    value: function isImageLoading() /*image*/{\n      return false;\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(image) {\n      //loadImageAsync(image);\n      if (this.isImageLoaded(image)) {\n        this.imageLoaded();\n      }\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty(area) {\n      // if dirty\n      this.paint(area);\n    }\n  }, {\n    key: \"requestAnimationFrame\",\n    value: function requestAnimationFrame() /*callback*/{\n      return 0;\n    }\n  }, {\n    key: \"requestPaint\",\n    value: function requestPaint() {}\n  }, {\n    key: \"save\",\n    value: function save() /*file_name*/{\n      return false;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() /*mime_type*/{\n      return \"\";\n    }\n  }, {\n    key: \"unloadImage\",\n    value: function unloadImage() /*image*/{}\n  }]);\n\n  return _class40;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Column\",\n  versions: /.*/,\n  baseClass: \"Positioner\"\n}, function () {\n  function _class41(meta) {\n    _classCallCheck(this, _class41);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class41, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      var curPos = this.padding;\n      var maxWidth = 0;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.visible || !child.width || !child.height) {\n          continue;\n        }\n        maxWidth = child.width > maxWidth ? child.width : maxWidth;\n        child.y = curPos + this.padding;\n        if (this.padding > 0) child.x = this.padding;\n        curPos += child.height + this.spacing;\n      }\n      this.implicitWidth = maxWidth + this.padding * 2;\n      this.implicitHeight = curPos - this.spacing + this.padding;\n      // We want no spacing at the bottom side\n    }\n  }]);\n\n  return _class41;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"DoubleValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    DoubleValidator: { StandardNotation: 1, ScientificNotation: 2 }\n  },\n  properties: {\n    bottom: { type: \"real\", initialValue: -Infinity },\n    top: { type: \"real\", initialValue: Infinity },\n    decimals: { type: \"int\", initialValue: 1000 },\n    // DoubleValidator.ScientificNotation\n    notation: { type: \"enum\", initialValue: 2 }\n  }\n}, function () {\n  function _class42(meta) {\n    _classCallCheck(this, _class42);\n\n    QmlWeb.callSuper(this, meta);\n    this.$standardRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n    this.$scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n  }\n\n  _createClass(_class42, [{\n    key: \"getRegExpForNotation\",\n    value: function getRegExpForNotation(notation) {\n      switch (notation) {\n        case this.DoubleValidator.ScientificNotation:\n          return this.$scientificRegExp;\n        case this.DoubleValidator.StandardNotation:\n          return this.$standardRegExp;\n      }\n      return null;\n    }\n  }, {\n    key: \"$getDecimalsForNumber\",\n    value: function $getDecimalsForNumber(number) {\n      if (Math.round(number) === number) {\n        return 0;\n      }\n      var str = \"\" + number;\n      return (/\\d*$/.exec(str)[0].length\n      );\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(string) {\n      var regExp = this.getRegExpForNotation(this.notation);\n      if (!regExp.test(string.trim())) {\n        return false;\n      }\n      var value = parseFloat(string);\n      return this.bottom <= value && this.top >= value && this.$getDecimalsForNumber(value) <= this.decimals;\n    }\n  }]);\n\n  return _class42;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Flow\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Flow: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    flow: \"enum\", // Flow.LeftToRight\n    layoutDirection: \"enum\" // Flow.LeftToRight\n  }\n}, function () {\n  function _class43(meta) {\n    _classCallCheck(this, _class43);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.heightChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class43, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      if (this.flow === undefined) {\n        // Flow has not been fully initialized yet\n        return;\n      }\n\n      var curHPos = 0;\n      var curVPos = 0;\n      var rowSize = 0;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.visible || !child.width || !child.height) {\n          continue;\n        }\n\n        if (this.flow === this.Flow.LeftToRight) {\n          if (!this.$isUsingImplicitWidth && curHPos + child.width > this.width) {\n            curHPos = 0;\n            curVPos += rowSize + this.spacing;\n            rowSize = 0;\n          }\n          rowSize = child.height > rowSize ? child.height : rowSize;\n          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;\n          child.y = curVPos;\n          curHPos += child.width + this.spacing;\n        } else {\n          // Flow.TopToBottom\n          if (!this.$isUsingImplicitHeight && curVPos + child.height > this.height) {\n            curVPos = 0;\n            curHPos += rowSize + this.spacing;\n            rowSize = 0;\n          }\n          rowSize = child.width > rowSize ? child.width : rowSize;\n          child.x = this.layoutDirection === this.Flow.TopToBottom ? this.width - curHPos - child.width : curHPos;\n          child.y = curVPos;\n          curVPos += child.height + this.spacing;\n        }\n      }\n\n      if (this.flow === this.Flow.LeftToRight) {\n        this.implicitWidth = curHPos - this.spacing;\n        this.implicitHeight = curVPos + rowSize;\n      } else {\n        // Flow.TopToBottom\n        this.implicitWidth = curHPos + rowSize;\n        this.implicitHeight = curVPos - this.spacing;\n      }\n    }\n  }]);\n\n  return _class43;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"FocusScope\",\n  versions: /.*/,\n  baseClass: \"Item\"\n}, function () {\n  function _class44(meta) {\n    _classCallCheck(this, _class44);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class44;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"FontLoader\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    FontLoader: { Null: 0, Ready: 1, Loading: 2, Error: 3 }\n  },\n  properties: {\n    name: \"string\",\n    source: \"url\",\n    status: \"enum\" // FontLoader.Null\n  }\n}, function () {\n  function _class45(meta) {\n    _classCallCheck(this, _class45);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$lastName = \"\";\n    this.$inTouchName = false;\n\n    /*\r\n      Maximum timeout is the maximum time for a font to load. If font isn't\r\n      loaded in this time, the status is set to Error.\r\n      For both cases (with and without FontLoader.js) if the font takes more\r\n      than the maximum timeout to load, dimensions recalculations for elements\r\n      that are using this font will not be triggered or will have no effect.\r\n        FontLoader.js uses only the last timeout. The state and name properties\r\n      are set immediately when the font loads. If the font could not be loaded,\r\n      the Error status will be set only when this timeout expires. If the font\r\n      loading takes more than the timeout, the name property is set, but the\r\n      status is set to Error.\r\n        Fallback sets the font name immediately and touches it several times to\r\n      trigger dimensions recalcuations. The status is set to Error and should\r\n      not be used.\r\n    */\n    // 15 seconds maximum\n    this.$timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000];\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.nameChanged.connect(this, this.$onNameChanged);\n  }\n\n  _createClass(_class45, [{\n    key: \"$loadFont\",\n    value: function $loadFont(fontName, fontFace) {\n      var _this36 = this;\n\n      /* global FontLoader */\n      if (this.$lastName === fontName || this.$inTouchName) {\n        return;\n      }\n      this.$lastName = fontName;\n\n      if (!fontName) {\n        this.status = this.FontLoader.Null;\n        return;\n      }\n      this.status = this.FontLoader.Loading;\n\n      var promise = void 0;\n      if (fontFace) {\n        promise = fontFace.loaded;\n      } else if (document.fonts && document.fonts.load) {\n        promise = document.fonts.load(fontName);\n      }\n\n      if (promise) {\n        promise.then(function () {\n          if (_this36.$lastName !== fontName) return;\n          _this36.name = fontName;\n          _this36.status = _this36.FontLoader.Ready;\n        }, function () {\n          if (_this36.$lastName !== fontName) return;\n          _this36.status = _this36.FontLoader.Error;\n        });\n      } else if (typeof FontLoader === \"function\") {\n        var fontLoader = new FontLoader([fontName], {\n          fontsLoaded: function fontsLoaded(error) {\n            if (error !== null) {\n              if (_this36.$lastName === fontName && error.notLoadedFontFamilies[0] === fontName) {\n                // Set the name for the case of font loading after the timeout.\n                _this36.name = fontName;\n                _this36.status = _this36.FontLoader.Error;\n              }\n            }\n          },\n          fontLoaded: function fontLoaded(fontFamily) {\n            if (_this36.$lastName === fontName && fontFamily === fontName) {\n              _this36.name = fontName;\n              _this36.status = _this36.FontLoader.Ready;\n            }\n          }\n        }, this.$timeouts[this.$timeouts.length - 1]);\n        // Else I get problems loading multiple fonts (FontLoader.js bug?)\n        FontLoader.testDiv = null;\n        fontLoader.loadFonts();\n      } else {\n        console.warn(\"FontLoader.js library is not loaded.\\nYou should load FontLoader.js if you want to use QtQuick FontLoader elements.\\nRefs: https://github.com/smnh/FontLoader.\");\n        // You should not rely on 'status' property without FontLoader.js.\n        this.status = this.FontLoader.Error;\n        this.name = fontName;\n        this.$cycleTouchName(fontName, 0);\n      }\n    }\n  }, {\n    key: \"$cycleTouchName\",\n    value: function $cycleTouchName(fontName, i) {\n      var _this37 = this;\n\n      if (this.$lastName !== fontName) {\n        return;\n      }\n      if (i > 0) {\n        var name = this.name;\n        this.$inTouchName = true;\n        // Calling this.nameChanged() is not enough, we have to actually change\n        // the value to flush the bindings.\n        this.name = \"sans-serif\";\n        this.name = name;\n        this.$inTouchName = false;\n      }\n      if (i < this.$timeouts.length) {\n        setTimeout(function () {\n          _this37.$cycleTouchName(fontName, i + 1);\n        }, this.$timeouts[i] - (i > 0 ? this.$timeouts[i - 1] : 0));\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(font_src) {\n      // Load font by source url\n      var rand = Math.round(Math.random() * 1e15);\n      var fontName = \"font_\" + Date.now().toString(36) + \"_\" + rand.toString(36);\n      if ((typeof FontFace === \"undefined\" ? \"undefined\" : _typeof(FontFace)) !== undefined && document.fonts && document.fonts.add) {\n        var fontFace = new FontFace(fontName, \"url('\" + font_src + \"')\");\n        document.fonts.add(fontFace);\n        fontFace.load();\n        this.$loadFont(fontName, fontFace);\n        return;\n      }\n      if (!this.$domStyle) {\n        this.$domStyle = document.createElement(\"style\");\n      }\n      this.$domStyle.innerHTML = \"@font-face {\\n      font-family: \" + fontName + \";\\n      src: url('\" + font_src + \"');\\n    }\";\n      document.getElementsByTagName(\"head\")[0].appendChild(this.$domStyle);\n      this.$loadFont(fontName);\n    }\n  }, {\n    key: \"$onNameChanged\",\n    value: function $onNameChanged(fontName) {\n      // Load font by the name\n      this.$loadFont(fontName);\n    }\n  }]);\n\n  return _class45;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Grid\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  enums: {\n    Grid: { LeftToRight: 0, TopToBottom: 1 }\n  },\n  properties: {\n    columns: \"int\",\n    rows: \"int\",\n    flow: \"enum\",\n    layoutDirection: \"enum\"\n  }\n}, function () {\n  function _class46(meta) {\n    _classCallCheck(this, _class46);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class46, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      // How many items are actually visible?\n      var visibleItems = this.$getVisibleItems();\n\n      // How many rows and columns do we need?\n\n      var _$calculateSize = this.$calculateSize(visibleItems.length),\n          _$calculateSize2 = _slicedToArray(_$calculateSize, 2),\n          c = _$calculateSize2[0],\n          r = _$calculateSize2[1];\n\n      // How big are the colums/rows?\n\n\n      var _$calculateGrid = this.$calculateGrid(visibleItems, c, r),\n          _$calculateGrid2 = _slicedToArray(_$calculateGrid, 2),\n          colWidth = _$calculateGrid2[0],\n          rowHeight = _$calculateGrid2[1];\n\n      // Do actual positioning\n      // When layoutDirection is RightToLeft we need oposite order of coumns\n\n\n      var step = this.layoutDirection === 1 ? -1 : 1;\n      var startingPoint = this.layoutDirection === 1 ? c - 1 : 0;\n      var endPoint = this.layoutDirection === 1 ? -1 : c;\n      var curHPos = 0;\n      var curVPos = 0;\n      if (this.flow === 0) {\n        for (var i = 0; i < r; i++) {\n          for (var j = startingPoint; j !== endPoint; j += step) {\n            var item = visibleItems[i * c + j];\n            if (!item) {\n              break;\n            }\n            item.x = curHPos;\n            item.y = curVPos;\n\n            curHPos += colWidth[j] + this.spacing;\n          }\n          curVPos += rowHeight[i] + this.spacing;\n          curHPos = 0;\n        }\n      } else {\n        for (var _i2 = startingPoint; _i2 !== endPoint; _i2 += step) {\n          for (var _j = 0; _j < r; _j++) {\n            var _item = visibleItems[_i2 * r + _j];\n            if (!_item) {\n              break;\n            }\n            _item.x = curHPos;\n            _item.y = curVPos;\n\n            curVPos += rowHeight[_j] + this.spacing;\n          }\n          curHPos += colWidth[_i2] + this.spacing;\n          curVPos = 0;\n        }\n      }\n\n      // Set implicit size\n      var gridWidth = -this.spacing;\n      var gridHeight = -this.spacing;\n      for (var _i3 in colWidth) {\n        gridWidth += colWidth[_i3] + this.spacing;\n      }\n      for (var _i4 in rowHeight) {\n        gridHeight += rowHeight[_i4] + this.spacing;\n      }\n      this.implicitWidth = gridWidth;\n      this.implicitHeight = gridHeight;\n    }\n  }, {\n    key: \"$getVisibleItems\",\n    value: function $getVisibleItems() {\n      return this.children.filter(function (child) {\n        return child.visible && child.width && child.height;\n      });\n    }\n  }, {\n    key: \"$calculateSize\",\n    value: function $calculateSize(length) {\n      var cols = void 0;\n      var rows = void 0;\n      if (!this.columns && !this.rows) {\n        cols = 4;\n        rows = Math.ceil(length / cols);\n      } else if (!this.columns) {\n        rows = this.rows;\n        cols = Math.ceil(length / rows);\n      } else {\n        cols = this.columns;\n        rows = Math.ceil(length / cols);\n      }\n      return [cols, rows];\n    }\n  }, {\n    key: \"$calculateGrid\",\n    value: function $calculateGrid(visibleItems, cols, rows) {\n      var colWidth = [];\n      var rowHeight = [];\n\n      if (this.flow === 0) {\n        for (var i = 0; i < rows; i++) {\n          for (var j = 0; j < cols; j++) {\n            var item = visibleItems[i * cols + j];\n            if (!item) {\n              break;\n            }\n            if (!colWidth[j] || item.width > colWidth[j]) {\n              colWidth[j] = item.width;\n            }\n            if (!rowHeight[i] || item.height > rowHeight[i]) {\n              rowHeight[i] = item.height;\n            }\n          }\n        }\n      } else {\n        for (var _i5 = 0; _i5 < cols; _i5++) {\n          for (var _j2 = 0; _j2 < rows; _j2++) {\n            var _item2 = visibleItems[_i5 * rows + _j2];\n            if (!_item2) {\n              break;\n            }\n            if (!rowHeight[_j2] || _item2.height > rowHeight[_j2]) {\n              rowHeight[_j2] = _item2.height;\n            }\n            if (!colWidth[_i5] || _item2.width > colWidth[_i5]) {\n              colWidth[_i5] = _item2.width;\n            }\n          }\n        }\n      }\n\n      return [colWidth, rowHeight];\n    }\n  }]);\n\n  return _class46;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Image\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Image: {\n      Stretch: 1, PreserveAspectFit: 2, PreserveAspectCrop: 3,\n      Tile: 4, TileVertically: 5, TileHorizontally: 6,\n\n      Null: 1, Ready: 2, Loading: 3, Error: 4\n    }\n  },\n  properties: {\n    asynchronous: { type: \"bool\", initialValue: true },\n    cache: { type: \"bool\", initialValue: true },\n    smooth: { type: \"bool\", initialValue: true },\n    fillMode: { type: \"enum\", initialValue: 1 }, // Image.Stretch\n    mirror: \"bool\",\n    progress: \"real\",\n    source: \"url\",\n    status: { type: \"enum\", initialValue: 1 } // Image.Null\n  }\n}, function () {\n  function _class47(meta) {\n    var _this38 = this;\n\n    _classCallCheck(this, _class47);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.sourceSize = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.sourceSize, {\n      width: \"int\",\n      height: \"int\"\n    });\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.height = \"100%\";\n    this.dom.appendChild(bg);\n\n    this.$img = new Image();\n    this.$img.addEventListener(\"load\", function () {\n      var w = _this38.$img.naturalWidth;\n      var h = _this38.$img.naturalHeight;\n      _this38.sourceSize.width = w;\n      _this38.sourceSize.height = h;\n      _this38.implicitWidth = w;\n      _this38.implicitHeight = h;\n      _this38.progress = 1;\n      _this38.status = _this38.Image.Ready;\n    });\n    this.$img.addEventListener(\"error\", function () {\n      _this38.status = _this38.Image.Error;\n    });\n\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.mirrorChanged.connect(this, this.$onMirrorChanged);\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\n  }\n\n  _createClass(_class47, [{\n    key: \"$updateFillMode\",\n    value: function $updateFillMode() {\n      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.fillMode;\n\n      var style = this.impl.style;\n      switch (val) {\n        default:\n        case this.Image.Stretch:\n          style.backgroundRepeat = \"auto\";\n          style.backgroundSize = \"100% 100%\";\n          style.backgroundPosition = \"auto\";\n          break;\n        case this.Image.Tile:\n          style.backgroundRepeat = \"auto\";\n          style.backgroundSize = \"auto\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.PreserveAspectFit:\n          style.backgroundRepeat = \"no-repeat\";\n          style.backgroundSize = \"contain\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.PreserveAspectCrop:\n          style.backgroundRepeat = \"no-repeat\";\n          style.backgroundSize = \"cover\";\n          style.backgroundPosition = \"center\";\n          break;\n        case this.Image.TileVertically:\n          style.backgroundRepeat = \"repeat-y\";\n          style.backgroundSize = \"100% auto\";\n          style.backgroundPosition = \"auto\";\n          break;\n        case this.Image.TileHorizontally:\n          style.backgroundRepeat = \"repeat-x\";\n          style.backgroundSize = \"auto 100%\";\n          style.backgroundPosition = \"auto\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(source) {\n      this.progress = 0;\n      this.status = this.Image.Loading;\n      var imageURL = QmlWeb.engine.$resolveImageURL(source);\n      this.impl.style.backgroundImage = \"url(\\\"\" + imageURL + \"\\\")\";\n      this.$img.src = imageURL;\n      if (this.$img.complete) {\n        this.progress = 1;\n        this.status = this.Image.Ready;\n      }\n      this.$updateFillMode();\n    }\n  }, {\n    key: \"$onMirrorChanged\",\n    value: function $onMirrorChanged(val) {\n      var transformRule = \"scale(-1,1)\";\n      if (!val) {\n        var index = this.transform.indexOf(transformRule);\n        if (index >= 0) {\n          this.transform.splice(index, 1);\n        }\n      } else {\n        this.transform.push(transformRule);\n      }\n      this.$updateTransform();\n    }\n  }, {\n    key: \"$onFillModeChanged\",\n    value: function $onFillModeChanged(val) {\n      this.$updateFillMode(val);\n    }\n  }, {\n    key: \"$onSmoothChanged\",\n    value: function $onSmoothChanged(val) {\n      var style = this.impl.style;\n      if (val) {\n        style.imageRendering = \"auto\";\n      } else {\n        style.imageRendering = \"-webkit-optimize-contrast\";\n        style.imageRendering = \"-moz-crisp-edges\";\n        style.imageRendering = \"crisp-edges\";\n        style.imageRendering = \"pixelated\";\n      }\n    }\n  }]);\n\n  return _class47;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"IntValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    bottom: { type: \"int\", initialValue: -2147483647 },\n    top: { type: \"int\", initialValue: 2147483647 }\n  }\n}, function () {\n  function _class48(meta) {\n    _classCallCheck(this, _class48);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class48, [{\n    key: \"validate\",\n    value: function validate(string) {\n      var regExp = /^(-|\\+)?\\s*[0-9]+$/;\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value = parseInt(string, 10);\n        acceptable = this.bottom <= value && this.top >= value;\n      }\n      return acceptable;\n    }\n  }]);\n\n  return _class48;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Item\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    $opacity: { type: \"real\", initialValue: 1 },\n    parent: \"Item\",\n    antialiasing: \"bool\",\n    state: \"string\",\n    states: \"list\",\n    transitions: \"list\",\n    data: \"list\",\n    children: \"list\",\n    resources: \"list\",\n    transform: \"list\",\n    x: \"real\",\n    y: \"real\",\n    z: \"real\",\n    width: \"real\",\n    height: \"real\",\n    implicitWidth: \"real\",\n    implicitHeight: \"real\",\n    left: \"real\",\n    right: \"real\",\n    top: \"real\",\n    bottom: \"real\",\n    horizontalCenter: \"real\",\n    verticalCenter: \"real\",\n    rotation: \"real\",\n    scale: { type: \"real\", initialValue: 1 },\n    opacity: { type: \"real\", initialValue: 1 },\n    visible: { type: \"bool\", initialValue: true },\n    clip: \"bool\",\n    focus: \"bool\"\n  },\n  defaultProperty: \"data\"\n}, function () {\n  function _class49(meta) {\n    _classCallCheck(this, _class49);\n\n    QmlWeb.callSuper(this, meta);\n\n    if (!this.dom) {\n      // Create a dom element for this item.\n      this.dom = document.createElement(meta.tagName || \"div\");\n    }\n    this.dom.style.position = \"absolute\";\n    this.dom.style.pointerEvents = \"none\";\n    // In case the class is qualified, only use the last part for the css class\n    // name.\n    var classComponent = meta.object.$class.split(\".\").pop();\n    this.dom.className = \"\" + classComponent + (this.id ? \" \" + this.id : \"\");\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = \"border-box\";\n\n    if (this.$isComponentRoot) {\n      QmlWeb.createProperty(\"var\", this, \"activeFocus\");\n    }\n\n    this.parentChanged.connect(this, this.$onParentChanged_);\n    this.dataChanged.connect(this, this.$onDataChanged);\n    this.stateChanged.connect(this, this.$onStateChanged);\n    this.visibleChanged.connect(this, this.$onVisibleChanged_);\n    this.clipChanged.connect(this, this.$onClipChanged);\n    this.zChanged.connect(this, this.$onZChanged);\n    this.xChanged.connect(this, this.$onXChanged);\n    this.yChanged.connect(this, this.$onYChanged);\n    this.widthChanged.connect(this, this.$onWidthChanged_);\n    this.heightChanged.connect(this, this.$onHeightChanged_);\n    this.focusChanged.connect(this, this.$onFocusChanged_);\n\n    this.widthChanged.connect(this, this.$updateHGeometry);\n    this.heightChanged.connect(this, this.$updateVGeometry);\n    this.implicitWidthChanged.connect(this, this.$onImplicitWidthChanged);\n    this.implicitHeightChanged.connect(this, this.$onImplicitHeightChanged);\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.anchors, {\n      left: \"var\",\n      right: \"var\",\n      top: \"var\",\n      bottom: \"var\",\n      horizontalCenter: \"var\",\n      verticalCenter: \"var\",\n      fill: \"Item\",\n      centerIn: \"Item\",\n      margins: \"real\",\n      leftMargin: \"real\",\n      rightMargin: \"real\",\n      topMargin: \"real\",\n      bottomMargin: \"real\"\n    });\n    this.anchors.leftChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomChanged.connect(this, this.$updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, this.$updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, this.$updateVGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateHGeometry);\n    this.anchors.fillChanged.connect(this, this.$updateVGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateHGeometry);\n    this.anchors.centerInChanged.connect(this, this.$updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, this.$updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, this.$updateVGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateHGeometry);\n    this.anchors.marginsChanged.connect(this, this.$updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.childrenRect, {\n      x: \"real\", // TODO ro\n      y: \"real\", // TODO ro\n      width: \"real\", // TODO ro\n      height: \"real\" // TODO ro\n    });\n\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n\n    this.Component.completed.connect(this, this.Component$onCompleted_);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = this.x + \"px\";\n    this.css.top = this.y + \"px\";\n  }\n\n  _createClass(_class49, [{\n    key: \"$onParentChanged_\",\n    value: function $onParentChanged_(newParent, oldParent, propName) {\n      if (oldParent) {\n        oldParent.children.splice(oldParent.children.indexOf(this), 1);\n        oldParent.childrenChanged();\n        oldParent.dom.removeChild(this.dom);\n      }\n      if (newParent && newParent.children.indexOf(this) === -1) {\n        newParent.children.push(this);\n        newParent.childrenChanged();\n      }\n      if (newParent) {\n        newParent.dom.appendChild(this.dom);\n      }\n      this.$updateHGeometry(newParent, oldParent, propName);\n      this.$updateVGeometry(newParent, oldParent, propName);\n    }\n  }, {\n    key: \"$onDataChanged\",\n    value: function $onDataChanged(newData) {\n      var QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\n      for (var i in newData) {\n        var child = newData[i];\n        if (child instanceof QMLItem) {\n          child.parent = this; // This will also add it to children.\n        } else {\n          this.resources.push(child);\n        }\n      }\n    }\n  }, {\n    key: \"$onStateChanged\",\n    value: function $onStateChanged(newVal, oldVal) {\n      // let oldState; // TODO: do we need oldState?\n      var newState = void 0;\n      for (var i = 0; i < this.states.length; i++) {\n        if (this.states[i].name === newVal) {\n          newState = this.states[i];\n        }\n        /*\r\n        else if (this.states[i].name === oldVal) {\r\n          oldState = this.states[i];\r\n        }\r\n        */\n      }\n\n      var actions = this.$revertActions.slice();\n\n      // Get current values for revert actions\n      for (var _i6 in actions) {\n        var action = actions[_i6];\n        action.from = action.target[action.property];\n      }\n      if (newState) {\n        var changes = newState.$getAllChanges();\n\n        // Get all actions we need to do and create actions to revert them\n        for (var _i7 = 0; _i7 < changes.length; _i7++) {\n          this.$applyChange(actions, changes[_i7]);\n        }\n      }\n\n      // Set all property changes and fetch the actual values afterwards\n      // The latter is needed for transitions. We need to set all properties\n      // before we fetch the values because properties can be interdependent.\n      for (var _i8 in actions) {\n        var _action = actions[_i8];\n        _action.target.$properties[_action.property].set(_action.value, QmlWeb.QMLProperty.ReasonUser, _action.target, newState ? newState.$context : _action.target.$context);\n      }\n      for (var _i9 in actions) {\n        var _action2 = actions[_i9];\n        _action2.to = _action2.target[_action2.property];\n        if (_action2.explicit) {\n          // Remove binding\n          _action2.target[_action2.property] = _action2.target[_action2.property];\n          _action2.value = _action2.target[_action2.property];\n        }\n      }\n\n      // Find the best transition to use\n      var transition = void 0;\n      var rating = 0;\n      for (var _i10 = 0; _i10 < this.transitions.length; _i10++) {\n        // We need to stop running transitions, so let's do\n        // it while iterating through the transitions anyway\n        this.transitions[_i10].$stop();\n        var curTransition = this.transitions[_i10];\n        var curRating = 0;\n        if (curTransition.from === oldVal || curTransition.reversible && curTransition.from === newVal) {\n          curRating += 2;\n        } else if (curTransition.from === \"*\") {\n          curRating++;\n        } else {\n          continue;\n        }\n        if (curTransition.to === newVal || curTransition.reversible && curTransition.to === oldVal) {\n          curRating += 2;\n        } else if (curTransition.to === \"*\") {\n          curRating++;\n        } else {\n          continue;\n        }\n        if (curRating > rating) {\n          rating = curRating;\n          transition = curTransition;\n        }\n      }\n      if (transition) {\n        transition.$start(actions);\n      }\n    }\n  }, {\n    key: \"$applyChange\",\n    value: function $applyChange(actions, change) {\n      var _this39 = this;\n\n      var arrayFindIndex = QmlWeb.helpers.arrayFindIndex;\n\n      var _loop = function _loop(j) {\n        var item = change.$actions[j];\n\n        var action = {\n          target: change.target,\n          property: item.property,\n          origValue: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n          value: item.value,\n          from: change.target[item.property],\n          to: undefined,\n          explicit: change.explicit\n        };\n\n        var actionIndex = arrayFindIndex(actions, function (element) {\n          return element.target === action.target && element.property === action.property;\n        });\n        if (actionIndex !== -1) {\n          actions[actionIndex] = action;\n        } else {\n          actions.push(action);\n        }\n\n        // Look for existing revert action, else create it\n        var revertIndex = arrayFindIndex(_this39.$revertActions, function (element) {\n          return element.target === change.target && element.property === item.property;\n        });\n        if (revertIndex !== -1 && !change.restoreEntryValues) {\n          // We don't want to revert, so remove it\n          _this39.$revertActions.splice(revertIndex, 1);\n        } else if (revertIndex === -1 && change.restoreEntryValues) {\n          _this39.$revertActions.push({\n            target: change.target,\n            property: item.property,\n            value: change.target.$properties[item.property].binding || change.target.$properties[item.property].val,\n            from: undefined,\n            to: change.target[item.property]\n          });\n        }\n      };\n\n      for (var j = 0; j < change.$actions.length; j++) {\n        _loop(j);\n      }\n    }\n  }, {\n    key: \"$onVisibleChanged_\",\n    value: function $onVisibleChanged_(newVal) {\n      this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n    }\n  }, {\n    key: \"$onClipChanged\",\n    value: function $onClipChanged(newVal) {\n      this.css.overflow = newVal ? \"hidden\" : \"visible\";\n    }\n  }, {\n    key: \"$onZChanged\",\n    value: function $onZChanged() {\n      this.$updateTransform();\n    }\n  }, {\n    key: \"$onXChanged\",\n    value: function $onXChanged(newVal) {\n      this.css.left = newVal + \"px\";\n      this.$updateHGeometry();\n    }\n  }, {\n    key: \"$onYChanged\",\n    value: function $onYChanged(newVal) {\n      this.css.top = newVal + \"px\";\n      this.$updateVGeometry();\n    }\n  }, {\n    key: \"$onWidthChanged_\",\n    value: function $onWidthChanged_(newVal) {\n      this.css.width = newVal ? newVal + \"px\" : \"auto\";\n    }\n  }, {\n    key: \"$onHeightChanged_\",\n    value: function $onHeightChanged_(newVal) {\n      this.css.height = newVal ? newVal + \"px\" : \"auto\";\n    }\n  }, {\n    key: \"$onFocusChanged_\",\n    value: function $onFocusChanged_(newVal) {\n      if (newVal) {\n        if (this.dom.firstChild) {\n          this.dom.firstChild.focus();\n        }\n        document.qmlFocus = this;\n        this.$context.activeFocus = this;\n      } else if (document.qmlFocus === this) {\n        document.getElementsByTagName(\"BODY\")[0].focus();\n        document.qmlFocus = QmlWeb.engine.rootContext().base;\n        this.$context.activeFocus = null;\n      }\n    }\n  }, {\n    key: \"setupFocusOnDom\",\n    value: function setupFocusOnDom(element) {\n      var _this40 = this;\n\n      var updateFocus = function updateFocus() {\n        var hasFocus = document.activeElement === _this40.dom || document.activeElement === _this40.dom.firstChild;\n        if (_this40.focus !== hasFocus) {\n          _this40.focus = hasFocus;\n        }\n      };\n      element.addEventListener(\"focus\", updateFocus);\n      element.addEventListener(\"blur\", updateFocus);\n    }\n  }, {\n    key: \"$updateTransform\",\n    value: function $updateTransform() {\n      var QMLTranslate = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Translate\");\n      var QMLRotation = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Rotation\");\n      var QMLScale = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Scale\");\n      var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\n      var filter = \"\";\n      var transformStyle = \"preserve-3d\";\n\n      for (var i = 0; i < this.transform.length; i++) {\n        var t = this.transform[i];\n        if (t instanceof QMLRotation) {\n          var ax = t.axis;\n          transform += \" rotate3d(\" + ax.x + \", \" + ax.y + \", \" + ax.z + \", \" + ax.angle + \"deg)\";\n        } else if (t instanceof QMLScale) {\n          transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\n        } else if (t instanceof QMLTranslate) {\n          transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\n        } else if (typeof t.transformType !== \"undefined\") {\n          if (t.transformType === \"filter\") {\n            filter += t.operation + \"(\" + t.parameters + \") \";\n          }\n        } else if (typeof t === \"string\") {\n          transform += t;\n        }\n      }\n      if (typeof this.z === \"number\") {\n        transform += \" translate3d(0, 0, \" + this.z + \"px)\";\n        // should also consider z as zIndex for stacking order behaviour of qml\n        // see http://doc.qt.io/qt-5/qml-qtquick-item.html#z-prop\n        this.dom.style.zIndex = this.z;\n      }\n      this.dom.style.transform = transform;\n      this.dom.style.transformStyle = transformStyle;\n      this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n      this.dom.style.webkitTransformStyle = transformStyle;\n      this.dom.style.msTransform = transform; // IE\n      this.dom.style.filter = filter;\n      this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n    }\n  }, {\n    key: \"Component$onCompleted_\",\n    value: function Component$onCompleted_() {\n      this.$calculateOpacity();\n    }\n  }, {\n    key: \"$calculateOpacity\",\n    value: function $calculateOpacity() {\n      // TODO: reset all opacity on layer.enabled changed\n      /*\r\n      if (false) { // TODO: check layer.enabled\r\n        this.css.opacity = this.opacity;\r\n      }\r\n      */\n      var parentOpacity = this.$parent && this.$parent.$opacity || 1;\n      this.$opacity = this.opacity * parentOpacity;\n      if (this.impl) {\n        this.impl.style.opacity = this.$opacity;\n      }\n    }\n  }, {\n    key: \"$onImplicitWidthChanged\",\n    value: function $onImplicitWidthChanged() {\n      if (this.$isUsingImplicitWidth) {\n        this.width = this.implicitWidth;\n        this.$isUsingImplicitWidth = true;\n      }\n    }\n  }, {\n    key: \"$onImplicitHeightChanged\",\n    value: function $onImplicitHeightChanged() {\n      if (this.$isUsingImplicitHeight) {\n        this.height = this.implicitHeight;\n        this.$isUsingImplicitHeight = true;\n      }\n    }\n  }, {\n    key: \"$updateHGeometry\",\n    value: function $updateHGeometry(newVal, oldVal, propName) {\n      var anchors = this.anchors || this;\n      if (this.$updatingHGeometry) {\n        return;\n      }\n      this.$updatingHGeometry = true;\n\n      var flags = QmlWeb.Signal.UniqueConnection;\n      var lM = anchors.leftMargin || anchors.margins;\n      var rM = anchors.rightMargin || anchors.margins;\n      var w = this.width;\n      var left = this.parent ? this.parent.left : 0;\n\n      // Width\n      if (propName === \"width\") {\n        this.$isUsingImplicitWidth = false;\n      }\n\n      // Position TODO: Layouts\n\n      var u = {}; // our update object\n\n      if (anchors.fill !== undefined) {\n        var fill = anchors.fill;\n        var props = fill.$properties;\n        props.left.changed.connect(this, this.$updateHGeometry, flags);\n        props.right.changed.connect(this, this.$updateHGeometry, flags);\n        props.width.changed.connect(this, this.$updateHGeometry, flags);\n\n        this.$isUsingImplicitWidth = false;\n        u.width = fill.width - lM - rM;\n        u.x = fill.left - left + lM;\n        u.left = fill.left + lM;\n        u.right = fill.right - rM;\n        u.horizontalCenter = (u.left + u.right) / 2;\n      } else if (anchors.centerIn !== undefined) {\n        var horizontalCenter = anchors.centerIn.$properties.horizontalCenter;\n        horizontalCenter.changed.connect(this, this.$updateHGeometry, flags);\n\n        u.horizontalCenter = anchors.centerIn.horizontalCenter;\n        u.x = u.horizontalCenter - w / 2 - left;\n        u.left = u.horizontalCenter - w / 2;\n        u.right = u.horizontalCenter + w / 2;\n      } else if (anchors.left !== undefined) {\n        u.left = anchors.left + lM;\n        if (anchors.right !== undefined) {\n          u.right = anchors.right - rM;\n          this.$isUsingImplicitWidth = false;\n          u.width = u.right - u.left;\n          u.x = u.left - left;\n          u.horizontalCenter = (u.right + u.left) / 2;\n        } else if (anchors.horizontalCenter !== undefined) {\n          u.horizontalCenter = anchors.horizontalCenter;\n          this.$isUsingImplicitWidth = false;\n          u.width = (u.horizontalCenter - u.left) * 2;\n          u.x = u.left - left;\n          u.right = 2 * u.horizontalCenter - u.left;\n        } else {\n          u.x = u.left - left;\n          u.right = u.left + w;\n          u.horizontalCenter = u.left + w / 2;\n        }\n      } else if (anchors.right !== undefined) {\n        u.right = anchors.right - rM;\n        if (anchors.horizontalCenter !== undefined) {\n          u.horizontalCenter = anchors.horizontalCenter;\n          this.$isUsingImplicitWidth = false;\n          u.width = (u.right - u.horizontalCenter) * 2;\n          u.x = 2 * u.horizontalCenter - u.right - left;\n          u.left = 2 * u.horizontalCenter - u.right;\n        } else {\n          u.x = u.right - w - left;\n          u.left = u.right - w;\n          u.horizontalCenter = u.right - w / 2;\n        }\n      } else if (anchors.horizontalCenter !== undefined) {\n        u.horizontalCenter = anchors.horizontalCenter;\n        u.x = u.horizontalCenter - w / 2 - left;\n        u.left = u.horizontalCenter - w / 2;\n        u.right = u.horizontalCenter + w / 2;\n      } else {\n        if (this.parent) {\n          var leftProp = this.parent.$properties.left;\n          leftProp.changed.connect(this, this.$updateHGeometry, flags);\n        }\n\n        u.left = this.x + left;\n        u.right = u.left + w;\n        u.horizontalCenter = u.left + w / 2;\n      }\n\n      for (var key in u) {\n        this[key] = u[key];\n      }\n\n      this.$updatingHGeometry = false;\n\n      if (this.parent) this.$updateChildrenRect(this.parent);\n    }\n  }, {\n    key: \"$updateVGeometry\",\n    value: function $updateVGeometry(newVal, oldVal, propName) {\n      var anchors = this.anchors || this;\n      if (this.$updatingVGeometry) {\n        return;\n      }\n      this.$updatingVGeometry = true;\n\n      var flags = QmlWeb.Signal.UniqueConnection;\n      var tM = anchors.topMargin || anchors.margins;\n      var bM = anchors.bottomMargin || anchors.margins;\n      var h = this.height;\n      var top = this.parent ? this.parent.top : 0;\n\n      // HeighttopProp\n      if (propName === \"height\") {\n        this.$isUsingImplicitHeight = false;\n      }\n\n      // Position TODO: Layouts\n\n      var u = {}; // our update object\n\n      if (anchors.fill !== undefined) {\n        var fill = anchors.fill;\n        var props = fill.$properties;\n        props.top.changed.connect(this, this.$updateVGeometry, flags);\n        props.bottom.changed.connect(this, this.$updateVGeometry, flags);\n        props.height.changed.connect(this, this.$updateVGeometry, flags);\n\n        this.$isUsingImplicitHeight = false;\n        u.height = fill.height - tM - bM;\n        u.y = fill.top - top + tM;\n        u.top = fill.top + tM;\n        u.bottom = fill.bottom - bM;\n        u.verticalCenter = (u.top + u.bottom) / 2;\n      } else if (anchors.centerIn !== undefined) {\n        var verticalCenter = anchors.centerIn.$properties.verticalCenter;\n        verticalCenter.changed.connect(this, this.$updateVGeometry, flags);\n\n        u.verticalCenter = anchors.centerIn.verticalCenter;\n        u.y = u.verticalCenter - h / 2 - top;\n        u.top = u.verticalCenter - h / 2;\n        u.bottom = u.verticalCenter + h / 2;\n      } else if (anchors.top !== undefined) {\n        u.top = anchors.top + tM;\n        if (anchors.bottom !== undefined) {\n          u.bottom = anchors.bottom - bM;\n          this.$isUsingImplicitHeight = false;\n          u.height = u.bottom - u.top;\n          u.y = u.top - top;\n          u.verticalCenter = (u.bottom + u.top) / 2;\n        } else if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n          this.$isUsingImplicitHeight = false;\n          u.height = (u.verticalCenter - u.top) * 2;\n          u.y = u.top - top;\n          u.bottom = 2 * u.verticalCenter - u.top;\n        } else {\n          u.y = u.top - top;\n          u.bottom = u.top + h;\n          u.verticalCenter = u.top + h / 2;\n        }\n      } else if (anchors.bottom !== undefined) {\n        u.bottom = anchors.bottom - bM;\n        if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\n          this.$isUsingImplicitHeight = false;\n          u.height = (u.bottom - u.verticalCenter) * 2;\n          u.y = 2 * u.verticalCenter - u.bottom - top;\n          u.top = 2 * u.verticalCenter - u.bottom;\n        } else {\n          u.y = u.bottom - h - top;\n          u.top = u.bottom - h;\n          u.verticalCenter = u.bottom - h / 2;\n        }\n      } else if (anchors.verticalCenter !== undefined) {\n        u.verticalCenter = anchors.verticalCenter;\n        u.y = u.verticalCenter - h / 2 - top;\n        u.top = u.verticalCenter - h / 2;\n        u.bottom = u.verticalCenter + h / 2;\n      } else {\n        if (this.parent) {\n          var topProp = this.parent.$properties.top;\n          topProp.changed.connect(this, this.$updateVGeometry, flags);\n        }\n\n        u.top = this.y + top;\n        u.bottom = u.top + h;\n        u.verticalCenter = u.top + h / 2;\n      }\n\n      for (var key in u) {\n        this[key] = u[key];\n      }\n\n      this.$updatingVGeometry = false;\n\n      if (this.parent) this.$updateChildrenRect(this.parent);\n    }\n  }, {\n    key: \"$updateChildrenRect\",\n    value: function $updateChildrenRect(component) {\n      if (!component || !component.children || component.children.length === 0) {\n        return;\n      }\n      var children = component.children;\n\n      var maxWidth = 0;\n      var maxHeight = 0;\n      var minX = children.length > 0 ? children[0].x : 0;\n      var minY = children.length > 0 ? children[0].y : 0;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        maxWidth = Math.max(maxWidth, child.x + child.width);\n        maxHeight = Math.max(maxHeight, child.y + child.heighth);\n        minX = Math.min(minX, child.x);\n        minY = Math.min(minX, child.y);\n      }\n\n      component.childrenRect.x = minX;\n      component.childrenRect.y = minY;\n      component.childrenRect.width = maxWidth;\n      component.childrenRect.height = maxHeight;\n    }\n  }]);\n\n  return _class49;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListElement\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\"\n}, function () {\n  function _class50(meta) {\n    _classCallCheck(this, _class50);\n\n    QmlWeb.callSuper(this, meta);\n\n    for (var i in meta.object) {\n      if (i[0] !== \"$\") {\n        QmlWeb.createProperty(\"variant\", this, i);\n      }\n    }\n    QmlWeb.applyProperties(meta.object, this, this, this.$context);\n  }\n\n  return _class50;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListModel\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    count: \"int\",\n    $items: \"list\"\n  },\n  defaultProperty: \"$items\"\n}, function () {\n  function _class51(meta) {\n    var _this41 = this;\n\n    _classCallCheck(this, _class51);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$firstItem = true;\n    this.$itemsChanged.connect(this, this.$on$itemsChanged);\n    this.$model = new QmlWeb.JSItemModel();\n    this.$model.data = function (index, role) {\n      return _this41.$items[index][role];\n    };\n    this.$model.rowCount = function () {\n      return _this41.$items.length;\n    };\n  }\n\n  _createClass(_class51, [{\n    key: \"$on$itemsChanged\",\n    value: function $on$itemsChanged(newVal) {\n      this.count = this.$items.length;\n      if (this.$firstItem && newVal.length > 0) {\n        var QMLListElement = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListElement\");\n        this.$firstItem = false;\n        var roleNames = [];\n        var dict = newVal[0];\n        if (dict instanceof QMLListElement) {\n          dict = dict.$properties;\n        }\n        for (var i in dict) {\n          if (i !== \"index\") {\n            roleNames.push(i);\n          }\n        }\n        this.$model.setRoleNames(roleNames);\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(dict) {\n      var index = this.$items.length;\n      var c = 0;\n\n      if (dict instanceof Array) {\n        for (var key in dict) {\n          this.$items.push(dict[key]);\n          c++;\n        }\n      } else {\n        this.$items.push(dict);\n        c = 1;\n      }\n\n      this.$itemsChanged(this.$items);\n      this.$model.rowsInserted(index, index + c);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.$items.length = 0;\n      this.count = 0;\n      this.$model.modelReset();\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this.$items[index];\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(index, dict) {\n      this.$items.splice(index, 0, dict);\n      this.$itemsChanged(this.$items);\n      this.$model.rowsInserted(index, index + 1);\n    }\n  }, {\n    key: \"move\",\n    value: function move(from, to, n) {\n      var vals = this.$items.splice(from, n);\n      for (var i = 0; i < vals.length; i++) {\n        this.$items.splice(to + i, 0, vals[i]);\n      }\n      this.$model.rowsMoved(from, from + n, to);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(index) {\n      this.$items.splice(index, 1);\n      this.$model.rowsRemoved(index, index + 1);\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, dict) {\n      this.$items[index] = dict;\n      this.$model.dataChanged(index, index);\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(index, property, value) {\n      this.$items[index][property] = value;\n      this.$model.dataChanged(index, index);\n    }\n  }]);\n\n  return _class51;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ListView\",\n  versions: /.*/,\n  baseClass: \"Repeater\",\n  properties: {\n    orientation: \"enum\",\n    spacing: \"real\"\n  }\n}, function () {\n  function _class52(meta) {\n    _classCallCheck(this, _class52);\n\n    QmlWeb.callSuper(this, meta);\n    this.modelChanged.connect(this, this.$styleChanged);\n    this.delegateChanged.connect(this, this.$styleChanged);\n    this.orientationChanged.connect(this, this.$styleChanged);\n    this.spacingChanged.connect(this, this.$styleChanged);\n    this._childrenInserted.connect(this, this.$applyStyleOnItem);\n  }\n\n  _createClass(_class52, [{\n    key: \"container\",\n    value: function container() {\n      return this;\n    }\n  }, {\n    key: \"$applyStyleOnItem\",\n    value: function $applyStyleOnItem($item) {\n      var Qt = QmlWeb.Qt;\n      $item.dom.style.position = \"initial\";\n      if (this.orientation === Qt.Horizontal) {\n        $item.dom.style.display = \"inline-block\";\n        if ($item !== this.$items[0]) {\n          $item.dom.style[\"margin-left\"] = this.spacing + \"px\";\n        }\n      } else {\n        $item.dom.style.display = \"block\";\n        if ($item !== this.$items[0]) {\n          $item.dom.style[\"margin-top\"] = this.spacing + \"px\";\n        }\n      }\n    }\n  }, {\n    key: \"$styleChanged\",\n    value: function $styleChanged() {\n      for (var i = 0; i < this.$items.length; ++i) {\n        this.$applyStyleOnItem(this.$items[i]);\n      }\n    }\n  }]);\n\n  return _class52;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Loader\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    active: { type: \"bool\", initialValue: true },\n    asynchronous: \"bool\",\n    item: \"var\",\n    progress: \"real\",\n    source: \"url\",\n    sourceComponent: \"Component\",\n    status: { type: \"enum\", initialValue: 1 }\n  },\n  signals: {\n    loaded: []\n  }\n}, function () {\n  function _class53(meta) {\n    _classCallCheck(this, _class53);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$sourceUrl = \"\";\n\n    this.activeChanged.connect(this, this.$onActiveChanged);\n    this.sourceChanged.connect(this, this.$onSourceChanged);\n    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);\n    this.widthChanged.connect(this, this.$updateGeometry);\n    this.heightChanged.connect(this, this.$updateGeometry);\n  }\n\n  _createClass(_class53, [{\n    key: \"$onActiveChanged\",\n    value: function $onActiveChanged() {\n      if (!this.active) {\n        this.$unload();\n        return;\n      }\n      if (this.source) {\n        this.$onSourceChanged(this.source);\n      } else if (this.sourceComponent) {\n        this.$onSourceComponentChanged(this.sourceComponent);\n      }\n    }\n  }, {\n    key: \"$onSourceChanged\",\n    value: function $onSourceChanged(fileName) {\n      // TODO\n      // if (fileName == this.$sourceUrl && this.item !== undefined) return;\n      if (!this.active) return;\n      this.$unload();\n\n      if (!fileName) {\n        this.sourceComponent = null;\n        this.$sourceUrl = fileName;\n        return;\n      }\n\n      var tree = QmlWeb.engine.loadComponent(fileName);\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var meta = { object: tree, context: this.$context, parent: this };\n      var qmlComponent = new QMLComponent(meta);\n      qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);\n      qmlComponent.$imports = tree.$imports;\n      qmlComponent.$file = tree.$file;\n      QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath, qmlComponent.importContextId);\n      var loadedComponent = this.$createComponentObject(qmlComponent, this);\n      this.sourceComponent = loadedComponent;\n      this.$sourceUrl = fileName;\n    }\n  }, {\n    key: \"$onSourceComponentChanged\",\n    value: function $onSourceComponentChanged(newItem) {\n      if (!this.active) return;\n      this.$unload();\n\n      if (!newItem) {\n        this.item = null;\n        return;\n      }\n\n      var QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\n      var qmlComponent = newItem;\n      if (newItem instanceof QMLComponent) {\n        qmlComponent = newItem.$createObject(this, {}, this);\n      }\n      qmlComponent.parent = this;\n      this.item = qmlComponent;\n      this.$updateGeometry();\n      if (this.item) {\n        this.loaded();\n      }\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(url, options) {\n      this.$sourceUrl = url;\n      this.props = options;\n      this.source = url;\n    }\n  }, {\n    key: \"$unload\",\n    value: function $unload() {\n      if (!this.item) return;\n      this.item.$delete();\n      this.item.parent = undefined;\n      this.item = undefined;\n    }\n  }, {\n    key: \"$callOnCompleted\",\n    value: function $callOnCompleted(child) {\n      child.Component.completed();\n      var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n      for (var i = 0; i < child.$tidyupList.length; i++) {\n        if (child.$tidyupList[i] instanceof QMLBaseObject) {\n          this.$callOnCompleted(child.$tidyupList[i]);\n        }\n      }\n    }\n  }, {\n    key: \"$createComponentObject\",\n    value: function $createComponentObject(qmlComponent, parent) {\n      var newComponent = qmlComponent.createObject(parent);\n      if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\n        // We don't call those on first creation, as they will be called\n        // by the regular creation-procedures at the right time.\n        QmlWeb.engine.$initializePropertyBindings();\n        this.$callOnCompleted(newComponent);\n      }\n      return newComponent;\n    }\n  }, {\n    key: \"$updateGeometry\",\n    value: function $updateGeometry() {\n      // Loader size doesn't exist\n      if (!this.width) {\n        this.width = this.item ? this.item.width : 0;\n      } else if (this.item) {\n        // Loader size exists\n        this.item.width = this.width;\n      }\n\n      if (!this.height) {\n        this.height = this.item ? this.item.height : 0;\n      } else if (this.item) {\n        // Loader size exists\n        this.item.height = this.height;\n      }\n    }\n  }]);\n\n  return _class53;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"MouseArea\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    acceptedButtons: { type: \"variant\", initialValue: 1 }, // Qt.LeftButton\n    enabled: { type: \"bool\", initialValue: true },\n    hoverEnabled: \"bool\",\n    mouseX: \"real\",\n    mouseY: \"real\",\n    pressed: \"bool\",\n    containsMouse: \"bool\",\n    pressedButtons: { type: \"variant\", initialValue: 0 },\n    cursorShape: \"enum\" // Qt.ArrowCursor\n  },\n  signals: {\n    clicked: [{ type: \"variant\", name: \"mouse\" }],\n    entered: [],\n    exited: [],\n    positionChanged: [{ type: \"variant\", name: \"mouse\" }],\n    wheel: [{ type: \"variant\", name: \"wheel\" }]\n  }\n}, function () {\n  function _class54(meta) {\n    var _this42 = this;\n\n    _classCallCheck(this, _class54);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.dom.style.pointerEvents = \"all\";\n\n    // IE does not handle mouse clicks to transparent divs, so we have\n    // to set a background color and make it invisible using opacity\n    // as that doesn't affect the mouse handling.\n    this.dom.style.backgroundColor = \"white\";\n    this.dom.style.opacity = 0;\n\n    this.cursorShapeChanged.connect(this, this.$onCursorShapeChanged);\n\n    this.dom.addEventListener(\"click\", function (e) {\n      return _this42.$handleClick(e);\n    });\n    this.dom.addEventListener(\"contextmenu\", function (e) {\n      return _this42.$handleClick(e);\n    });\n    var handleMouseMove = function handleMouseMove(e) {\n      if (!_this42.enabled || !_this42.hoverEnabled && !_this42.pressed) return;\n      _this42.$handlePositionChanged(e);\n    };\n    var handleMouseUp = function handleMouseUp() {\n      _this42.pressed = false;\n      _this42.pressedButtons = 0;\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n      _this42.$clientTransform = undefined;\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n    this.dom.addEventListener(\"mousedown\", function (e) {\n      if (!_this42.enabled) return;\n      // Handle scale and translate transformations\n      var boundingRect = _this42.dom.getBoundingClientRect();\n      _this42.$clientTransform = {\n        x: boundingRect.left,\n        y: boundingRect.top,\n        xScale: _this42.width ? (boundingRect.right - boundingRect.left) / _this42.width : 1,\n        yScale: _this42.height ? (boundingRect.bottom - boundingRect.top) / _this42.height : 1\n      };\n      var mouse = _this42.$eventToMouse(e);\n      _this42.mouseX = mouse.x;\n      _this42.mouseY = mouse.y;\n      _this42.pressed = true;\n      _this42.pressedButtons = mouse.button;\n      document.addEventListener(\"mouseup\", handleMouseUp);\n      document.addEventListener(\"mousemove\", handleMouseMove);\n    });\n    this.dom.addEventListener(\"mouseover\", function () {\n      _this42.containsMouse = true;\n      _this42.entered();\n    });\n    this.dom.addEventListener(\"mouseout\", function () {\n      _this42.containsMouse = false;\n      _this42.exited();\n    });\n    // This is to emit positionChanged for `hoverEnabled` only. When `pressed`,\n    // `positionChanged` is handled by a temporary `mousemove` event listener\n    // on `document`.\n    this.dom.addEventListener(\"mousemove\", function (e) {\n      if (!_this42.enabled || !_this42.hoverEnabled || _this42.pressed) return;\n      _this42.$handlePositionChanged(e);\n    });\n    this.dom.addEventListener(\"wheel\", function (e) {\n      _this42.$handleWheel(e);\n    });\n  }\n\n  _createClass(_class54, [{\n    key: \"$onCursorShapeChanged\",\n    value: function $onCursorShapeChanged() {\n      this.dom.style.cursor = this.$cursorShapeToCSS();\n    }\n  }, {\n    key: \"$handlePositionChanged\",\n    value: function $handlePositionChanged(e) {\n      var mouse = this.$eventToMouse(e);\n      this.mouseX = mouse.x;\n      this.mouseY = mouse.y;\n      this.positionChanged(mouse);\n    }\n  }, {\n    key: \"$handleWheel\",\n    value: function $handleWheel(e) {\n      var wheel = this.$eventToMouse(e);\n      wheel.angleDelta = { x: e.deltaX, y: e.deltaY };\n      wheel.accepted = false;\n\n      this.wheel(wheel);\n\n      if (wheel.accepted) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  }, {\n    key: \"$handleClick\",\n    value: function $handleClick(e) {\n      var mouse = this.$eventToMouse(e);\n      if (this.enabled && this.acceptedButtons & mouse.button) {\n        this.clicked(mouse);\n      }\n      // This decides whether to show the browser's context menu on right click or\n      // not\n      return !(this.acceptedButtons & QmlWeb.Qt.RightButton);\n    }\n  }, {\n    key: \"$eventToMouse\",\n    value: function $eventToMouse(e) {\n      var Qt = QmlWeb.Qt;\n      var mouse = {\n        accepted: true,\n        button: e.button === 0 ? Qt.LeftButton : e.button === 1 ? Qt.MiddleButton : e.button === 2 ? Qt.RightButton : 0,\n        modifiers: e.ctrlKey * Qt.CtrlModifier | e.altKey * Qt.AltModifier | e.shiftKey * Qt.ShiftModifier | e.metaKey * Qt.MetaModifier\n      };\n      if (this.$clientTransform) {\n        // Handle scale and translate transformations\n        mouse.x = (e.clientX - this.$clientTransform.x) / this.$clientTransform.xScale;\n        mouse.y = (e.clientY - this.$clientTransform.y) / this.$clientTransform.yScale;\n      } else {\n        mouse.x = e.offsetX || e.layerX;\n        mouse.y = e.offsetY || e.layerY;\n      }\n      return mouse;\n    }\n\n    // eslint-disable-next-line complexity\n\n  }, {\n    key: \"$cursorShapeToCSS\",\n    value: function $cursorShapeToCSS() {\n      var Qt = QmlWeb.Qt;\n      switch (this.cursorShape) {\n        case Qt.ArrowCursor:\n          return \"default\";\n        case Qt.UpArrowCursor:\n          return \"n-resize\";\n        case Qt.CrossCursor:\n          return \"crosshair\";\n        case Qt.WaitCursor:\n          return \"wait\";\n        case Qt.IBeamCursor:\n          return \"text\";\n        case Qt.SizeVerCursor:\n          return \"ew-resize\";\n        case Qt.SizeHorCursor:\n          return \"ns-resize\";\n        case Qt.SizeBDiagCursor:\n          return \"nesw-resize\";\n        case Qt.SizeFDiagCursor:\n          return \"nwse-resize\";\n        case Qt.SizeAllCursor:\n          return \"all-scroll\";\n        case Qt.BlankCursor:\n          return \"none\";\n        case Qt.SplitVCursor:\n          return \"row-resize\";\n        case Qt.SplitHCursor:\n          return \"col-resize\";\n        case Qt.PointingHandCursor:\n          return \"pointer\";\n        case Qt.ForbiddenCursor:\n          return \"not-allowed\";\n        case Qt.WhatsThisCursor:\n          return \"help\";\n        case Qt.BusyCursor:\n          return \"progress\";\n        case Qt.OpenHandCursor:\n          return \"grab\";\n        case Qt.ClosedHandCursor:\n          return \"grabbing\";\n        case Qt.DragCopyCursor:\n          return \"copy\";\n        case Qt.DragMoveCursor:\n          return \"move\";\n        case Qt.DragLinkCursor:\n          return \"alias\";\n        //case Qt.BitmapCursor: return \"auto\";\n        //case Qt.CustomCursor: return \"auto\";\n      }\n      return \"auto\";\n    }\n  }]);\n\n  return _class54;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"NumberAnimation\",\n  versions: /.*/,\n  baseClass: \"PropertyAnimation\"\n}, function () {\n  function _class55(meta) {\n    var _this43 = this;\n\n    _classCallCheck(this, _class55);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$at = 0;\n    this.$loop = 0;\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this43.$ticker.apply(_this43, arguments);\n    });\n    this.runningChanged.connect(this, this.$onRunningChanged);\n  }\n\n  _createClass(_class55, [{\n    key: \"$startLoop\",\n    value: function $startLoop() {\n      for (var i in this.$actions) {\n        var _action3 = this.$actions[i];\n        _action3.from = _action3.from !== undefined ? _action3.from : _action3.target[_action3.property];\n      }\n      this.$at = 0;\n    }\n  }, {\n    key: \"$ticker\",\n    value: function $ticker(now, elapsed) {\n      if (!this.running && this.$loop !== -1 || this.paused) {\n        // $loop === -1 is a marker to just finish this run\n        return;\n      }\n      if (this.$at === 0 && this.$loop === 0 && !this.$actions.length) {\n        this.$redoActions();\n      }\n      this.$at += elapsed / this.duration;\n      if (this.$at >= 1) {\n        this.complete();\n        return;\n      }\n      for (var i in this.$actions) {\n        var _action4 = this.$actions[i];\n        var value = _action4.from + (_action4.to - _action4.from) * this.easing.$valueForProgress(this.$at);\n        var property = _action4.target.$properties[_action4.property];\n        property.set(value, QmlWeb.QMLProperty.ReasonAnimation);\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged(newVal) {\n      if (newVal) {\n        this.$startLoop();\n        this.paused = false;\n      } else if (this.alwaysRunToEnd && this.$at < 1) {\n        this.$loop = -1; // -1 is used as a marker to stop\n      } else {\n        this.$loop = 0;\n        this.$actions = [];\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      for (var i in this.$actions) {\n        var _action5 = this.$actions[i];\n        var property = _action5.target.$properties[_action5.property];\n        property.set(_action5.to, QmlWeb.QMLProperty.ReasonAnimation);\n      }\n      this.$loop++;\n      if (this.$loop === this.loops) {\n        this.running = false;\n      } else if (!this.running) {\n        this.$actions = [];\n      } else {\n        this.$startLoop(this);\n      }\n    }\n  }]);\n\n  return _class55;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"OpacityAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class56(meta) {\n    _classCallCheck(this, _class56);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class56;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ParallelAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  enums: {\n    Animation: { Infinite: Math.Infinite }\n  },\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class57(meta) {\n    var _this44 = this;\n\n    _classCallCheck(this, _class57);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$runningAnimations = 0;\n\n    this.animationsChanged.connect(this, this.$onAnimationsChanged);\n\n    QmlWeb.engine.$registerStart(function () {\n      if (!_this44.running) return;\n      self.running = false; // toggled back by start();\n      self.start();\n    });\n    QmlWeb.engine.$registerStop(function () {\n      return _this44.stop();\n    });\n  }\n\n  _createClass(_class57, [{\n    key: \"$onAnimationsChanged\",\n    value: function $onAnimationsChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.runningChanged.connect(this, this.$animationFinished, flags);\n      }\n    }\n  }, {\n    key: \"$animationFinished\",\n    value: function $animationFinished(newVal) {\n      this.$runningAnimations += newVal ? 1 : -1;\n      if (this.$runningAnimations === 0) {\n        this.running = false;\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.running) return;\n      this.running = true;\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].start();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) return;\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].stop();\n      }\n      this.running = false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.stop();\n    }\n  }]);\n\n  return _class57;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PauseAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 }\n  }\n}, function () {\n  function _class58(meta) {\n    var _this45 = this;\n\n    _classCallCheck(this, _class58);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$at = 0;\n\n    QmlWeb.engine.$addTicker(function () {\n      return _this45.$ticker.apply(_this45, arguments);\n    });\n    this.runningChanged.connect(this, this.$onRunningChanged);\n  }\n\n  _createClass(_class58, [{\n    key: \"$ticker\",\n    value: function $ticker(now, elapsed) {\n      if (!this.running || this.paused) {\n        return;\n      }\n      this.$at += elapsed / this.duration;\n      if (this.$at >= 1) {\n        this.complete();\n      }\n    }\n  }, {\n    key: \"$onRunningChanged\",\n    value: function $onRunningChanged(newVal) {\n      if (newVal) {\n        this.$at = 0;\n        this.paused = false;\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.running = false;\n    }\n  }]);\n\n  return _class58;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Positioner\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    spacing: \"int\",\n    padding: \"int\"\n  }\n}, function () {\n  function _class59(meta) {\n    _classCallCheck(this, _class59);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class59, [{\n    key: \"$onChildrenChanged\",\n    value: function $onChildrenChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.widthChanged.connect(this, this.layoutChildren, flags);\n        child.heightChanged.connect(this, this.layoutChildren, flags);\n        child.visibleChanged.connect(this, this.layoutChildren, flags);\n      }\n    }\n  }]);\n\n  return _class59;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    duration: { type: \"int\", initialValue: 250 },\n    from: \"real\",\n    to: \"real\",\n    properties: \"string\",\n    property: \"string\",\n    target: \"QtObject\",\n    targets: \"list\"\n  }\n}, function () {\n  function _class60(meta) {\n    _classCallCheck(this, _class60);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.easing = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.easing, {\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\n      amplitude: { type: \"real\", initialValue: 1 },\n      overshoot: { type: \"real\", initialValue: 1.70158 },\n      period: { type: \"real\", initialValue: 0.3 },\n      bezierCurve: \"list\"\n    });\n\n    this.easing.$valueForProgress = function (t) {\n      return QmlWeb.$ease(this.type, this.period, this.amplitude, this.overshoot, t);\n    };\n\n    this.$props = [];\n    this.$targets = [];\n    this.$actions = [];\n\n    this.targetChanged.connect(this, this.$redoTargets);\n    this.targetsChanged.connect(this, this.$redoTargets);\n    this.propertyChanged.connect(this, this.$redoProperties);\n    this.propertiesChanged.connect(this, this.$redoProperties);\n\n    if (meta.object.$on !== undefined) {\n      this.property = meta.object.$on;\n      this.target = this.$parent;\n      this.running = true;\n    }\n  }\n\n  _createClass(_class60, [{\n    key: \"$redoActions\",\n    value: function $redoActions() {\n      this.$actions = [];\n      for (var i = 0; i < this.$targets.length; i++) {\n        for (var j in this.$props) {\n          this.$actions.push({\n            target: this.$targets[i],\n            property: this.$props[j],\n            from: this.from,\n            to: this.to\n          });\n        }\n      }\n    }\n  }, {\n    key: \"$redoProperties\",\n    value: function $redoProperties() {\n      this.$props = this.properties.split(\",\");\n\n      // Remove whitespaces\n      for (var i = 0; i < this.$props.length; i++) {\n        var matches = this.$props[i].match(/\\w+/);\n        if (matches) {\n          this.$props[i] = matches[0];\n        } else {\n          this.$props.splice(i, 1);\n          i--;\n        }\n      }\n      // Merge properties and property\n      if (this.property && this.$props.indexOf(this.property) === -1) {\n        this.$props.push(this.property);\n      }\n    }\n  }, {\n    key: \"$redoTargets\",\n    value: function $redoTargets() {\n      this.$targets = this.targets.slice();\n      if (this.target && this.$targets.indexOf(this.target) === -1) {\n        this.$targets.push(this.target);\n      }\n    }\n  }]);\n\n  return _class60;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"PropertyChanges\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    target: \"QtObject\",\n    explicit: \"bool\",\n    restoreEntryValues: { type: \"bool\", initialValue: true }\n  }\n}, function () {\n  function _class61(meta) {\n    _classCallCheck(this, _class61);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$actions = [];\n  }\n\n  _createClass(_class61, [{\n    key: \"$setCustomData\",\n    value: function $setCustomData(property, value) {\n      this.$actions.push({ property: property, value: value });\n    }\n  }]);\n\n  return _class61;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rectangle\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    color: { type: \"color\", initialValue: \"white\" },\n    radius: \"real\"\n  }\n}, function () {\n  function _class62(meta) {\n    _classCallCheck(this, _class62);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.border = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.border, {\n      color: { type: \"color\", initialValue: \"black\" },\n      width: { type: \"int\", initialValue: 1 }\n    });\n    this.$borderActive = false;\n\n    var bg = this.impl = document.createElement(\"div\");\n    bg.style.pointerEvents = \"none\";\n    bg.style.position = \"absolute\";\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = \"0px\";\n    bg.style.borderWidth = \"0px\";\n    bg.style.borderStyle = \"solid\";\n    bg.style.borderColor = this.border.color.$css;\n    bg.style.backgroundColor = this.color.$css;\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\n    this.border.colorChanged.connect(this, this.border$onColorChanged);\n    this.border.widthChanged.connect(this, this.border$onWidthChanged);\n    this.widthChanged.connect(this, this.$updateBorder);\n    this.heightChanged.connect(this, this.$updateBorder);\n  }\n\n  _createClass(_class62, [{\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.backgroundColor = newVal.$css;\n    }\n  }, {\n    key: \"border$onColorChanged\",\n    value: function border$onColorChanged(newVal) {\n      this.$borderActive = true;\n      this.impl.style.borderColor = newVal.$css;\n      this.$updateBorder();\n    }\n  }, {\n    key: \"border$onWidthChanged\",\n    value: function border$onWidthChanged() {\n      this.$borderActive = true;\n      this.$updateBorder();\n    }\n  }, {\n    key: \"$onRadiusChanged\",\n    value: function $onRadiusChanged(newVal) {\n      this.impl.style.borderRadius = newVal + \"px\";\n    }\n  }, {\n    key: \"$updateBorder\",\n    value: function $updateBorder() {\n      var border = this.$borderActive ? Math.max(0, this.border.width) : 0;\n      var style = this.impl.style;\n      if (border * 2 > this.width || border * 2 > this.height) {\n        // Border is covering the whole background\n        style.borderWidth = \"0px\";\n        style.borderTopWidth = this.height + \"px\";\n      } else {\n        style.borderWidth = border + \"px\";\n      }\n    }\n  }]);\n\n  return _class62;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"RegExpValidator\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    regExp: \"var\"\n  }\n}, function () {\n  function _class63(meta) {\n    _classCallCheck(this, _class63);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  _createClass(_class63, [{\n    key: \"validate\",\n    value: function validate(string) {\n      if (!this.regExp) return true;\n      return this.regExp.test(string);\n    }\n  }]);\n\n  return _class63;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Repeater\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    delegate: \"Component\",\n    model: { type: \"variant\", initialValue: 0 },\n    count: \"int\"\n  },\n  signals: {\n    _childrenInserted: []\n  },\n  defaultProperty: \"delegate\"\n}, function () {\n  function _class64(meta) {\n    _classCallCheck(this, _class64);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.parent = meta.parent;\n    // TODO: some (all ?) of the components including Repeater needs to know own\n    // parent at creation time. Please consider this major change.\n\n    this.$completed = false;\n    this.$items = []; // List of created items\n\n    this.modelChanged.connect(this, this.$onModelChanged);\n    this.delegateChanged.connect(this, this.$onDelegateChanged);\n    this.parentChanged.connect(this, this.$onParentChanged);\n  }\n\n  _createClass(_class64, [{\n    key: \"container\",\n    value: function container() {\n      return this.parent;\n    }\n  }, {\n    key: \"itemAt\",\n    value: function itemAt(index) {\n      return this.$items[index];\n    }\n  }, {\n    key: \"$onModelChanged\",\n    value: function $onModelChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$onDelegateChanged\",\n    value: function $onDelegateChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$onParentChanged\",\n    value: function $onParentChanged() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$getModel\",\n    value: function $getModel() {\n      var QMLListModel = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListModel\");\n      return this.model instanceof QMLListModel ? this.model.$model : this.model;\n    }\n  }, {\n    key: \"$applyModel\",\n    value: function $applyModel() {\n      if (!this.delegate || !this.parent) {\n        return;\n      }\n      var model = this.$getModel();\n      if (model instanceof QmlWeb.JSItemModel) {\n        var flags = QmlWeb.Signal.UniqueConnection;\n        model.dataChanged.connect(this, this.$_onModelDataChanged, flags);\n        model.rowsInserted.connect(this, this.$_onRowsInserted, flags);\n        model.rowsMoved.connect(this, this.$_onRowsMoved, flags);\n        model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);\n        model.modelReset.connect(this, this.$_onModelReset, flags);\n\n        this.$removeChildren(0, this.$items.length);\n        this.$insertChildren(0, model.rowCount());\n      } else if (typeof model === \"number\") {\n        if (this.$items.length > model) {\n          // have more than we need\n          this.$removeChildren(model, this.$items.length);\n        } else {\n          // need more\n          this.$insertChildren(this.$items.length, model);\n        }\n      } else if (model instanceof Array) {\n        this.$removeChildren(0, this.$items.length);\n        this.$insertChildren(0, model.length);\n      }\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$callOnCompleted\",\n    value: function $callOnCompleted(child) {\n      child.Component.completed();\n      var QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\n      for (var i = 0; i < child.$tidyupList.length; i++) {\n        if (child.$tidyupList[i] instanceof QMLBaseObject) {\n          this.$callOnCompleted(child.$tidyupList[i]);\n        }\n      }\n    }\n  }, {\n    key: \"$_onModelDataChanged\",\n    value: function $_onModelDataChanged(startIndex, endIndex, roles) {\n      var model = this.$getModel();\n      var roleNames = roles || model.roleNames;\n      for (var index = startIndex; index <= endIndex; index++) {\n        var _item3 = this.$items[index];\n        var modelData = _item3.$properties.model;\n        for (var i in roleNames) {\n          var roleName = roleNames[i];\n          var roleData = model.data(index, roleName);\n          _item3.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);\n          modelData[roleName] = roleData;\n        }\n        _item3.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, _item3, this.model.$context);\n      }\n    }\n  }, {\n    key: \"$_onRowsInserted\",\n    value: function $_onRowsInserted(startIndex, endIndex) {\n      this.$insertChildren(startIndex, endIndex);\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$_onRowsMoved\",\n    value: function $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\n      var vals = this.$items.splice(sourceStartIndex, sourceEndIndex - sourceStartIndex);\n      for (var i = 0; i < vals.length; i++) {\n        this.$items.splice(destinationIndex + i, 0, vals[i]);\n      }\n      var smallestChangedIndex = sourceStartIndex < destinationIndex ? sourceStartIndex : destinationIndex;\n      for (var _i11 = smallestChangedIndex; _i11 < this.$items.length; _i11++) {\n        this.$items[_i11].index = _i11;\n      }\n    }\n  }, {\n    key: \"$_onRowsRemoved\",\n    value: function $_onRowsRemoved(startIndex, endIndex) {\n      this.$removeChildren(startIndex, endIndex);\n      for (var i = startIndex; i < this.$items.length; i++) {\n        this.$items[i].index = i;\n      }\n      this.count = this.$items.length;\n    }\n  }, {\n    key: \"$_onModelReset\",\n    value: function $_onModelReset() {\n      this.$applyModel();\n    }\n  }, {\n    key: \"$insertChildren\",\n    value: function $insertChildren(startIndex, endIndex) {\n      if (endIndex <= 0) {\n        this.count = 0;\n        return;\n      }\n\n      var QMLOperationState = QmlWeb.QMLOperationState;\n      var createProperty = QmlWeb.createProperty;\n      var model = this.$getModel();\n      var index = void 0;\n      for (index = startIndex; index < endIndex; index++) {\n        var newItem = this.delegate.$createObject(this.parent);\n        createProperty(\"int\", newItem, \"index\", { initialValue: index });\n\n        if (typeof model === \"number\" || model instanceof Array) {\n          if (typeof newItem.$properties.modelData === \"undefined\") {\n            createProperty(\"variant\", newItem, \"modelData\");\n          }\n          var value = model instanceof Array ? model[index] : typeof model === \"number\" ? index : \"undefined\";\n          newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit, newItem, model.$context);\n        } else {\n          // QML exposes a \"model\" property in the scope that contains all role\n          // data.\n          var modelData = {};\n          for (var i = 0; i < model.roleNames.length; i++) {\n            var roleName = model.roleNames[i];\n            if (typeof newItem.$properties[roleName] === \"undefined\") {\n              createProperty(\"variant\", newItem, roleName);\n            }\n            var roleData = model.data(index, roleName);\n            modelData[roleName] = roleData;\n            newItem.$properties[roleName].set(roleData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);\n          }\n          if (typeof newItem.$properties.model === \"undefined\") {\n            createProperty(\"variant\", newItem, \"model\");\n          }\n          newItem.$properties.model.set(modelData, QmlWeb.QMLProperty.ReasonInit, newItem, this.model.$context);\n        }\n\n        this.$items.splice(index, 0, newItem);\n\n        // parent must be set after the roles have been added to newItem scope in\n        // case we are outside of QMLOperationState.Init and parentChanged has\n        // any side effects that result in those roleNames being referenced.\n        newItem.parent = this.parent;\n\n        // TODO debug this. Without check to Init, Completed sometimes called\n        // twice.. But is this check correct?\n        if (QmlWeb.engine.operationState !== QMLOperationState.Init && QmlWeb.engine.operationState !== QMLOperationState.Idle) {\n          // We don't call those on first creation, as they will be called\n          // by the regular creation-procedures at the right time.\n          this.$callOnCompleted(newItem);\n        }\n      }\n      if (QmlWeb.engine.operationState !== QMLOperationState.Init) {\n        // We don't call those on first creation, as they will be called\n        // by the regular creation-procedures at the right time.\n        QmlWeb.engine.$initializePropertyBindings();\n      }\n\n      if (index > 0) {\n        this.container().childrenChanged();\n      }\n\n      for (var _i12 = endIndex; _i12 < this.$items.length; _i12++) {\n        this.$items[_i12].index = _i12;\n      }\n    }\n  }, {\n    key: \"$removeChildren\",\n    value: function $removeChildren(startIndex, endIndex) {\n      var removed = this.$items.splice(startIndex, endIndex - startIndex);\n      for (var index in removed) {\n        removed[index].$delete();\n        this.$removeChildProperties(removed[index]);\n      }\n    }\n  }, {\n    key: \"$removeChildProperties\",\n    value: function $removeChildProperties(child) {\n      var signals = QmlWeb.engine.completedSignals;\n      signals.splice(signals.indexOf(child.Component.completed), 1);\n      for (var i = 0; i < child.children.length; i++) {\n        this.$removeChildProperties(child.children[i]);\n      }\n    }\n  }]);\n\n  return _class64;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Rotation\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    angle: \"real\"\n  }\n}, function () {\n  function _class65(meta) {\n    _classCallCheck(this, _class65);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.axis = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.axis, {\n      x: \"real\",\n      y: \"real\",\n      z: { type: \"real\", initialValue: 1 }\n    });\n\n    this.origin = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.origin, {\n      x: \"real\",\n      y: \"real\"\n    });\n\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n    this.$parent.$updateTransform();\n  }\n\n  _createClass(_class65, [{\n    key: \"$updateOrigin\",\n    value: function $updateOrigin() {\n      var style = this.$parent.dom.style;\n      style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n      style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n    }\n  }]);\n\n  return _class65;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"RotationAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class66(meta) {\n    _classCallCheck(this, _class66);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class66;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Row\",\n  versions: /.*/,\n  baseClass: \"Positioner\",\n  properties: {\n    layoutDirection: \"enum\"\n  }\n}, function () {\n  function _class67(meta) {\n    _classCallCheck(this, _class67);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n  }\n\n  _createClass(_class67, [{\n    key: \"layoutChildren\",\n    value: function layoutChildren() {\n      var curPos = this.padding;\n      var maxHeight = 0;\n      // When layoutDirection is RightToLeft we need oposite order\n      var i = this.layoutDirection === 1 ? this.children.length - 1 : 0;\n      var endPoint = this.layoutDirection === 1 ? -1 : this.children.length;\n      var step = this.layoutDirection === 1 ? -1 : 1;\n      for (; i !== endPoint; i += step) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height)) {\n          continue;\n        }\n        maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n        child.x = curPos;\n        if (this.padding > 0) child.y = this.padding;\n\n        curPos += child.width + this.spacing;\n      }\n      this.implicitHeight = maxHeight + this.padding * 2;\n      // We want no spacing at the right side\n      this.implicitWidth = curPos - this.spacing + this.padding;\n    }\n  }]);\n\n  return _class67;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Scale\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    xScale: { type: \"real\", initialValue: 1 },\n    yScale: { type: \"real\", initialValue: 1 }\n  }\n}, function () {\n  function _class68(meta) {\n    _classCallCheck(this, _class68);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.origin = new QmlWeb.QObject(this);\n    QmlWeb.createProperties(this.origin, {\n      x: \"real\",\n      y: \"real\"\n    });\n\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, this.$updateOrigin);\n    this.origin.yChanged.connect(this, this.$updateOrigin);\n\n    /* QML default origin is top-left, while CSS default origin is centre, so\r\n     * $updateOrigin must be called to set the initial transformOrigin. */\n    this.$updateOrigin();\n  }\n\n  _createClass(_class68, [{\n    key: \"$updateOrigin\",\n    value: function $updateOrigin() {\n      var style = this.$parent.dom.style;\n      style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n      style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n    }\n  }]);\n\n  return _class68;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ScaleAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class69(meta) {\n    _classCallCheck(this, _class69);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class69;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SequentialAnimation\",\n  versions: /.*/,\n  baseClass: \"Animation\",\n  properties: {\n    animations: \"list\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class70(meta) {\n    var _this46 = this;\n\n    _classCallCheck(this, _class70);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.animationsChanged.connect(this, this.$onAnimatonsChanged);\n\n    QmlWeb.engine.$registerStart(function () {\n      if (!_this46.running) return;\n      _this46.running = false; // toggled back by start();\n      _this46.start();\n    });\n    QmlWeb.engine.$registerStop(function () {\n      return self.stop();\n    });\n  }\n\n  _createClass(_class70, [{\n    key: \"$onAnimatonsChanged\",\n    value: function $onAnimatonsChanged() {\n      var flags = QmlWeb.Signal.UniqueConnection;\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.runningChanged.connect(this, this.$nextAnimation, flags);\n      }\n    }\n  }, {\n    key: \"$nextAnimation\",\n    value: function $nextAnimation(proceed) {\n      if (this.running && !proceed) {\n        this.$curIndex++;\n        if (this.$curIndex < this.animations.length) {\n          var anim = this.animations[this.$curIndex];\n          console.log(\"nextAnimation\", this, this.$curIndex, anim);\n          anim.start();\n        } else {\n          this.$passedLoops++;\n          if (this.$passedLoops >= this.loops) {\n            this.complete();\n          } else {\n            this.$curIndex = -1;\n            this.$nextAnimation();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.running) return;\n      this.running = true;\n      this.$curIndex = -1;\n      this.$passedLoops = 0;\n      this.$nextAnimation();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) return;\n      this.running = false;\n      if (this.$curIndex < this.animations.length) {\n        this.animations[this.$curIndex].stop();\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (!this.running) return;\n      if (this.$curIndex < this.animations.length) {\n        // Stop current animation\n        this.animations[this.$curIndex].stop();\n      }\n      this.running = false;\n    }\n  }]);\n\n  return _class70;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ShaderEffect\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    ShaderEffect: {\n      NoCulling: 0, BackFaceCulling: 1, FrontFaceCulling: 2,\n      Compiled: 0, Uncompiled: 1, Error: 2\n    }\n  },\n  properties: {\n    blending: { type: \"bool\", initialValue: true },\n    cullMode: \"enum\", // ShaderEffect.NoCulling\n    fragmentShader: \"string\",\n    log: \"string\",\n    mesh: \"var\",\n    status: { type: \"enum\", initialValue: 1 }, // ShaderEffect.Uncompiled\n    supportsAtlasTextures: \"bool\",\n    vertexShader: \"string\"\n  }\n}, function () {\n  function _class71(meta) {\n    _classCallCheck(this, _class71);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  return _class71;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"ShaderEffectSource\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    ShaderEffectSource: {\n      Alpha: 0x6406, RGB: 0x6407, RGBA: 0x6408,\n      NoMirroring: 0, MirrorHorizontally: 1, MirrorVertically: 2,\n      ClampToEdge: 0, RepeatHorizontally: 1, RepeatVertically: 2, Repeat: 3\n    }\n  },\n  properties: {\n    format: { type: \"enum\", initialValue: 0x6408 }, // ShaderEffectSource.RGBA\n    hideSource: \"bool\",\n    live: { type: \"bool\", initialValue: true },\n    mipmap: \"bool\",\n    recursive: \"bool\",\n    sourceItem: \"Item\",\n    sourceRect: \"rect\",\n    textureMirroring: { type: \"enum\", initialValue: 2 }, // MirrorVertically\n    textureSize: \"size\",\n    wrapMode: \"enum\" // ShaderEffectSource.ClampToEdge\n  }\n}, function () {\n  function _class72(meta) {\n    _classCallCheck(this, _class72);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO\n  }\n\n  _createClass(_class72, [{\n    key: \"scheduleUpdate\",\n    value: function scheduleUpdate() {\n      // TODO\n    }\n  }]);\n\n  return _class72;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"State\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    name: \"string\",\n    changes: \"list\",\n    extend: \"string\",\n    when: \"bool\"\n  },\n  defaultProperty: \"changes\"\n}, function () {\n  function _class73(meta) {\n    _classCallCheck(this, _class73);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n\n    this.whenChanged.connect(this, this.$onWhenChanged);\n  }\n\n  _createClass(_class73, [{\n    key: \"$getAllChanges\",\n    value: function $getAllChanges() {\n      var _this47 = this;\n\n      if (this.extend) {\n        /* ECMAScript 2015. TODO: polyfill Array?\r\n        const base = this.$item.states.find(state => state.name === this.extend);\r\n        */\n        var states = this.$item.states;\n        var base = states.filter(function (state) {\n          return state.name === _this47.extend;\n        })[0];\n        if (base) {\n          return base.$getAllChanges().concat(this.changes);\n        }\n        console.error(\"Can't find the state to extend!\");\n      }\n      return this.changes;\n    }\n  }, {\n    key: \"$onWhenChanged\",\n    value: function $onWhenChanged(newVal) {\n      if (newVal) {\n        this.$item.state = this.name;\n      } else if (this.$item.state === this.name) {\n        this.$item.state = \"\";\n      }\n    }\n  }]);\n\n  return _class73;\n}());\n\nvar platformsDetectors = [\n//{ name: \"W8\", regexp: /Windows NT 6\\.2/ },\n//{ name: \"W7\", regexp: /Windows NT 6\\.1/ },\n//{ name: \"Windows\", regexp: /Windows NT/ },\n{ name: \"OSX\", regexp: /Macintosh/ }];\n\nvar systemPalettes = {};\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"SystemPalette\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    SystemPalette: {\n      Active: 0, Inactive: 2, Disabled: 1\n    }\n  },\n  properties: {\n    alternateBase: { type: \"color\", readOnly: true },\n    base: { type: \"color\", readOnly: true },\n    button: { type: \"color\", readOnly: true },\n    buttonText: { type: \"color\", readOnly: true },\n    dark: { type: \"color\", readOnly: true },\n    highlight: { type: \"color\", readOnly: true },\n    highlightedText: { type: \"color\", readOnly: true },\n    light: { type: \"color\", readOnly: true },\n    mid: { type: \"color\", readOnly: true },\n    midlight: { type: \"color\", readOnly: true },\n    shadow: { type: \"color\", readOnly: true },\n    text: { type: \"color\", readOnly: true },\n    window: { type: \"color\", readOnly: true },\n    windowText: { type: \"color\", readOnly: true },\n\n    colorGroup: \"enum\"\n  }\n}, function () {\n  function _class74(meta) {\n    _classCallCheck(this, _class74);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.colorGroupChanged.connect(this, this.$onColorGroupChanged);\n\n    this.$platform = \"OSX\";\n    // Detect OS\n    for (var i = 0; i < platformsDetectors.length; ++i) {\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n        this.$platform = platformsDetectors[i].name;\n        break;\n      }\n    }\n\n    this.$onColorGroupChanged(this.colorGroup);\n  }\n\n  _createClass(_class74, [{\n    key: \"$onColorGroupChanged\",\n    value: function $onColorGroupChanged(newVal) {\n      var _this48 = this;\n\n      var name = [\"active\", \"disabled\", \"inactive\"][newVal];\n      var pallete = systemPalettes[this.$platform][name];\n      this.$canEditReadOnlyProperties = true;\n      Object.keys(pallete).forEach(function (key) {\n        _this48[key] = pallete[key];\n      });\n      delete this.$canEditReadOnlyProperties;\n    }\n  }]);\n\n  return _class74;\n}());\n\nsystemPalettes.OSX = {\n  active: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#fbed73\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  inactive: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ffffff\",\n    button: \"#ededed\",\n    buttonText: \"#000000\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#000000\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#000000\",\n    window: \"#ededed\",\n    windowText: \"#000000\"\n  },\n  disabled: {\n    alternateBase: \"#f6f6f6\",\n    base: \"#ededed\",\n    button: \"#ededed\",\n    buttonText: \"#949494\",\n    dark: \"#bfbfbf\",\n    highlight: \"#d0d0d0\",\n    highlightText: \"#7f7f7f\",\n    light: \"#ffffff\",\n    mid: \"#a9a9a9\",\n    midlight: \"#f6f6f6\",\n    shadow: \"#8b8b8b\",\n    text: \"#7f7f7f\",\n    window: \"#ededed\",\n    windowText: \"#7f7f7f\"\n  }\n};\n\nQmlWeb.systemPalettes = systemPalettes;\nQmlWeb.platformsDetectors = platformsDetectors;\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Text\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    Text: {\n      NoWrap: 0, WordWrap: 1, WrapAnywhere: 2, Wrap: 3,\n      WrapAtWordBoundaryOrAnywhere: 4,\n      AlignLeft: 1, AlignRight: 2, AlignHCenter: 4, AlignJustify: 8,\n      AlignTop: 32, AlignBottom: 64, AlignVCenter: 128,\n      AutoText: 2, PlainText: 0, StyledText: 4, RichText: 1,\n      Normal: 0, Outline: 1, Raised: 2, Sunken: 3\n    }\n  },\n  properties: {\n    color: { type: \"color\", initialValue: \"black\" },\n    text: \"string\",\n    textFormat: { type: \"enum\", initialValue: 2 }, // Text.AutoText\n    font: \"font\",\n    lineHeight: \"real\",\n    wrapMode: { type: \"enum\", initialValue: 0 }, // Text.NoWrap\n    horizontalAlignment: { type: \"enum\", initialValue: 1 }, // Text.AlignLeft\n    style: \"enum\",\n    styleColor: \"color\"\n  }\n}, function () {\n  function _class75(meta) {\n    _classCallCheck(this, _class75);\n\n    QmlWeb.callSuper(this, meta);\n\n    var fc = this.impl = document.createElement(\"span\");\n    fc.style.pointerEvents = \"none\";\n    fc.style.width = \"100%\";\n    fc.style.height = \"100%\";\n    fc.style.whiteSpace = \"pre\";\n    this.dom.style.textAlign = \"left\";\n    this.dom.appendChild(fc);\n\n    this.colorChanged.connect(this, this.$onColorChanged);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.textFormatChanged.connect(this, this.$onTextFormatChanged);\n    this.lineHeightChanged.connect(this, this.$onLineHeightChanged);\n    this.wrapModeChanged.connect(this, this.$onWrapModeChanged);\n    this.horizontalAlignmentChanged.connect(this, this.$onHorizontalAlignmentChanged);\n    this.styleChanged.connect(this, this.$onStyleChanged);\n    this.styleColorChanged.connect(this, this.$onStyleColorChanged);\n\n    this.widthChanged.connect(this, this.$onWidthChanged);\n    this.fontChanged.connect(this, this.$onFontChanged);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n  }\n\n  _createClass(_class75, [{\n    key: \"$redrawText\",\n    value: function $redrawText() {\n      var text = this.text;\n      var format = this.textFormat;\n      if (format === this.Text.AutoText) {\n        // NOTE: this is not the exact same heuristics that Qt uses\n        if (/<[a-zA-Z]+(\\s[^>]*)?\\/?>/.test(text)) {\n          format = this.Text.StyledText;\n        } else {\n          format = this.Text.PlainText;\n        }\n      }\n      if (format === this.Text.PlainText) {\n        this.impl.innerHTML = \"\";\n        this.impl.appendChild(document.createTextNode(text));\n      } else {\n        // TODO: sanitize StyledText/RichText\n        this.impl.innerHTML = text;\n      }\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.color = newVal.$css;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged() {\n      this.$redrawText();\n    }\n  }, {\n    key: \"$onTextFormatChanged\",\n    value: function $onTextFormatChanged() {\n      this.$redrawText();\n    }\n  }, {\n    key: \"$onWidthChanged\",\n    value: function $onWidthChanged() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onLineHeightChanged\",\n    value: function $onLineHeightChanged(newVal) {\n      this.impl.style.lineHeight = newVal + \"px\";\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$onStyleChanged\",\n    value: function $onStyleChanged(newVal) {\n      this.$updateShadow(newVal, this.styleColor.$css);\n    }\n  }, {\n    key: \"$onStyleColorChanged\",\n    value: function $onStyleColorChanged(newVal) {\n      this.$updateShadow(this.style, newVal.$css);\n    }\n  }, {\n    key: \"$onWrapModeChanged\",\n    value: function $onWrapModeChanged(newVal) {\n      var style = this.impl.style;\n      switch (newVal) {\n        case this.Text.NoWrap:\n          style.whiteSpace = \"pre\";\n          break;\n        case this.Text.WordWrap:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordWrap = \"normal\";\n          break;\n        case this.Text.WrapAnywhere:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordBreak = \"break-all\";\n          break;\n        case this.Text.Wrap:\n        case this.Text.WrapAtWordBoundaryOrAnywhere:\n          style.whiteSpace = \"pre-wrap\";\n          style.wordWrap = \"break-word\";\n      }\n      this.$updateJustifyWhiteSpace();\n    }\n  }, {\n    key: \"$onHorizontalAlignmentChanged\",\n    value: function $onHorizontalAlignmentChanged(newVal) {\n      var textAlign = null;\n      switch (newVal) {\n        case this.Text.AlignLeft:\n          textAlign = \"left\";\n          break;\n        case this.Text.AlignRight:\n          textAlign = \"right\";\n          break;\n        case this.Text.AlignHCenter:\n          textAlign = \"center\";\n          break;\n        case this.Text.AlignJustify:\n          textAlign = \"justify\";\n          break;\n      }\n      this.dom.style.textAlign = textAlign;\n      this.$updateJustifyWhiteSpace();\n    }\n  }, {\n    key: \"$onFontChanged\",\n    value: function $onFontChanged() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.$updateImplicit();\n    }\n  }, {\n    key: \"$updateImplicit\",\n    value: function $updateImplicit() {\n      if (!this.text || !this.dom) {\n        this.implicitHeight = this.implicitWidth = 0;\n        return;\n      }\n\n      if (!this.$isUsingImplicitWidth) {\n        this.implicitWidth = this.impl.offsetWidth;\n        this.implicitHeight = this.impl.offsetHeight;\n        return;\n      }\n\n      var fc = this.impl;\n      var engine = QmlWeb.engine;\n      // Need to move the child out of it's parent so that it can properly\n      // recalculate it's \"natural\" offsetWidth/offsetHeight\n      if (engine.dom === document.body && engine.dom !== engine.domTarget) {\n        // Can't use document.body here, as it could have Shadow DOM inside\n        // The root is document.body, though, so it's probably not hidden\n        engine.domTarget.appendChild(fc);\n      } else {\n        document.body.appendChild(fc);\n      }\n      var height = fc.offsetHeight;\n      var width = fc.offsetWidth;\n      this.dom.appendChild(fc);\n\n      this.implicitHeight = height;\n      this.implicitWidth = width;\n    }\n  }, {\n    key: \"$updateShadow\",\n    value: function $updateShadow(textStyle, styleColor) {\n      var style = this.impl.style;\n      switch (textStyle) {\n        case 0:\n          style.textShadow = \"none\";\n          break;\n        case 1:\n          style.textShadow = [\"1px 0 0 \" + styleColor, \"-1px 0 0 \" + styleColor, \"0 1px 0 \" + styleColor, \"0 -1px 0 \" + styleColor].join(\",\");\n          break;\n        case 2:\n          style.textShadow = \"1px 1px 0 \" + styleColor;\n          break;\n        case 3:\n          style.textShadow = \"-1px -1px 0 \" + styleColor;\n          break;\n      }\n    }\n  }, {\n    key: \"$updateJustifyWhiteSpace\",\n    value: function $updateJustifyWhiteSpace() {\n      var style = this.impl.style;\n      // AlignJustify doesn't work with pre/pre-wrap, so we decide the lesser of\n      // the two evils to be ignoring \"\\n\"s inside the text.\n      if (this.horizontalAlignment === this.Text.AlignJustify) {\n        style.whiteSpace = \"normal\";\n      }\n      this.$updateImplicit();\n    }\n  }]);\n\n  return _class75;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextEdit\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  properties: {\n    activeFocusOnPress: { type: \"bool\", initialValue: true },\n    baseUrl: \"url\",\n    canPaste: \"bool\",\n    canRedo: \"bool\",\n    canUndo: \"bool\",\n    color: { type: \"color\", initialValue: \"white\" },\n    contentHeight: \"real\",\n    contentWidth: \"real\",\n    cursorDelegate: \"Component\",\n    cursorPosition: \"int\",\n    cursorRectangle: \"rect\",\n    cursorVisible: { type: \"bool\", initialValue: true },\n    effectiveHorizontalAlignment: \"enum\",\n    font: \"font\",\n    horizontalAlignment: \"enum\",\n    hoveredLink: \"string\",\n    inputMethodComposing: \"bool\",\n    inputMethodHints: \"enum\",\n    length: \"int\",\n    lineCount: \"int\",\n    mouseSelectionMode: \"enum\",\n    persistentSelection: \"bool\",\n    readOnly: \"bool\",\n    renderType: \"enum\",\n    selectByKeyboard: { type: \"bool\", initialValue: true },\n    selectByMouse: \"bool\",\n    selectedText: \"string\",\n    selectedTextColor: { type: \"color\", initialValue: \"yellow\" },\n    selectionColor: { type: \"color\", initialValue: \"pink\" },\n    selectionEnd: \"int\",\n    selectionStart: \"int\",\n    text: \"string\",\n    textDocument: \"TextDocument\",\n    textFormat: \"enum\",\n    textMargin: \"real\",\n    verticalAlignment: \"enum\",\n    wrapMode: \"enum\"\n  },\n  signals: {\n    linkActivated: [{ type: \"string\", name: \"link\" }],\n    linkHovered: [{ type: \"string\", name: \"link\" }]\n  }\n}, function () {\n  function _class76(meta) {\n    var _this49 = this;\n\n    _classCallCheck(this, _class76);\n\n    QmlWeb.callSuper(this, meta);\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    var textarea = this.impl = document.createElement(\"textarea\");\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = \"border-box\";\n    textarea.style.borderWidth = \"0\";\n    textarea.style.background = \"none\";\n    textarea.style.outline = \"none\";\n    textarea.style.resize = \"none\";\n    textarea.style.padding = \"0\"; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.colorChanged.connect(this, this.$onColorChanged);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this49.$updateValue();\n    });\n  }\n\n  _createClass(_class76, [{\n    key: \"append\",\n    value: function append(text) {\n      this.text += text;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      // TODO\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      this.text = this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);\n      // TODO\n    }\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      //this.selectionStart = -1;\n      //this.selectionEnd = -1;\n      //this.selectedText = null;\n      // TODO\n    }\n  }, {\n    key: \"getFormattedText\",\n    value: function getFormattedText(start, end) {\n      var text = this.text.slice(start, end);\n      // TODO\n      // process text\n      return text;\n    }\n  }, {\n    key: \"getText\",\n    value: function getText(start, end) {\n      return this.text.slice(start, end);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert() /*position, text*/{\n      // TODO\n    }\n  }, {\n    key: \"isRightToLeft\",\n    value: function isRightToLeft() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"linkAt\",\n    value: function linkAt() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"moveCursorSelection\",\n    value: function moveCursorSelection() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"paste\",\n    value: function paste() {\n      // TODO\n    }\n  }, {\n    key: \"positionAt\",\n    value: function positionAt() /*x, y*/{\n      // TODO\n    }\n  }, {\n    key: \"positionToRectangle\",\n    value: function positionToRectangle() /*position*/{\n      // TODO\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      // TODO\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"select\",\n    value: function select() /*start, end*/{\n      // TODO\n    }\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      // TODO\n    }\n  }, {\n    key: \"selectWord\",\n    value: function selectWord() {\n      // TODO\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      // TODO\n    }\n  }, {\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.selectByKeyboard = !this.readOnly;\n      this.impl.readOnly = this.readOnly;\n      this.$updateValue();\n      this.implicitWidth = this.offsetWidth;\n      this.implicitHeight = this.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      this.impl.value = newVal;\n    }\n  }, {\n    key: \"$onColorChanged\",\n    value: function $onColorChanged(newVal) {\n      this.impl.style.color = newVal.$css;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.text = this.impl.value;\n      }\n      this.length = this.text.length;\n      this.lineCount = this.$getLineCount();\n      this.$updateCss();\n    }\n    // Transfer dom style to firstChild,\n    // then clear corresponding dom style\n\n  }, {\n    key: \"$updateCss\",\n    value: function $updateCss() {\n      var supported = [\"border\", \"borderRadius\", \"borderWidth\", \"borderColor\", \"backgroundColor\"];\n      var style = this.impl.style;\n      for (var n = 0; n < supported.length; n++) {\n        var o = supported[n];\n        var v = this.css[o];\n        if (v) {\n          style[o] = v;\n          this.css[o] = null;\n        }\n      }\n    }\n  }, {\n    key: \"$getLineCount\",\n    value: function $getLineCount() {\n      return this.text.split(/\\n/).length;\n    }\n  }]);\n\n  return _class76;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"TextInput\",\n  versions: /.*/,\n  baseClass: \"Item\",\n  enums: {\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\n  },\n  properties: {\n    text: \"string\",\n    font: \"font\",\n    maximumLength: { type: \"int\", initialValue: -1 },\n    readOnly: \"bool\",\n    validator: \"var\",\n    echoMode: \"enum\" // TextInput.Normal\n  },\n  signals: {\n    accepted: []\n  }\n}, function () {\n  function _class77(meta) {\n    var _this50 = this;\n\n    _classCallCheck(this, _class77);\n\n    QmlWeb.callSuper(this, meta);\n\n    var input = this.impl = document.createElement(\"input\");\n    input.type = \"text\";\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    // In some browsers text-inputs have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    input.style.margin = \"0\";\n    input.style.padding = \"0\";\n    input.style.width = \"100%\";\n    input.style.height = \"100%\";\n    this.dom.appendChild(input);\n    this.setupFocusOnDom(input);\n    input.disabled = false;\n\n    this.Component.completed.connect(this, this.Component$onCompleted);\n    this.textChanged.connect(this, this.$onTextChanged);\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\n\n    this.impl.addEventListener(\"input\", function () {\n      return _this50.$updateValue();\n    });\n  }\n\n  _createClass(_class77, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      this.implicitWidth = this.impl.offsetWidth;\n      this.implicitHeight = this.impl.offsetHeight;\n    }\n  }, {\n    key: \"$onTextChanged\",\n    value: function $onTextChanged(newVal) {\n      // We have to check if value actually changes.\n      // If we do not have this check, then after user updates text input\n      // following occurs: user updates gui text -> updateValue gets called ->\n      // textChanged gets called -> gui value updates again -> caret position\n      // moves to the right!\n      if (this.impl.value !== newVal) {\n        this.impl.value = newVal;\n      }\n    }\n  }, {\n    key: \"$onEchoModeChanged\",\n    value: function $onEchoModeChanged(newVal) {\n      var TextInput = this.TextInput;\n      var input = this.impl;\n      switch (newVal) {\n        case TextInput.Normal:\n          input.type = \"text\";\n          break;\n        case TextInput.Password:\n          input.type = \"password\";\n          break;\n        case TextInput.NoEcho:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n        case TextInput.PasswordEchoOnEdit:\n          // Not supported, use password, that's nearest\n          input.type = \"password\";\n          break;\n      }\n    }\n  }, {\n    key: \"$onMaximumLengthChanged\",\n    value: function $onMaximumLengthChanged(newVal) {\n      this.impl.maxLength = newVal < 0 ? null : newVal;\n    }\n  }, {\n    key: \"$onReadOnlyChanged\",\n    value: function $onReadOnlyChanged(newVal) {\n      this.impl.disabled = newVal;\n    }\n  }, {\n    key: \"Keys$onPressed\",\n    value: function Keys$onPressed(e) {\n      var Qt = QmlWeb.Qt;\n      var submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\n      if (submit && this.$testValidator()) {\n        this.accepted();\n        e.accepted = true;\n      }\n    }\n  }, {\n    key: \"$testValidator\",\n    value: function $testValidator() {\n      if (this.validator) {\n        return this.validator.validate(this.text);\n      }\n      return true;\n    }\n  }, {\n    key: \"$updateValue\",\n    value: function $updateValue() {\n      if (this.text !== this.impl.value) {\n        this.$canEditReadOnlyProperties = true;\n        this.text = this.impl.value;\n        this.$canEditReadOnlyProperties = false;\n      }\n    }\n  }]);\n\n  return _class77;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Transition\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    animations: \"list\",\n    from: { type: \"string\", initialValue: \"*\" },\n    to: { type: \"string\", initialValue: \"*\" },\n    reversible: \"bool\"\n  },\n  defaultProperty: \"animations\"\n}, function () {\n  function _class78(meta) {\n    _classCallCheck(this, _class78);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$item = this.$parent;\n  }\n\n  _createClass(_class78, [{\n    key: \"$start\",\n    value: function $start(actions) {\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i];\n        animation.$actions = [];\n        var $targets = animation.$targets,\n            $props = animation.$props,\n            $actions = animation.$actions;\n\n        for (var j in actions) {\n          var _action6 = actions[j];\n          if (($targets.length === 0 || $targets.indexOf(_action6.target) !== -1) && ($props.length === 0 || $props.indexOf(_action6.property) !== -1)) {\n            $actions.push(_action6);\n          }\n        }\n        animation.start();\n      }\n    }\n  }, {\n    key: \"$stop\",\n    value: function $stop() {\n      for (var i = 0; i < this.animations.length; i++) {\n        this.animations[i].stop();\n      }\n    }\n  }]);\n\n  return _class78;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"Translate\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  properties: {\n    x: \"real\",\n    y: \"real\"\n  }\n}, function () {\n  function _class79(meta) {\n    _classCallCheck(this, _class79);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n  }\n\n  return _class79;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"UniformAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\",\n  properties: {\n    uniform: \"string\"\n  }\n}, function () {\n  function _class80(meta) {\n    _classCallCheck(this, _class80);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class80;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"XAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class81(meta) {\n    _classCallCheck(this, _class81);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class81;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtQuick\",\n  name: \"YAnimator\",\n  versions: /^2\\./,\n  baseClass: \"Animator\"\n}, function () {\n  function _class82(meta) {\n    _classCallCheck(this, _class82);\n\n    QmlWeb.callSuper(this, meta);\n  }\n\n  return _class82;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtTest\",\n  name: \"TestCase\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    completed: \"bool\",\n    name: \"string\",\n    optional: \"bool\",\n    running: \"bool\",\n    when: \"bool\",\n    windowShown: \"bool\"\n  }\n}, function () {\n  function _class83(meta) {\n    var _this51 = this;\n\n    _classCallCheck(this, _class83);\n\n    QmlWeb.callSuper(this, meta);\n    this.Component.completed.connect(this, this.Component$onCompleted);\n\n    var engine = QmlWeb.engine;\n    if (!engine.tests) {\n      QmlWeb.engine.tests = {\n        name: engine.name || \"Run_\" + Math.random().toString(36).slice(2, 10),\n        started: false,\n        finished: false,\n        duration: 0,\n        total: 0,\n        completed: 0,\n        errors: [],\n        stats: {\n          pass: 0,\n          fail: 0,\n          skip: 0\n        }\n      };\n    }\n    QmlWeb.engine.tests.total++;\n\n    this.console = {\n      assert: function assert() {\n        var _console;\n\n        return (_console = console).assert.apply(_console, arguments);\n      },\n      error: function error() {\n        var _console2;\n\n        for (var _len26 = arguments.length, a = Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n          a[_key26] = arguments[_key26];\n        }\n\n        return (_console2 = console).error.apply(_console2, [\"QSYSTEM: \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      info: function info() {\n        var _console3;\n\n        for (var _len27 = arguments.length, a = Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n          a[_key27] = arguments[_key27];\n        }\n\n        return (_console3 = console).info.apply(_console3, [\"QINFO  : \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      log: function log() {\n        var _console4;\n\n        for (var _len28 = arguments.length, a = Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n          a[_key28] = arguments[_key28];\n        }\n\n        return (_console4 = console).log.apply(_console4, [\"QDEBUG : \" + _this51.$testId + \" qml:\"].concat(a));\n      },\n      time: function time() {\n        var _console5;\n\n        return (_console5 = console).time.apply(_console5, arguments);\n      },\n      timeEnd: function timeEnd() {\n        var _console6;\n\n        return (_console6 = console).timeEnd.apply(_console6, arguments);\n      },\n      trace: function trace() {\n        var _console7;\n\n        return (_console7 = console).trace.apply(_console7, arguments);\n      },\n      warn: function warn() {\n        var _console8;\n\n        for (var _len29 = arguments.length, a = Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n          a[_key29] = arguments[_key29];\n        }\n\n        return (_console8 = console).warn.apply(_console8, [\"QWARN  : \" + _this51.$testId + \" qml:\"].concat(a));\n      }\n    };\n  }\n\n  _createClass(_class83, [{\n    key: \"Component$onCompleted\",\n    value: function Component$onCompleted() {\n      var _this52 = this;\n\n      var info = QmlWeb.engine.tests;\n      if (!info.started) {\n        console.log(\"********* Start testing of \" + info.name + \" *********\");\n        console.log(\"Config: Using QmlWeb, \" + window.navigator.userAgent);\n        info.started = true;\n      }\n\n      var keys = Object.keys(this);\n      var tests = keys.filter(function (key) {\n        return key.lastIndexOf(\"test_\", 0) === 0;\n      }).filter(function (key) {\n        return key.indexOf(\"_data\", key.length - 5) === -1;\n      }).sort();\n\n      tests.unshift(\"initTestCase\");\n      tests.push(\"cleanupTestCase\");\n      tests.forEach(function (test) {\n        _this52.$testId = info.name + \"::\" + _this52.name + \"::\" + test + \"()\";\n        var special = test === \"initTestCase\" || test === \"cleanupTestCase\";\n\n        var dstart = performance.now();\n        var data = void 0;\n        if (_this52[test + \"_data\"] && !special) {\n          data = _this52[test + \"_data\"]();\n          if (!data || !data.length) {\n            _this52.warn(\"no data supplied for \" + test + \"() by \" + test + \"_data()\");\n            data = [];\n          }\n        } else if (_this52.init_data && !special) {\n          data = _this52.init_data();\n          if (!data || !data.length) {\n            data = undefined;\n          }\n        }\n        if (!data) {\n          data = [null];\n        }\n        var dend = performance.now();\n        info.duration += dend - dstart;\n\n        data.forEach(function (row) {\n          var arg = row ? row.tag : \"\";\n          _this52.$testId = info.name + \"::\" + _this52.name + \"::\" + test + \"(\" + arg + \")\";\n          var start = performance.now();\n          var error = void 0;\n          try {\n            if (!special) {\n              _this52.init();\n            }\n            _this52[test](row);\n          } catch (e) {\n            error = e;\n          } finally {\n            if (!special) {\n              _this52.cleanup();\n            }\n          }\n          var end = performance.now();\n          info.duration += end - start;\n          if (error && error.skip) {\n            info.stats.skip++;\n            console.log(\"SKIP   : \" + _this52.$testId + \" \" + error.message);\n          } else if (error) {\n            info.stats.fail++;\n            info.errors.push(_this52.$testId + \" \" + error.message);\n            console.log(\"FAIL!  : \" + _this52.$testId + \" \" + error.message);\n            if (\"actual\" in error) {\n              console.log(\"   Actual   (): \" + error.actual);\n            }\n            if (\"expected\" in error) {\n              console.log(\"   Expected (): \" + error.expected);\n            }\n          } else {\n            info.stats.pass++;\n            console.log(\"PASS   : \" + _this52.$testId);\n          }\n        });\n\n        _this52.$testId = info.name + \"::UnknownTestFunc()\";\n      });\n\n      // TODO: benchmarks\n\n      info.completed++;\n      if (info.completed === info.total) {\n        info.finished = true;\n        var _info$stats = info.stats,\n            pass = _info$stats.pass,\n            fail = _info$stats.fail,\n            skip = _info$stats.skip;\n\n        var duration = Math.round(info.duration * 100) / 100;\n        console.log(\"Totals: \" + pass + \" passed, \" + fail + \" failed, \" + skip + \" skipped, \" + duration + \"ms\");\n        console.log(\"********* Finished testing of \" + info.name + \" *********\");\n      }\n    }\n\n    // No-ops\n\n  }, {\n    key: \"init\",\n    value: function init() {}\n  }, {\n    key: \"initTestCase\",\n    value: function initTestCase() {}\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {}\n  }, {\n    key: \"cleanupTestCase\",\n    value: function cleanupTestCase() {}\n\n    // API\n\n  }, {\n    key: \"compare\",\n    value: function compare(actual, expected) {\n      var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n\n      if (actual !== expected) {\n        var err = new Error(message);\n        err.actual = actual;\n        err.expected = expected;\n        throw err;\n      }\n    }\n  }, {\n    key: \"verify\",\n    value: function verify(condition) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n\n      if (!condition) {\n        throw new Error(\"'\" + message + \"' returned FALSE. ()\");\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      throw new Error(message);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn(message) {\n      console.warn(\"WARNING: \" + this.$testId + \" \" + message);\n    }\n  }, {\n    key: \"skip\",\n    value: function skip() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      var err = new Error(message);\n      err.skip = true;\n      throw err;\n    }\n    /*\r\n    expectFail(tag, message) {\r\n      // TODO\r\n    }\r\n    expectFailContinue(tag, message) {\r\n      // TODO\r\n    }\r\n    findChild(parent, objectName) {\r\n      // TODO\r\n      // return QtObject\r\n    }\r\n    fuzzyCompare(actual, expected, delta, message) {\r\n      // TODO\r\n    }\r\n    grabImage(item) {\r\n      if (!window.top || !window.top.callPhantom) {\r\n        this.skip(\"Can't use TestCase::grabImage() without PhantomJS.\");\r\n      }\r\n      // TODO\r\n      return {\r\n        red: (x, y) => {},\r\n        green: (x, y) => {},\r\n        blue: (x, y) => {},\r\n        alpha: (x, y) => {},\r\n        pixel: (x, y) => {},\r\n        equals: image => false\r\n      };\r\n    }\r\n    ignoreWarning(message) {\r\n      // TODO\r\n    }\r\n    sleep(ms) {\r\n      // TODO\r\n    }\r\n    tryCompare(obj, property, expected, timeout, message) {\r\n      // TODO\r\n    }\r\n    wait(ms) {\r\n      // TODO\r\n    }\r\n    waitForRendering(item, timeout = 5000) {\r\n      // TODO\r\n    }\r\n    */\n\n    // TODO\n    /*\r\n    // Events\r\n    keyClick(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    keyPress(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    keyRelease(key, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseClick(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDoubleClick(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDoubleClickSequence(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseDrag(item, x, y, dx, dy, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseMove(item, x, y, delay = -1) {\r\n      // TODO\r\n    }\r\n    mousePress(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseRelease(item, x, y, button, modifiers, delay = -1) {\r\n      // TODO\r\n    }\r\n    mouseWheel(item, x, y, xDelta, yDelta, button, modifiers, delay = -1) {\r\n      // button = Qt.LeftButton, modifiers = Qt.NoModifier\r\n      // TODO\r\n    }\r\n    */\n\n  }]);\n\n  return _class83;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtWebEngine\",\n  name: \"WebEngineView\",\n  versions: /^5\\./,\n  baseClass: \"QtWebView.WebView\", // It's easier this way\n  properties: {\n    // TODO\n  },\n  signals: {\n    // TODO\n  }\n}, function () {\n  function _class84(meta) {\n    _classCallCheck(this, _class84);\n\n    QmlWeb.callSuper(this, meta);\n\n    // TODO: implement more features on top of WebView\n  }\n\n  return _class84;\n}());\n\n// WARNING: Can have wrong behavior if url is changed while the socket is in\n// Connecting state.\n// TODO: Recheck everything.\n\nQmlWeb.registerQmlType({\n  module: \"QtWebSockets\",\n  name: \"WebSocket\",\n  versions: /.*/,\n  baseClass: \"QtQml.QtObject\",\n  enums: {\n    WebSocket: { Connecting: 0, Open: 1, Closing: 2, Closed: 3, Error: 4 }\n  },\n  properties: {\n    active: \"bool\",\n    status: { type: \"enum\", initialValue: 3 }, // WebSocket.Closed\n    errorString: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    textMessageReceived: [{ type: \"string\", name: \"message\" }]\n  }\n}, function () {\n  function _class85(meta) {\n    _classCallCheck(this, _class85);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.$socket = undefined;\n    this.$reconnect = false;\n\n    this.statusChanged.connect(this, this.$onStatusChanged);\n    this.activeChanged.connect(this, this.$reconnectSocket);\n    this.urlChanged.connect(this, this.$reconnectSocket);\n  }\n\n  _createClass(_class85, [{\n    key: \"$onStatusChanged\",\n    value: function $onStatusChanged(status) {\n      if (status !== this.WebSocket.Error) {\n        this.errorString = \"\";\n      }\n    }\n  }, {\n    key: \"$connectSocket\",\n    value: function $connectSocket() {\n      var _this53 = this;\n\n      this.$reconnect = false;\n\n      if (!this.url || !this.active) {\n        return;\n      }\n\n      this.status = this.WebSocket.Connecting;\n      this.$socket = new WebSocket(this.url);\n      this.$socket.onopen = function () {\n        _this53.status = _this53.WebSocket.Open;\n      };\n      this.$socket.onclose = function () {\n        _this53.status = _this53.WebSocket.Closed;\n        if (_this53.$reconnect) {\n          _this53.$connectSocket();\n        }\n      };\n      this.$socket.onerror = function (error) {\n        _this53.errorString = error.message;\n        _this53.status = _this53.WebSocket.Error;\n      };\n      this.$socket.onmessage = function (message) {\n        _this53.textMessageReceived(message.data);\n      };\n    }\n  }, {\n    key: \"$reconnectSocket\",\n    value: function $reconnectSocket() {\n      this.$reconnect = true;\n      if (this.status === this.WebSocket.Open) {\n        this.status = this.WebSocket.Closing;\n        this.$socket.close();\n      } else if (this.status !== this.WebSocket.Closing) {\n        this.$connectSocket();\n      }\n    }\n  }, {\n    key: \"sendTextMessage\",\n    value: function sendTextMessage(message) {\n      if (this.status === this.WebSocket.Open) {\n        this.$socket.send(message);\n      }\n    }\n  }]);\n\n  return _class85;\n}());\n\nQmlWeb.registerQmlType({\n  module: \"QtWebView\",\n  name: \"WebView\",\n  versions: /^1\\./,\n  baseClass: \"QtQuick.Item\",\n  properties: {\n    canGoBack: \"bool\", // TODO\n    canGoForward: \"bool\", // TODO\n    loadProgress: \"int\",\n    loading: \"bool\",\n    title: \"string\",\n    url: \"url\"\n  },\n  signals: {\n    /* // TODO\r\n    loadingChanged: [\r\n      { type: \"WebViewLoadRequest\", name: \"loadRequest\" }\r\n    ]\r\n    */\n  }\n}, function () {\n  function _class86(meta) {\n    var _this54 = this;\n\n    _classCallCheck(this, _class86);\n\n    QmlWeb.callSuper(this, meta);\n\n    this.urlChanged.connect(this, this.$onUrlChanged);\n\n    var iframe = this.impl = document.createElement(\"iframe\");\n    iframe.style.display = \"block\";\n    iframe.style.position = \"absolute\";\n    iframe.style.width = \"100%\";\n    iframe.style.height = \"100%\";\n    iframe.style.borderWidth = \"0\";\n    iframe.style.pointerEvents = \"auto\";\n    this.dom.appendChild(iframe);\n\n    iframe.onload = function () {\n      try {\n        _this54.title = iframe.contentDocument.title;\n      } catch (e) {\n        console.log(\"CSP prevents us from reading title for \" + _this54.url);\n        _this54.title = \"\";\n      }\n      _this54.loadProgress = 100;\n      _this54.loading = false;\n    };\n    iframe.onerror = function () {\n      _this54.title = \"\";\n      _this54.loadProgress = 0;\n      _this54.loading = false;\n    };\n  }\n\n  _createClass(_class86, [{\n    key: \"$onUrlChanged\",\n    value: function $onUrlChanged(newVal) {\n      this.loadProgress = 0;\n      this.loading = true;\n      this.impl.src = newVal;\n    }\n  }]);\n\n  return _class86;\n}());\n}(typeof global != \"undefined\" ? global : window));\n\n//# sourceMappingURL=qmlweb.js.map\n","function QMLBoolean(val) {\r\n  return !!val;\r\n}\r\nQMLBoolean.plainType = true;\r\nQmlWeb.qmlBoolean = QMLBoolean;\r\n","function QMLInteger(val) {\r\n  return val | 0;\r\n}\r\nQMLInteger.plainType = true;\r\nQmlWeb.qmlInteger = QMLInteger;\r\n","function QMLList(meta) {\r\n  const list = [];\r\n  if (meta.object instanceof Array) {\r\n    for (const i in meta.object) {\r\n      list.push(QmlWeb.construct({\r\n        object: meta.object[i],\r\n        parent: meta.parent,\r\n        context: meta.context\r\n      }));\r\n    }\r\n  } else if (meta.object instanceof QmlWeb.QMLMetaElement) {\r\n    list.push(QmlWeb.construct({\r\n      object: meta.object,\r\n      parent: meta.parent,\r\n      context: meta.context\r\n    }));\r\n  }\r\n\r\n  return list;\r\n}\r\nQMLList.plainType = true;\r\nQmlWeb.qmlList = QMLList;\r\n","function QMLNumber(val) {\r\n  return +val;\r\n}\r\nQMLNumber.plainType = true;\r\nQmlWeb.qmlNumber = QMLNumber;\r\n","function QMLString(val) {\r\n  return `${val}`;\r\n}\r\nQMLString.plainType = true;\r\nQmlWeb.qmlString = QMLString;\r\n","function QMLUrl(val) {\r\n  return QmlWeb.engine.$resolvePath(`${val}`);\r\n}\r\nQMLUrl.plainType = true;\r\nQmlWeb.qmlUrl = QMLUrl;\r\n","function QMLVariant(val) {\r\n  return val;\r\n}\r\nQMLVariant.plainType = true;\r\nQmlWeb.qmlVariant = QMLVariant;\r\n","const anchorNames = [\r\n  \"left\", \"right\", \"top\", \"bottom\", \"verticalCenter\", \"horizontalCenter\"\r\n];\r\n\r\nconst ignoreProps = [\r\n  \"x\", \"y\", \"z\", \"scale\", \"rotation\", \"implicitWidth\", \"implicitHeight\"\r\n];\r\n\r\nfunction getProperties(file) {\r\n  // TODO: implement a cleaner way\r\n\r\n  const div = document.createElement(\"div\");\r\n  const engine = new QmlWeb.QMLEngine(div);\r\n  engine.loadFile(file);\r\n\r\n  const qml = engine.rootObject;\r\n  const properties = Object.keys(qml.$properties).filter(name => {\r\n    // Invalid names\r\n    if (!name.match(/^[a-z]+$/i) || name === \"is\") return false;\r\n\r\n    // We don't need anchors\r\n    if (anchorNames.indexOf(name) !== -1) return false;\r\n\r\n    // These properties are not supported in a good way on top-level items\r\n    if (ignoreProps.indexOf(name) !== -1) return false;\r\n\r\n    const type = qml.$properties[name].type;\r\n    return [\"real\", \"color\", \"int\", \"bool\", \"string\"].indexOf(type) !== -1;\r\n  });\r\n\r\n  engine.stop();\r\n  return properties;\r\n}\r\n\r\nfunction registerElement(name, file) {\r\n  // Delay until the document is fully loaded\r\n  if (document.readyState === \"loading\") {\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n      registerElement(name, file);\r\n    });\r\n    return;\r\n  }\r\n\r\n  // Bail out if Custom Elements v1 are not present\r\n  if (!window.customElements) {\r\n    throw new Error(\r\n      \"window.customElements are not supported. Consider installing a polyfill.\"\r\n    );\r\n  }\r\n\r\n  // We need attributes list at this point, those form a static property\r\n  const properties = getProperties(file);\r\n  const attributes = properties.map(pname => pname.toLowerCase());\r\n  const attr2prop = properties.reduce((map, pname) => {\r\n    map[pname.toLowerCase()] = pname;\r\n    return map;\r\n  }, {});\r\n\r\n  const QmlElement = class extends HTMLElement {\r\n    connectedCallback() {\r\n      // Default wrapper display is inline-block to support native width/height\r\n      const computedStyle = window.getComputedStyle(this);\r\n      if (computedStyle.display === \"inline\") {\r\n        this.style.display = \"inline-block\";\r\n      }\r\n\r\n      const engine = this.engine = new QmlWeb.QMLEngine(this);\r\n      engine.loadFile(file);\r\n      engine.start();\r\n      const qml = this.qml = engine.rootObject;\r\n\r\n      // Bind attributes\r\n      attributes.forEach(attr => {\r\n        const pname = attr2prop[attr] || attr;\r\n        const val = this.getAttribute(attr);\r\n        if (typeof val === \"string\") {\r\n          qml[pname] = val;\r\n        }\r\n        this.applyAttribute(attr);\r\n        Object.defineProperty(\r\n          this,\r\n          attr,\r\n          {\r\n            get() {\r\n              return this.qml[pname];\r\n            },\r\n            set(value) {\r\n              this.qml[pname] = value;\r\n              this.applyAttribute(attr);\r\n            }\r\n          }\r\n        );\r\n        qml.$properties[pname].changed.connect(() => this.applyAttribute(attr));\r\n      });\r\n\r\n      // Set and update wrapper width/height\r\n      this.style.width = `${qml.width}px`;\r\n      this.style.height = `${qml.height}px`;\r\n      qml.$properties.width.changed.connect(width => {\r\n        this.style.width = `${width}px`;\r\n      });\r\n      qml.$properties.height.changed.connect(height => {\r\n        this.style.height = `${height}px`;\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      return attributes;\r\n    }\r\n\r\n    attributeChangedCallback(attr, oldValue, newValue) {\r\n      if (!this.qml) return;\r\n      const pname = attr2prop[attr] || attr;\r\n      const prop = this.qml.$properties[pname];\r\n      if (!prop) return;\r\n      switch (prop.type) {\r\n        case \"bool\":\r\n          this.qml[pname] = typeof newValue === \"string\";\r\n          break;\r\n        default:\r\n          this.qml[pname] = newValue;\r\n      }\r\n    }\r\n\r\n    applyAttribute(attr) {\r\n      const pname = attr2prop[attr] || attr;\r\n      const prop = this.qml.$properties[pname];\r\n      if (!prop) {\r\n        this.deleteAttribute(attr);\r\n        return;\r\n      }\r\n      const value = this.qml[pname];\r\n      switch (prop.type) {\r\n        case \"bool\":\r\n          if (value) {\r\n            this.setAttribute(attr, \"\");\r\n          } else {\r\n            this.removeAttribute(attr);\r\n          }\r\n          break;\r\n        default:\r\n          this.setAttribute(attr, this.qml[pname]);\r\n      }\r\n    }\r\n  };\r\n\r\n  window.customElements.define(name, QmlElement);\r\n}\r\n\r\nQmlWeb.registerElement = registerElement;\r\n","/* eslint accessor-pairs: 0 */\r\n\r\nfunction setupGetter(obj, propName, func) {\r\n  Object.defineProperty(obj, propName, {\r\n    get: func,\r\n    configurable: true,\r\n    enumerable: true\r\n  });\r\n}\r\n\r\nfunction setupSetter(obj, propName, func) {\r\n  Object.defineProperty(obj, propName, {\r\n    set: func,\r\n    configurable: true,\r\n    enumerable: false\r\n  });\r\n}\r\n\r\nfunction setupGetterSetter(obj, propName, getter, setter) {\r\n  Object.defineProperty(obj, propName, {\r\n    get: getter,\r\n    set: setter,\r\n    configurable: true,\r\n    enumerable: false\r\n  });\r\n}\r\n\r\nQmlWeb.setupGetter = setupGetter;\r\nQmlWeb.setupSetter = setupSetter;\r\nQmlWeb.setupGetterSetter = setupGetterSetter;\r\n","/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial and working\r\n                                                         import implementation.\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\n/**\r\n * Get URL contents.\r\n * @param url {String} Url to fetch.\r\n * @param skipExceptions {bool} when turned on, ignore exeptions and return\r\n *        false. This feature is used by readQmlDir.\r\n * @private\r\n * @return {mixed} String of contents or false in errors.\r\n */\r\nfunction getUrlContents(url, skipExceptions) {\r\n  if (typeof QmlWeb.urlContentCache[url] === \"undefined\") {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url, false);\r\n\r\n    if (skipExceptions) {\r\n      try {\r\n        xhr.send(null);\r\n      } catch (e) {\r\n        return false;\r\n      }\r\n      // it is OK to not have logging here, because DeveloperTools already will\r\n      // have red log record\r\n    } else {\r\n      xhr.send(null);\r\n    }\r\n\r\n    if (xhr.status !== 200 && xhr.status !== 0) { // 0 if accessing with file://\r\n      console.log(`Retrieving ${url} failed: ${xhr.responseText}`, xhr);\r\n      return false;\r\n    }\r\n    QmlWeb.urlContentCache[url] = xhr.responseText;\r\n  }\r\n  return QmlWeb.urlContentCache[url];\r\n}\r\nif (typeof QmlWeb.urlContentCache === \"undefined\") {\r\n  QmlWeb.urlContentCache = {};\r\n}\r\n\r\n/**\r\n * Read qmldir spec file at directory.\r\n * @param url Url of the directory\r\n * @return {Object} Object, where .internals lists qmldir internal references\r\n *                          and .externals lists qmldir external references.\r\n */\r\n\r\n/*  Note on how importing works.\r\n\r\nparseQML gives us `tree.$imports` variable, which contains information from\r\n`import` statements.\r\n\r\nAfter each call to parseQML, we call engine.loadImports(tree.$imports).\r\nIt in turn invokes readQmlDir() calls for each import, with respect to current\r\ncomponent base path and engine.importPathList().\r\n\r\nWe keep all component names from all qmldir files in global variable\r\n`engine.qmldir`.\r\n\r\nIn construct() function, we use `engine.qmldir` for component url lookup.\r\n\r\nReference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html\r\nAlso please look at notes and TODO's in qtcore.js::loadImports() and\r\nqtcore.js::construct() methods.\r\n*/\r\n\r\nfunction readQmlDir(url) {\r\n  // in case 'url' is empty, do not attach \"/\"\r\n  // Q1: when this happen?\r\n  const qmldirFileUrl = url.length > 0 ? `${url}/qmldir` : \"qmldir\";\r\n\r\n  const parsedUrl = QmlWeb.engine.$parseURI(qmldirFileUrl);\r\n\r\n  let qmldir;\r\n  if (parsedUrl.scheme === \"qrc://\") {\r\n    qmldir = QmlWeb.qrc[parsedUrl.path];\r\n  } else {\r\n    qmldir = getUrlContents(qmldirFileUrl, true) || undefined;\r\n  }\r\n\r\n  const internals = {};\r\n  const externals = {};\r\n\r\n  if (qmldir === undefined) {\r\n    return false;\r\n  }\r\n\r\n  // we have to check for \"://\"\r\n  // In that case, item path is meant to be absolute, and we have no need to\r\n  // prefix it with base url\r\n  function makeurl(path) {\r\n    if (path.indexOf(\"://\") > 0) {\r\n      return path;\r\n    }\r\n    return `${url}/${path}`;\r\n  }\r\n\r\n  const lines = qmldir.split(/\\r?\\n/);\r\n  for (let i = 0; i < lines.length; i++) {\r\n    // trim\r\n    const line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\r\n    if (!line.length || line[0] === \"#\") {\r\n      // Empty line or comment\r\n      continue;\r\n    }\r\n    const match = line.split(/\\s+/);\r\n    if (match.length === 2 || match.length === 3) {\r\n      if (match[0] === \"plugin\") {\r\n        console.log(`${url}: qmldir plugins are not supported!`);\r\n      } else if (match[0] === \"internal\") {\r\n        internals[match[1]] = { url: makeurl(match[2]) };\r\n      } else if (match.length === 2) {\r\n        externals[match[0]] = { url: makeurl(match[1]) };\r\n      } else {\r\n        externals[match[0]] = { url: makeurl(match[2]), version: match[1] };\r\n      }\r\n    } else {\r\n      console.log(`${url}: unmatched: ${line}`);\r\n    }\r\n  }\r\n  return { internals, externals };\r\n}\r\n\r\nQmlWeb.getUrlContents = getUrlContents;\r\nQmlWeb.readQmlDir = readQmlDir;\r\n","function importJavascriptInContext(contextSetter, $context) {\r\n  /* Set the QmlWeb.executionContext so that any internal calls to Qt.include\r\n   * will have the proper context */\r\n  const oldExecutionContext = QmlWeb.executionContext;\r\n  QmlWeb.executionContext = $context;\r\n  contextSetter($context);\r\n  QmlWeb.executionContext = oldExecutionContext;\r\n}\r\n\r\nQmlWeb.importJavascriptInContext = importJavascriptInContext;\r\n","QmlWeb.executionContext = null;\r\n\r\nconst modules = {\r\n  Main: {\r\n    int: QmlWeb.qmlInteger,\r\n    real: QmlWeb.qmlNumber,\r\n    double: QmlWeb.qmlNumber,\r\n    string: QmlWeb.qmlString,\r\n    bool: QmlWeb.qmlBoolean,\r\n    list: QmlWeb.qmlList,\r\n    color: QmlWeb.QColor,\r\n    font: QmlWeb.QFont,\r\n    size: QmlWeb.QSizeF,\r\n    point: QmlWeb.QPointF,\r\n    rect: QmlWeb.QRectF,\r\n    vector2d: QmlWeb.QVector2D,\r\n    vector3d: QmlWeb.QVector3D,\r\n    vector4d: QmlWeb.QVector4D,\r\n    quaternion: QmlWeb.QQuaternion,\r\n    matrix4x4: QmlWeb.QMatrix4x4,\r\n    enum: QmlWeb.qmlNumber,\r\n    url: QmlWeb.qmlUrl,\r\n    variant: QmlWeb.qmlVariant,\r\n    var: QmlWeb.qmlVariant\r\n  }\r\n};\r\n\r\n// All object constructors\r\nQmlWeb.constructors = modules.Main;\r\n\r\nconst dependants = {};\r\n\r\nconst perImportContextConstructors = {};\r\nlet importContextIds = 0;\r\n\r\n// Helper. Adds a type to the constructor list\r\nfunction registerGlobalQmlType(name, type) {\r\n  QmlWeb[type.name] = type;\r\n  QmlWeb.constructors[name] = type;\r\n  modules.Main[name] = type;\r\n}\r\n\r\n// Helper. Register a type to a module\r\nfunction registerQmlType(options, constructor) {\r\n  if (constructor !== undefined) {\r\n    options.constructor = constructor;\r\n  }\r\n\r\n  if (typeof options.baseClass === \"string\") {\r\n    // TODO: Does not support version specification (yet?)\r\n    let baseModule;\r\n    let baseName;\r\n    const dot = options.baseClass.lastIndexOf(\".\");\r\n    if (dot === -1) {\r\n      baseModule = options.module;\r\n      baseName = options.baseClass;\r\n    } else {\r\n      baseModule = options.baseClass.substring(0, dot);\r\n      baseName = options.baseClass.substring(dot + 1);\r\n    }\r\n    const found = (modules[baseModule] || [])\r\n                    .filter(descr => descr.name === baseName);\r\n    if (found.length > 0) {\r\n      // Ok, we found our base class\r\n      options.baseClass = found[0].constructor;\r\n    } else {\r\n      // Base class not found, delay the loading\r\n      const baseId = [baseModule, baseName].join(\".\");\r\n      if (!dependants.hasOwnProperty(baseId)) {\r\n        dependants[baseId] = [];\r\n      }\r\n      dependants[baseId].push(options);\r\n      return;\r\n    }\r\n  }\r\n\r\n  const descriptor = typeof options === \"function\" ? {\r\n    module: options.module,\r\n    name: options.element,\r\n    versions: options.versions,\r\n    baseClass: options.baseClass,\r\n    enums: options.enums,\r\n    signals: options.signals,\r\n    defaultProperty: options.defaultProperty,\r\n    properties: options.properties,\r\n    constructor: options\r\n  } : options;\r\n\r\n  descriptor.constructor.$qmlTypeInfo = {\r\n    enums: descriptor.enums,\r\n    signals: descriptor.signals,\r\n    defaultProperty: descriptor.defaultProperty,\r\n    properties: descriptor.properties\r\n  };\r\n\r\n  if (descriptor.global) {\r\n    registerGlobalQmlType(descriptor.name, descriptor.constructor);\r\n  }\r\n\r\n  const moduleDescriptor = {\r\n    name: descriptor.name,\r\n    versions: descriptor.versions,\r\n    constructor: descriptor.constructor\r\n  };\r\n\r\n  if (typeof modules[descriptor.module] === \"undefined\") {\r\n    modules[descriptor.module] = [];\r\n  }\r\n  modules[descriptor.module].push(moduleDescriptor);\r\n\r\n\r\n  if (typeof descriptor.baseClass !== \"undefined\") {\r\n    inherit(descriptor.constructor, descriptor.baseClass);\r\n  }\r\n\r\n  const id = [descriptor.module, descriptor.name].join(\".\");\r\n  if (dependants.hasOwnProperty(id)) {\r\n    dependants[id].forEach(opt => registerQmlType(opt));\r\n    dependants[id].length = 0;\r\n  }\r\n\r\n  // TODO: Move to module initialization?\r\n  /*\r\n    http://doc.qt.io/qt-5/qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers\r\n\r\n    Some object treated as Attached. For example, Component.\r\n    Here, we set property to object `QMLBaseObject.prototype` with name of that\r\n    object, and with specific getter func.\r\n    E.g., we create \"someitem.Component\" here.\r\n    Later, if somebody will read that property, the getter will be invoked.\r\n    Here all getters are set to `getAttachedObject` only, which is actually\r\n    dedicated for Component attached object.\r\n    The code of `getAttachedObject` checks whether $Component internal\r\n    variable exist, and creates it if it absent.\r\n    Then, `getAttachedObject` adds self \"completed\" signal to global\r\n    `engine.completedSignals`.\r\n    That is how completed handlers gathered into global list. This list then\r\n    is called by `engine.callCompletedSignals`.\r\n\r\n    p.s. At the moment, Repeater and Loader manually call\r\n    `Component.completed` signals on objects they create.\r\n    At the same time, those signals are still pushed to\r\n    `engine.completedSignals` by getAttachedObject.\r\n  */\r\n  if (descriptor.constructor.getAttachedObject) {\r\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\r\n    QmlWeb.setupGetter(\r\n      QMLBaseObject.prototype,\r\n      descriptor.name,\r\n      descriptor.constructor.getAttachedObject\r\n    );\r\n  }\r\n}\r\n\r\nfunction getConstructor(moduleName, version, name) {\r\n  if (typeof modules[moduleName] !== \"undefined\") {\r\n    for (let i = 0; i < modules[moduleName].length; ++i) {\r\n      const type = modules[moduleName][i];\r\n      if (type.name === name && type.versions.test(version)) {\r\n        return type.constructor;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getModuleConstructors(moduleName, version) {\r\n  const constructors = {};\r\n  if (typeof modules[moduleName] === \"undefined\") {\r\n    console.warn(`module \"${moduleName}\" not found`);\r\n    return constructors;\r\n  }\r\n  for (let i = 0; i < modules[moduleName].length; ++i) {\r\n    const module = modules[moduleName][i];\r\n    if (module.versions.test(version)) {\r\n      constructors[module.name] = module.constructor;\r\n    }\r\n  }\r\n  return constructors;\r\n}\r\n\r\nfunction loadImports(self, imports) {\r\n  const mergeObjects = QmlWeb.helpers.mergeObjects;\r\n  let constructors = mergeObjects(modules.Main);\r\n  if (imports.filter(row => row[1] === \"QtQml\").length === 0 &&\r\n      imports.filter(row => row[1] === \"QtQuick\").length === 1) {\r\n    imports.push([\"qmlimport\", \"QtQml\", 2, \"\", true]);\r\n  }\r\n  for (let i = 0; i < imports.length; ++i) {\r\n    const [, moduleName, moduleVersion, moduleAlias] = imports[i];\r\n    if (typeof moduleVersion !== \"number\") continue;\r\n    const versionString = moduleVersion % 1 === 0 ?\r\n                            moduleVersion.toFixed(1) :\r\n                            moduleVersion.toString();\r\n    const moduleConstructors = getModuleConstructors(moduleName, versionString);\r\n\r\n    if (moduleAlias !== \"\") {\r\n      constructors[moduleAlias] = mergeObjects(\r\n        constructors[moduleAlias],\r\n        moduleConstructors\r\n      );\r\n    } else {\r\n      constructors = mergeObjects(constructors, moduleConstructors);\r\n    }\r\n  }\r\n  self.importContextId = importContextIds++;\r\n  perImportContextConstructors[self.importContextId] = constructors;\r\n  QmlWeb.constructors = constructors; // TODO: why do we need this?\r\n}\r\n\r\nfunction inherit(constructor, baseClass) {\r\n  const oldProto = constructor.prototype;\r\n  constructor.prototype = Object.create(baseClass.prototype);\r\n  Object.getOwnPropertyNames(oldProto).forEach(prop => {\r\n    constructor.prototype[prop] = oldProto[prop];\r\n  });\r\n  constructor.prototype.constructor = baseClass;\r\n}\r\n\r\nfunction callSuper(self, meta) {\r\n  const info = meta.super.$qmlTypeInfo || {};\r\n  meta.super = meta.super.prototype.constructor;\r\n  meta.super.call(self, meta);\r\n\r\n  if (info.enums) {\r\n    // TODO: not exported to the whole file scope yet\r\n    Object.keys(info.enums).forEach(name => {\r\n      self[name] = info.enums[name];\r\n\r\n      if (!global[name]) {\r\n        global[name] = self[name]; // HACK\r\n      }\r\n    });\r\n  }\r\n  if (info.properties) {\r\n    QmlWeb.createProperties(self, info.properties);\r\n  }\r\n  if (info.signals) {\r\n    Object.keys(info.signals).forEach(name => {\r\n      const params = info.signals[name];\r\n      self[name] = QmlWeb.Signal.signal(params);\r\n    });\r\n  }\r\n  if (info.defaultProperty) {\r\n    self.$defaultProperty = info.defaultProperty;\r\n  }\r\n}\r\n\r\n/**\r\n * QML Object constructor.\r\n * @param {Object} meta Meta information about the object and the creation\r\n *                      context\r\n * @return {Object} New qml object\r\n */\r\nfunction construct(meta) {\r\n  let item;\r\n\r\n  let constructors = perImportContextConstructors[meta.context.importContextId];\r\n\r\n  const classComponents = meta.object.$class.split(\".\");\r\n  for (let ci = 0; ci < classComponents.length; ++ci) {\r\n    const c = classComponents[ci];\r\n    constructors = constructors[c];\r\n    if (constructors === undefined) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (constructors !== undefined) {\r\n    const constructor = constructors;\r\n    meta.super = constructor;\r\n    item = new constructor(meta);\r\n    meta.super = undefined;\r\n  } else {\r\n    // Load component from file. Please look at import.js for main notes.\r\n    // Actually, we have to use that order:\r\n    // 1) try to load component from current basePath\r\n    // 2) from importPathList\r\n    // 3) from directories in imports statements and then\r\n    // 4) from qmldir files\r\n    // Currently we support only 1,2 and 4 and use order: 4,1,2\r\n    // TODO: engine.qmldirs is global for all loaded components.\r\n    //       That's not qml's original behaviour.\r\n    const qdirInfo = QmlWeb.engine.qmldirs[meta.object.$class];\r\n    // Are we have info on that component in some imported qmldir files?\r\n\r\n    /* This will also be set in applyProperties, but needs to be set here\r\n     * for Qt.createComponent to have the correct context. */\r\n    QmlWeb.executionContext = meta.context;\r\n\r\n    let filePath;\r\n    if (qdirInfo) {\r\n      filePath = qdirInfo.url;\r\n    } else if (classComponents.length === 2) {\r\n      const qualified = QmlWeb.engine.qualifiedImportPath(\r\n        meta.context.importContextId, classComponents[0]\r\n      );\r\n      filePath = `${qualified}${classComponents[1]}.qml`;\r\n    } else {\r\n      filePath = `${classComponents[0]}.qml`;\r\n    }\r\n\r\n    const component = QmlWeb.Qt.createComponent(filePath);\r\n\r\n    if (!component) {\r\n      throw new Error(`No constructor found for ${meta.object.$class}`);\r\n    }\r\n\r\n    item = component.$createObject(meta.parent);\r\n    if (typeof item.dom !== \"undefined\") {\r\n      item.dom.className += ` ${classComponents[classComponents.length - 1]}`;\r\n      if (meta.object.id) {\r\n        item.dom.className += `  ${meta.object.id}`;\r\n      }\r\n    }\r\n    // Handle default properties\r\n  }\r\n\r\n  // id\r\n  if (meta.object.id) {\r\n    QmlWeb.setupGetterSetter(\r\n      meta.context, meta.object.id,\r\n      () => item,\r\n      () => {}\r\n    );\r\n  }\r\n\r\n  // keep path in item for probale use it later in Qt.resolvedUrl\r\n  item.$context.$basePath = QmlWeb.engine.$basePath; //gut\r\n\r\n  // We want to use the item's scope, but this Component's imports\r\n  item.$context.importContextId = meta.context.importContextId;\r\n\r\n  // Apply properties (Bindings won't get evaluated, yet)\r\n  QmlWeb.applyProperties(meta.object, item, item, item.$context);\r\n\r\n  return item;\r\n}\r\n\r\nQmlWeb.modules = modules;\r\nQmlWeb.registerGlobalQmlType = registerGlobalQmlType;\r\nQmlWeb.registerQmlType = registerQmlType;\r\nQmlWeb.getConstructor = getConstructor;\r\nQmlWeb.loadImports = loadImports;\r\nQmlWeb.callSuper = callSuper;\r\nQmlWeb.construct = construct;\r\n","/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {String} propName Property name\r\n * @param {Object} [options] Options that allow finetuning of the property\r\n */\r\nfunction createProperty(type, obj, propName, options = {}) {\r\n  const QMLProperty = QmlWeb.QMLProperty;\r\n  const prop = new QMLProperty(type, obj, propName);\r\n  obj[`${propName}Changed`] = prop.changed;\r\n  obj.$properties[propName] = prop;\r\n  obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\r\n\r\n  const getter = () => obj.$properties[propName].get();\r\n  let setter;\r\n  if (options.readOnly) {\r\n    setter = function(newVal) {\r\n      if (!obj.$canEditReadOnlyProperties) {\r\n        throw new Error(`property '${propName}' has read only access`);\r\n      }\r\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\r\n    };\r\n  } else {\r\n    setter = function(newVal) {\r\n      obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\r\n    };\r\n  }\r\n  QmlWeb.setupGetterSetter(obj, propName, getter, setter);\r\n  if (obj.$isComponentRoot) {\r\n    let skip = false;\r\n    if (options.noContextOverride) {\r\n      // Don't override context properties if options.noContextOverride is on\r\n      const descr = Object.getOwnPropertyDescriptor(obj.$context, propName);\r\n      skip = descr && (descr.get || descr.set);\r\n    }\r\n    if (!skip) {\r\n      QmlWeb.setupGetterSetter(obj.$context, propName, getter, setter);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Create property getters and setters for object.\r\n * @param {Object} obj Object for which gsetters will be set\r\n * @param {Object} properties An object containing properties descriptors\r\n */\r\nfunction createProperties(obj, properties) {\r\n  Object.keys(properties).forEach(name => {\r\n    let desc = properties[name];\r\n    if (typeof desc === \"string\") {\r\n      desc = { type: desc };\r\n    }\r\n    createProperty(desc.type, obj, name, desc);\r\n  });\r\n}\r\n\r\n/**\r\n * Apply properties from metaObject to item.\r\n * @param {Object} metaObject Source of properties\r\n * @param {Object} item Target of property apply\r\n * @param {Object} objectScope Scope in which properties should be evaluated\r\n * @param {Object} componentScope Component scope in which properties should be\r\n *                 evaluated\r\n */\r\nfunction applyProperties(metaObject, item, objectScopeIn, componentScope) {\r\n  const QMLProperty = QmlWeb.QMLProperty;\r\n  const objectScope = objectScopeIn || item;\r\n  QmlWeb.executionContext = componentScope;\r\n\r\n  if (metaObject.$children && metaObject.$children.length !== 0) {\r\n    if (item.$defaultProperty) {\r\n      item.$properties[item.$defaultProperty].set(\r\n        metaObject.$children, QMLProperty.ReasonInit,\r\n        objectScope, componentScope\r\n      );\r\n    } else {\r\n      throw new Error(\"Cannot assign to unexistant default property\");\r\n    }\r\n  }\r\n  // We purposefully set the default property AFTER using it, in order to only\r\n  // have it applied for instanciations of this component, but not for its\r\n  // internal children\r\n  if (metaObject.$defaultProperty) {\r\n    item.$defaultProperty = metaObject.$defaultProperty;\r\n  }\r\n\r\n  for (const i in metaObject) {\r\n    const value = metaObject[i];\r\n    if (i === \"id\" || i === \"$class\") { // keep them\r\n      item[i] = value;\r\n      continue;\r\n    }\r\n\r\n    // skip global id's and internal values\r\n    if (i === \"id\" || i[0] === \"$\") { // TODO: what? See above.\r\n      continue;\r\n    }\r\n\r\n    // slots\r\n    if (i.indexOf(\"on\") === 0 && i.length > 2 && /[A-Z]/.test(i[2])) {\r\n      const signalName = i[2].toLowerCase() + i.slice(3);\r\n      if (connectSignal(item, signalName, value, objectScope, componentScope)) {\r\n        continue;\r\n      }\r\n      if (item.$setCustomSlot) {\r\n        item.$setCustomSlot(signalName, value, objectScope, componentScope);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (value instanceof Object) {\r\n      if (applyProperty(item, i, value, objectScope, componentScope)) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (item.$properties && i in item.$properties) {\r\n      item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope,\r\n                                                             componentScope);\r\n    } else if (i in item) {\r\n      item[i] = value;\r\n    } else if (item.$setCustomData) {\r\n      item.$setCustomData(i, value);\r\n    } else {\r\n      console.warn(\r\n        `Cannot assign to non-existent property \"${i}\". Ignoring assignment.`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyProperty(item, i, value, objectScope, componentScope) {\r\n  const QMLProperty = QmlWeb.QMLProperty;\r\n\r\n  if (value instanceof QmlWeb.QMLSignalDefinition) {\r\n    item[i] = QmlWeb.Signal.signal(value.parameters);\r\n    if (item.$isComponentRoot) {\r\n      componentScope[i] = item[i];\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (value instanceof QmlWeb.QMLMethod) {\r\n    value.compile();\r\n    item[i] = value.eval(objectScope, componentScope,\r\n      componentScope.$basePath);\r\n    if (item.$isComponentRoot) {\r\n      componentScope[i] = item[i];\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (value instanceof QmlWeb.QMLAliasDefinition) {\r\n    // TODO\r\n    // 1. Alias must be able to point to prop or id of local object,\r\n    //    eg: property alias q: t\r\n    // 2. Alias may have same name as id it points to: property alias\r\n    //    someid: someid\r\n    // 3. Alias proxy (or property proxy) to proxy prop access to selected\r\n    //    incapsulated object. (think twice).\r\n    createProperty(\"alias\", item, i, { noContextOverride: true });\r\n    item.$properties[i].componentScope = componentScope;\r\n    item.$properties[i].componentScopeBasePath = componentScope.$basePath;\r\n    item.$properties[i].val = value;\r\n    item.$properties[i].get = function() {\r\n      const obj = this.componentScope[this.val.objectName];\r\n      const propertyName = this.val.propertyName;\r\n      return propertyName ? obj.$properties[propertyName].get() : obj;\r\n    };\r\n    item.$properties[i].set = function(newVal, reason, _objectScope,\r\n                                       _componentScope) {\r\n      if (!this.val.propertyName) {\r\n        throw new Error(\"Cannot set alias property pointing to an QML object.\");\r\n      }\r\n      const obj = this.componentScope[this.val.objectName];\r\n      const prop = obj.$properties[this.val.propertyName];\r\n      prop.set(newVal, reason, _objectScope, _componentScope);\r\n    };\r\n\r\n    if (value.propertyName) {\r\n      const con = prop => {\r\n        const obj = prop.componentScope[prop.val.objectName];\r\n        if (!obj) {\r\n          console.error(\"qtcore: target object \", prop.val.objectName,\r\n                        \" not found for alias \", prop);\r\n          return;\r\n        }\r\n        const targetProp = obj.$properties[prop.val.propertyName];\r\n        if (!targetProp) {\r\n          console.error(\r\n            \"qtcore: target property [\", prop.val.objectName, \"].\",\r\n            prop.val.propertyName, \" not found for alias \", prop.name\r\n          );\r\n          return;\r\n        }\r\n        // targetProp.changed.connect( prop.changed );\r\n        // it is not sufficient to connect to `changed` of source property\r\n        // we have to propagate own changed to it too\r\n        // seems the best way to do this is to make them identical?..\r\n        // prop.changed = targetProp.changed;\r\n        // obj[`${i}Changed`] = prop.changed;\r\n        // no. because those object might be destroyed later.\r\n        let loopWatchdog = false;\r\n        targetProp.changed.connect(item, (...args) => {\r\n          if (loopWatchdog) return;\r\n          loopWatchdog = true;\r\n          prop.changed.apply(item, args);\r\n          loopWatchdog = false;\r\n        });\r\n        prop.changed.connect(obj, (...args) => {\r\n          if (loopWatchdog) return;\r\n          loopWatchdog = true;\r\n          targetProp.changed.apply(obj, args);\r\n          loopWatchdog = false;\r\n        });\r\n      };\r\n      QmlWeb.engine.pendingOperations.push([con, item.$properties[i]]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (value instanceof QmlWeb.QMLPropertyDefinition) {\r\n    createProperty(value.type, item, i);\r\n    item.$properties[i].set(value.value, QMLProperty.ReasonInit,\r\n                            objectScope, componentScope);\r\n    return true;\r\n  }\r\n\r\n  if (item[i] && value instanceof QmlWeb.QMLMetaPropertyGroup) {\r\n    // Apply properties one by one, otherwise apply at once\r\n    applyProperties(value, item[i], objectScope, componentScope);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction connectSignal(item, signalName, value, objectScope, componentScope) {\r\n  if (!item[signalName]) {\r\n    console.warn(`No signal called ${signalName} found!`);\r\n    return undefined;\r\n  } else if (typeof item[signalName].connect !== \"function\") {\r\n    console.warn(`${signalName} is not a signal!`);\r\n    return undefined;\r\n  }\r\n\r\n  if (!value.compiled) {\r\n    const params = [];\r\n    for (const j in item[signalName].parameters) {\r\n      params.push(item[signalName].parameters[j].name);\r\n    }\r\n    // Wrap value.src in IIFE in case it includes a \"return\"\r\n    value.src = `(\r\n      function(${params.join(\", \")}) {\r\n        QmlWeb.executionContext = __executionContext;\r\n        const bp = QmlWeb.engine.$basePath;\r\n        QmlWeb.engine.$basePath = \"${componentScope.$basePath}\";\r\n        try {\r\n          (function() {\r\n            ${value.src}\r\n          })();\r\n        } finally {\r\n          QmlWeb.engine.$basePath = bp;\r\n        }\r\n      }\r\n    )`;\r\n    value.isFunction = false;\r\n    value.compile();\r\n  }\r\n  // Don't pass in __basePath argument, as QMLEngine.$basePath is set in the\r\n  // value.src, as we need it set at the time the slot is called.\r\n  const slot = value.eval(objectScope, componentScope);\r\n  item[signalName].connect(item, slot);\r\n  return slot;\r\n}\r\n\r\nQmlWeb.createProperty = createProperty;\r\nQmlWeb.createProperties = createProperties;\r\nQmlWeb.applyProperties = applyProperties;\r\nQmlWeb.connectSignal = connectSignal;\r\n","/* @license\r\n\r\nMIT License\r\n\r\nCopyright (c) 2011 Lauri Paimen <lauri@paimen.info>\r\nCopyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\r\nCopyright (c) 2016 QmlWeb contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\nclass QMLMethod extends QmlWeb.QMLBinding {\r\n}\r\n\r\n/**\r\n * Create an object representing a QML property definition.\r\n * @param {String} type The type of the property\r\n * @param {Array} value The default value of the property\r\n * @return {Object} Object representing the defintion\r\n */\r\nclass QMLPropertyDefinition {\r\n  constructor(type, value) {\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nclass QMLAliasDefinition {\r\n  constructor(objName, propName) {\r\n    this.objectName = objName;\r\n    this.propertyName = propName;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an object representing a QML signal definition.\r\n * @param {Array} params The parameters the signal ships\r\n * @return {Object} Object representing the defintion\r\n */\r\nclass QMLSignalDefinition {\r\n  constructor(params) {\r\n    this.parameters = params;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an object representing a group of QML properties (like anchors).\r\n * @return {Object} Object representing the group\r\n */\r\nclass QMLMetaPropertyGroup {\r\n}\r\n\r\n/**\r\n * Create an object representing a QML element.\r\n * @param {String} type Type of the element\r\n * @param {String} onProp Name of the property specified with the \"on\" keyword\r\n */\r\nclass QMLMetaElement {\r\n  constructor(type, onProp) {\r\n    this.$class = type;\r\n    this.$children = [];\r\n    this.$on = onProp;\r\n  }\r\n}\r\n\r\n// Convert parser tree to the format understood by engine\r\nfunction convertToEngine(tree) {\r\n  return convertToEngine.walk(tree);\r\n}\r\n\r\nfunction stringifyDots(elem) {\r\n  let sub = elem;\r\n  const path = [];\r\n  while (sub[0] === \"dot\") {\r\n    path.push(sub[1]);\r\n    sub = sub[2];\r\n  }\r\n  path.push(sub);\r\n  return path.join(\".\");\r\n}\r\n\r\nfunction applyProp(item, name, val) {\r\n  let curr = item; // output structure\r\n  let sub = name; // input structure\r\n  while (sub[0] === \"dot\") {\r\n    if (!curr[sub[1]]) {\r\n      curr[sub[1]] = new QMLMetaPropertyGroup();\r\n    }\r\n    curr = curr[sub[1]];\r\n    sub = sub[2];\r\n  }\r\n  curr[sub] = val;\r\n}\r\n\r\nconvertToEngine.walkers = {\r\n  toplevel: (imports, statement) => {\r\n    const item = { $class: \"Component\" };\r\n    item.$imports = imports;\r\n    item.$children = [convertToEngine.walk(statement)];\r\n    return item;\r\n  },\r\n  qmlelem: (elem, onProp, statements) => {\r\n    const item = new QMLMetaElement(stringifyDots(elem), onProp);\r\n\r\n    for (const i in statements) {\r\n      const statement = statements[i];\r\n      const name = statement[1];\r\n      const val = convertToEngine.walk(statement);\r\n      switch (statement[0]) {\r\n        case \"qmldefaultprop\":\r\n          item.$defaultProperty = name;\r\n          item[name] = val;\r\n          break;\r\n        case \"qmlprop\":\r\n        case \"qmlpropdef\":\r\n        case \"qmlaliasdef\":\r\n        case \"qmlmethod\":\r\n        case \"qmlsignaldef\":\r\n          applyProp(item, name, val);\r\n          break;\r\n        case \"qmlelem\":\r\n          item.$children.push(val);\r\n          break;\r\n        case \"qmlobjdef\":\r\n          throw new Error(\r\n            \"qmlobjdef support was removed, update qmlweb-parser to ^0.3.0.\"\r\n          );\r\n        case \"qmlobj\":\r\n          // Create object to item\r\n          item[name] = item[name] || new QMLMetaPropertyGroup();\r\n          for (const j in val) {\r\n            item[name][j] = val[j];\r\n          }\r\n          break;\r\n        default:\r\n          console.log(\"Unknown statement\", statement);\r\n      }\r\n    }\r\n    // Make $children be either a single item or an array, if it's more than one\r\n    if (item.$children.length === 1) {\r\n      item.$children = item.$children[0];\r\n    }\r\n\r\n    return item;\r\n  },\r\n  qmlprop: (name, tree, src) => {\r\n    if (name === \"id\") {\r\n      // id property\r\n      return tree[1][1];\r\n    }\r\n    return convertToEngine.bindout(tree, src);\r\n  },\r\n  qmlobjdef: (name, property, tree, src) =>\r\n    convertToEngine.bindout(tree, src),\r\n  qmlobj: (elem, statements) => {\r\n    const item = {};\r\n    for (const i in statements) {\r\n      const statement = statements[i];\r\n      const name = statement[1];\r\n      const val = convertToEngine.walk(statement);\r\n      if (statement[0] === \"qmlprop\") {\r\n        applyProp(item, name, val);\r\n      }\r\n    }\r\n    return item;\r\n  },\r\n  qmlmethod: (name, tree, src) =>\r\n    new QMLMethod(src),\r\n  qmlpropdef: (name, type, tree, src) =>\r\n    new QMLPropertyDefinition(\r\n        type,\r\n        tree ? convertToEngine.bindout(tree, src) : undefined\r\n    ),\r\n  qmlaliasdef: (name, objName, propName) =>\r\n    new QMLAliasDefinition(objName, propName),\r\n  qmlsignaldef: (name, params) =>\r\n    new QMLSignalDefinition(params),\r\n  qmldefaultprop: tree => convertToEngine.walk(tree),\r\n  name: src => {\r\n    if (src === \"true\" || src === \"false\") {\r\n      return src === \"true\";\r\n    } else if (typeof src === \"boolean\") {\r\n      // TODO: is this needed? kept for compat with ==\r\n      return src;\r\n    }\r\n    return new QmlWeb.QMLBinding(src, [\"name\", src]);\r\n  },\r\n  num: src => +src,\r\n  string: src => String(src),\r\n  array: (tree, src) => {\r\n    const a = [];\r\n    let isList = false;\r\n    let hasBinding = false;\r\n    for (const i in tree) {\r\n      const val = convertToEngine.bindout(tree[i]);\r\n      a.push(val);\r\n\r\n      if (val instanceof QMLMetaElement) {\r\n        isList = true;\r\n      } else if (val instanceof QmlWeb.QMLBinding) {\r\n        hasBinding = true;\r\n      }\r\n    }\r\n\r\n    if (hasBinding) {\r\n      if (isList) {\r\n        throw new TypeError(\r\n          \"An array may either contain bindings or Element definitions.\"\r\n        );\r\n      }\r\n      return new QmlWeb.QMLBinding(src, tree);\r\n    }\r\n\r\n    return a;\r\n  }\r\n};\r\n\r\nconvertToEngine.walk = function(tree) {\r\n  const type = tree[0];\r\n  const walker = convertToEngine.walkers[type];\r\n  if (!walker) {\r\n    console.log(`No walker for ${type}`);\r\n    return undefined;\r\n  }\r\n  return walker.apply(type, tree.slice(1));\r\n};\r\n\r\n// Try to bind out tree and return static variable instead of binding\r\nconvertToEngine.bindout = function(statement, binding) {\r\n  // We want to process the content of the statement\r\n  // (but still handle the case, we get the content directly)\r\n  const tree = statement[0] === \"stat\" ? statement[1] : statement;\r\n\r\n  const type = tree[0];\r\n  const walker = convertToEngine.walkers[type];\r\n  if (walker) {\r\n    return walker.apply(type, tree.slice(1));\r\n  }\r\n  return new QmlWeb.QMLBinding(binding, tree);\r\n};\r\n\r\n// Help logger\r\nconvertToEngine.amIn = function(str, tree) {\r\n  console.log(str);\r\n  if (tree) console.log(JSON.stringify(tree, null, \"  \"));\r\n};\r\n\r\nfunction loadParser() {\r\n  if (typeof QmlWeb.parse !== \"undefined\") {\r\n    return;\r\n  }\r\n\r\n  console.log(\"Loading parser...\");\r\n  const tags = document.getElementsByTagName(\"script\");\r\n  for (const i in tags) {\r\n    if (tags[i].src && tags[i].src.match(/\\/(qt|qmlweb)\\./)) {\r\n      const src = tags[i].src.replace(\r\n        /\\/(qt|qmlweb)\\.(es201.\\.)?/,\r\n        \"/qmlweb.parser.\"\r\n      );\r\n      // TODO: rewrite to async loading\r\n      const xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", src, false);\r\n      xhr.send(null);\r\n      if (xhr.status !== 200 && xhr.status !== 0) {\r\n        // xhr.status === 0 if accessing with file://\r\n        throw new Error(\"Could not load QmlWeb parser!\");\r\n      }\r\n      new Function(xhr.responseText)();\r\n      QmlWeb.parse = QmlWeb.parse;\r\n      QmlWeb.jsparse = QmlWeb.jsparse;\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\n// Function to parse qml and output tree expected by engine\r\nfunction parseQML(src, file) {\r\n  loadParser();\r\n  QmlWeb.parse.nowParsingFile = file;\r\n  const parsetree = QmlWeb.parse(src, QmlWeb.parse.QmlDocument);\r\n  return convertToEngine(parsetree);\r\n}\r\n\r\nQmlWeb.QMLMethod = QMLMethod;\r\nQmlWeb.QMLPropertyDefinition = QMLPropertyDefinition;\r\nQmlWeb.QMLAliasDefinition = QMLAliasDefinition;\r\nQmlWeb.QMLSignalDefinition = QMLSignalDefinition;\r\nQmlWeb.QMLMetaPropertyGroup = QMLMetaPropertyGroup;\r\nQmlWeb.QMLMetaElement = QMLMetaElement;\r\nQmlWeb.convertToEngine = convertToEngine;\r\nQmlWeb.loadParser = loadParser;\r\nQmlWeb.parseQML = parseQML;\r\n","const QmlWeb = {};\r\n\r\nglobal.QmlWeb = QmlWeb;\r\n","let objectIds = 0;\r\n\r\nclass QObject {\r\n  constructor(parent) {\r\n    this.$parent = parent;\r\n    if (parent && parent.$tidyupList) {\r\n      parent.$tidyupList.push(this);\r\n    }\r\n\r\n    // List of things to tidy up when deleting this object.\r\n    this.$tidyupList = [];\r\n    this.$properties = {};\r\n    this.$signals = [];\r\n\r\n    this.objectId = objectIds++;\r\n  }\r\n\r\n  $delete() {\r\n    if (this.$Component) {\r\n      this.$Component.destruction();\r\n    }\r\n\r\n    while (this.$tidyupList.length > 0) {\r\n      const item = this.$tidyupList[0];\r\n      if (item.$delete) {\r\n        // It's a QObject\r\n        item.$delete();\r\n      } else {\r\n        // It must be a signal\r\n        item.disconnect(this);\r\n      }\r\n    }\r\n\r\n    for (const i in this.$properties) {\r\n      const prop = this.$properties[i];\r\n      while (prop.$tidyupList.length > 0) {\r\n        prop.$tidyupList[0].disconnect(prop);\r\n      }\r\n    }\r\n\r\n    if (this.$parent && this.$parent.$tidyupList) {\r\n      const index = this.$parent.$tidyupList.indexOf(this);\r\n      this.$parent.$tidyupList.splice(index, 1);\r\n    }\r\n\r\n    // must do this:\r\n    // 1) parent will be notified and erase object from it's children.\r\n    // 2) DOM node will be removed.\r\n    this.parent = undefined;\r\n\r\n    // Disconnect any slots connected to any of our signals. Do this after\r\n    // clearing the parent, as that relies on parentChanged being handled.\r\n    for (const i in this.$signals) {\r\n      this.$signals[i].disconnect();\r\n    }\r\n  }\r\n\r\n  // must have a `destroy` method\r\n  // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\r\n  destroy() {\r\n    this.$delete();\r\n  }\r\n\r\n  $toString(...args) {\r\n    return `${this.constructor.name}(${args.join(\", \")})`;\r\n  }\r\n}\r\n\r\nQmlWeb.QObject = QObject;\r\n","class JSItemModel {\r\n  constructor() {\r\n    this.roleNames = [];\r\n\r\n    const Signal = QmlWeb.Signal;\r\n    this.dataChanged = Signal.signal([\r\n      { type: \"int\", name: \"startIndex\" },\r\n      { type: \"int\", name: \"endIndex\" }\r\n    ]);\r\n    this.rowsInserted = Signal.signal([\r\n      { type: \"int\", name: \"startIndex\" },\r\n      { type: \"int\", name: \"endIndex\" }\r\n    ]);\r\n    this.rowsMoved = Signal.signal([\r\n      { type: \"int\", name: \"sourceStartIndex\" },\r\n      { type: \"int\", name: \"sourceEndIndex\" },\r\n      { type: \"int\", name: \"destinationIndex\" }\r\n    ]);\r\n    this.rowsRemoved = Signal.signal([\r\n      { type: \"int\", name: \"startIndex\" },\r\n      { type: \"int\", name: \"endIndex\" }\r\n    ]);\r\n    this.modelReset = Signal.signal();\r\n  }\r\n\r\n  setRoleNames(names) {\r\n    this.roleNames = names;\r\n  }\r\n}\r\n\r\nQmlWeb.JSItemModel = JSItemModel;\r\n","class QColor {\r\n  constructor(...args) {\r\n    this.$changed = new QmlWeb.Signal();\r\n    this.$r = this.$g = this.$b = 0;\r\n    this.$a = 1;\r\n    const val = args[0];\r\n    if (args.length >= 3) {\r\n      this.$r = args[0];\r\n      this.$g = args[1];\r\n      this.$b = args[2];\r\n      if (args.length >= 4) {\r\n        this.$a = args[3];\r\n      }\r\n    } else if (val instanceof QColor) {\r\n      // Copy constructor\r\n      this.$a = val.a;\r\n      this.$r = val.r;\r\n      this.$g = val.g;\r\n      this.$b = val.b;\r\n    } else if (typeof val === \"string\") {\r\n      const lval = val.toLowerCase();\r\n      if (QColor.colormap[lval]) {\r\n        const rgb = QColor.colormap[lval];\r\n        this.$r = rgb[0] / 255;\r\n        this.$g = rgb[1] / 255;\r\n        this.$b = rgb[2] / 255;\r\n      } else if (lval === \"transparent\") {\r\n        this.$a = 0;\r\n      } else if (lval[0] === \"#\") {\r\n        const hex = lval.substr(1);\r\n        if (hex.length === 3) {\r\n          this.$r = parseInt(hex[0], 16) / 15;\r\n          this.$g = parseInt(hex[1], 16) / 15;\r\n          this.$b = parseInt(hex[2], 16) / 15;\r\n        } else {\r\n          const rgb = hex.match(/.{2}/g).map(x => parseInt(x, 16));\r\n          if (rgb.length === 4) {\r\n            this.$a = rgb.shift() / 255;\r\n          }\r\n          this.$r = rgb[0] / 255;\r\n          this.$g = rgb[1] / 255;\r\n          this.$b = rgb[2] / 255;\r\n        }\r\n      } else {\r\n        throw new Error(`Can not convert ${val} to color`);\r\n      }\r\n    } else if (typeof val !== \"undefined\") {\r\n      throw new Error(`Can not assign ${typeof val} to QColor`);\r\n    }\r\n  }\r\n  toString() {\r\n    if (this.$string) return this.$string;\r\n    const argb = [this.$a, this.$r, this.$g, this.$b].map(x =>\r\n      (Math.round(x * 255) + 0x100).toString(16).substr(-2)\r\n    );\r\n    if (argb[0] === \"ff\") {\r\n      argb.shift(); // We don't need alpha if it's ff\r\n    }\r\n    this.$string = `#${argb.join(\"\")}`;\r\n    return `#${argb.join(\"\")}`;\r\n  }\r\n  get $css() {\r\n    if (this.$cssValue) return this.$cssValue;\r\n    if (this.$a === 1) {\r\n      this.$cssValue = this.toString();\r\n    } else if (this.$a === 0) {\r\n      this.$cssValue = \"transparent\";\r\n    } else {\r\n      const intr = Math.round(this.$r * 255);\r\n      const intg = Math.round(this.$g * 255);\r\n      const intb = Math.round(this.$b * 255);\r\n      this.$cssValue = `rgba(${intr},${intg},${intb},${this.$a})`;\r\n    }\r\n    return this.$cssValue;\r\n  }\r\n  get r() {\r\n    return this.$r;\r\n  }\r\n  get g() {\r\n    return this.$g;\r\n  }\r\n  get b() {\r\n    return this.$b;\r\n  }\r\n  get a() {\r\n    return this.$a;\r\n  }\r\n  set r(r) {\r\n    this.$r = r;\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set g(g) {\r\n    this.$g = g;\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set b(b) {\r\n    this.$b = b;\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set a(a) {\r\n    this.$a = a;\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  get hsvHue() {\r\n    const v = this.hsvValue;\r\n    const m = Math.min(this.$r, this.$g, this.$b);\r\n    if (v === m) return -1;\r\n    if (v === this.$r) return ((this.$g - this.$b) / (v - m) + 1) % 1 / 6;\r\n    if (v === this.$g) return ((this.$b - this.$r) / (v - m) + 2) / 6;\r\n    if (v === this.$b) return ((this.$r - this.$g) / (v - m) + 4) / 6;\r\n    throw new Error();\r\n  }\r\n  get hsvSaturation() {\r\n    const v = this.hsvValue;\r\n    if (v === 0) return 0;\r\n    return 1 - Math.min(this.$r, this.$g, this.$b) / v;\r\n  }\r\n  get hsvValue() {\r\n    return Math.max(this.$r, this.$g, this.$b);\r\n  }\r\n  get hslHue() {\r\n    return this.hsvHue;\r\n  }\r\n  get hslSaturation() {\r\n    const max = Math.max(this.$r, this.$g, this.$b);\r\n    const min = Math.min(this.$r, this.$g, this.$b);\r\n    if (max === min) return 0;\r\n    return (max - min) / (1 - Math.abs(1 - max - min));\r\n  }\r\n  get hslLightness() {\r\n    const max = Math.max(this.$r, this.$g, this.$b);\r\n    const min = Math.min(this.$r, this.$g, this.$b);\r\n    return (max + min) / 2;\r\n  }\r\n  set hsvHue(h) {\r\n    const rgb = QColor.$hsv(h, this.hsvSaturation, this.hsvValue);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set hsvSaturation(s) {\r\n    const rgb = QColor.$hsv(this.hsvHue, s, this.hsvValue);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set hsvValue(v) {\r\n    const rgb = QColor.$hsv(this.hsvHue, this.hsvSaturation, v);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set hslHue(h) {\r\n    const rgb = QColor.$hsl(h, this.hslSaturation, this.hslLightness);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set hslSaturation(s) {\r\n    const rgb = QColor.$hsl(this.hslHue, s, this.hslLightness);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n  set hslLightness(l) {\r\n    const rgb = QColor.$hsl(this.hslHue, this.hslSaturation, l);\r\n    this.$r = rgb[0];\r\n    this.$g = rgb[1];\r\n    this.$b = rgb[2];\r\n    this.$string = this.$cssValue = null;\r\n    this.$changed.execute();\r\n  }\r\n\r\n  static rgba = (r, g, b, a = 1) => new QColor(r, g, b, a);\r\n  static hsva = (h, s, v, a = 1) => new QColor(...QColor.$hsv(h, s, v), a);\r\n  static hsla = (h, s, l, a = 1) => new QColor(...QColor.$hsl(h, s, l), a);\r\n\r\n  static $hsv(h, s, v) {\r\n    const c = v * s;\r\n    const m = v - c;\r\n    return QColor.$hcma(h, c, m);\r\n  }\r\n  static $hsl(h, s, l) {\r\n    const c = (1 - Math.abs(2 * l - 1)) * s;\r\n    const m = l - c / 2;\r\n    return QColor.$hcma(h, c, m);\r\n  }\r\n  static $hcma(h, c, m) {\r\n    const hh = h > 0 ? h * 6 % 6 : 0;\r\n    const x = c * (1 - Math.abs(hh % 2 - 1));\r\n    let rgb;\r\n    switch (Math.floor(hh)) {\r\n      case 0:\r\n        rgb = [c, x, 0];\r\n        break;\r\n      case 1:\r\n        rgb = [x, c, 0];\r\n        break;\r\n      case 2:\r\n        rgb = [0, c, x];\r\n        break;\r\n      case 3:\r\n        rgb = [0, x, c];\r\n        break;\r\n      case 4:\r\n        rgb = [x, 0, c];\r\n        break;\r\n      case 5:\r\n        rgb = [c, 0, x];\r\n        break;\r\n    }\r\n    return rgb.map(y => Math.min(1, y + m));\r\n  }\r\n\r\n  static darker(baseColor, factor = 2) {\r\n    const color = baseColor instanceof QColor ?\r\n      baseColor :\r\n      new QColor(baseColor);\r\n    const v = color.hsvValue / factor;\r\n    // Undocumented in Qt, but this matches the observed Qt behaviour\r\n    const s = color.hsvSaturation - Math.max(0, v - 1);\r\n    return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\r\n  }\r\n  static lighter(baseColor, factor = 1.5) {\r\n    const color = baseColor instanceof QColor ?\r\n      baseColor :\r\n      new QColor(baseColor);\r\n    const v = color.hsvValue * factor;\r\n    // Undocumented in Qt, but this matches the observed Qt behaviour\r\n    const s = color.hsvSaturation - Math.max(0, v - 1);\r\n    return QColor.hsva(color.hsvHue, Math.max(0, s), Math.min(1, v), color.a);\r\n  }\r\n  static equal(lhs, rhs) {\r\n    const a = lhs instanceof QColor ? lhs : new QColor(lhs);\r\n    const b = rhs instanceof QColor ? rhs : new QColor(rhs);\r\n    return a.toString() === b.toString();\r\n  }\r\n\r\n  static colormap = { // https://www.w3.org/TR/SVG/types.html#ColorKeywords\r\n    aliceblue: [240, 248, 255],\r\n    antiquewhite: [250, 235, 215],\r\n    aqua: [0, 255, 255],\r\n    aquamarine: [127, 255, 212],\r\n    azure: [240, 255, 255],\r\n    beige: [245, 245, 220],\r\n    bisque: [255, 228, 196],\r\n    black: [0, 0, 0],\r\n    blanchedalmond: [255, 235, 205],\r\n    blue: [0, 0, 255],\r\n    blueviolet: [138, 43, 226],\r\n    brown: [165, 42, 42],\r\n    burlywood: [222, 184, 135],\r\n    cadetblue: [95, 158, 160],\r\n    chartreuse: [127, 255, 0],\r\n    chocolate: [210, 105, 30],\r\n    coral: [255, 127, 80],\r\n    cornflowerblue: [100, 149, 237],\r\n    cornsilk: [255, 248, 220],\r\n    crimson: [220, 20, 60],\r\n    cyan: [0, 255, 255],\r\n    darkblue: [0, 0, 139],\r\n    darkcyan: [0, 139, 139],\r\n    darkgoldenrod: [184, 134, 11],\r\n    darkgray: [169, 169, 169],\r\n    darkgreen: [0, 100, 0],\r\n    darkgrey: [169, 169, 169],\r\n    darkkhaki: [189, 183, 107],\r\n    darkmagenta: [139, 0, 139],\r\n    darkolivegreen: [85, 107, 47],\r\n    darkorange: [255, 140, 0],\r\n    darkorchid: [153, 50, 204],\r\n    darkred: [139, 0, 0],\r\n    darksalmon: [233, 150, 122],\r\n    darkseagreen: [143, 188, 143],\r\n    darkslateblue: [72, 61, 139],\r\n    darkslategray: [47, 79, 79],\r\n    darkslategrey: [47, 79, 79],\r\n    darkturquoise: [0, 206, 209],\r\n    darkviolet: [148, 0, 211],\r\n    deeppink: [255, 20, 147],\r\n    deepskyblue: [0, 191, 255],\r\n    dimgray: [105, 105, 105],\r\n    dimgrey: [105, 105, 105],\r\n    dodgerblue: [30, 144, 255],\r\n    firebrick: [178, 34, 34],\r\n    floralwhite: [255, 250, 240],\r\n    forestgreen: [34, 139, 34],\r\n    fuchsia: [255, 0, 255],\r\n    gainsboro: [220, 220, 220],\r\n    ghostwhite: [248, 248, 255],\r\n    gold: [255, 215, 0],\r\n    goldenrod: [218, 165, 32],\r\n    gray: [128, 128, 128],\r\n    grey: [128, 128, 128],\r\n    green: [0, 128, 0],\r\n    greenyellow: [173, 255, 47],\r\n    honeydew: [240, 255, 240],\r\n    hotpink: [255, 105, 180],\r\n    indianred: [205, 92, 92],\r\n    indigo: [75, 0, 130],\r\n    ivory: [255, 255, 240],\r\n    khaki: [240, 230, 140],\r\n    lavender: [230, 230, 250],\r\n    lavenderblush: [255, 240, 245],\r\n    lawngreen: [124, 252, 0],\r\n    lemonchiffon: [255, 250, 205],\r\n    lightblue: [173, 216, 230],\r\n    lightcoral: [240, 128, 128],\r\n    lightcyan: [224, 255, 255],\r\n    lightgoldenrodyellow: [250, 250, 210],\r\n    lightgray: [211, 211, 211],\r\n    lightgreen: [144, 238, 144],\r\n    lightgrey: [211, 211, 211],\r\n    lightpink: [255, 182, 193],\r\n    lightsalmon: [255, 160, 122],\r\n    lightseagreen: [32, 178, 170],\r\n    lightskyblue: [135, 206, 250],\r\n    lightslategray: [119, 136, 153],\r\n    lightslategrey: [119, 136, 153],\r\n    lightsteelblue: [176, 196, 222],\r\n    lightyellow: [255, 255, 224],\r\n    lime: [0, 255, 0],\r\n    limegreen: [50, 205, 50],\r\n    linen: [250, 240, 230],\r\n    magenta: [255, 0, 255],\r\n    maroon: [128, 0, 0],\r\n    mediumaquamarine: [102, 205, 170],\r\n    mediumblue: [0, 0, 205],\r\n    mediumorchid: [186, 85, 211],\r\n    mediumpurple: [147, 112, 219],\r\n    mediumseagreen: [60, 179, 113],\r\n    mediumslateblue: [123, 104, 238],\r\n    mediumspringgreen: [0, 250, 154],\r\n    mediumturquoise: [72, 209, 204],\r\n    mediumvioletred: [199, 21, 133],\r\n    midnightblue: [25, 25, 112],\r\n    mintcream: [245, 255, 250],\r\n    mistyrose: [255, 228, 225],\r\n    moccasin: [255, 228, 181],\r\n    navajowhite: [255, 222, 173],\r\n    navy: [0, 0, 128],\r\n    oldlace: [253, 245, 230],\r\n    olive: [128, 128, 0],\r\n    olivedrab: [107, 142, 35],\r\n    orange: [255, 165, 0],\r\n    orangered: [255, 69, 0],\r\n    orchid: [218, 112, 214],\r\n    palegoldenrod: [238, 232, 170],\r\n    palegreen: [152, 251, 152],\r\n    paleturquoise: [175, 238, 238],\r\n    palevioletred: [219, 112, 147],\r\n    papayawhip: [255, 239, 213],\r\n    peachpuff: [255, 218, 185],\r\n    peru: [205, 133, 63],\r\n    pink: [255, 192, 203],\r\n    plum: [221, 160, 221],\r\n    powderblue: [176, 224, 230],\r\n    purple: [128, 0, 128],\r\n    red: [255, 0, 0],\r\n    rosybrown: [188, 143, 143],\r\n    royalblue: [65, 105, 225],\r\n    saddlebrown: [139, 69, 19],\r\n    salmon: [250, 128, 114],\r\n    sandybrown: [244, 164, 96],\r\n    seagreen: [46, 139, 87],\r\n    seashell: [255, 245, 238],\r\n    sienna: [160, 82, 45],\r\n    silver: [192, 192, 192],\r\n    skyblue: [135, 206, 235],\r\n    slateblue: [106, 90, 205],\r\n    slategray: [112, 128, 144],\r\n    slategrey: [112, 128, 144],\r\n    snow: [255, 250, 250],\r\n    springgreen: [0, 255, 127],\r\n    steelblue: [70, 130, 180],\r\n    tan: [210, 180, 140],\r\n    teal: [0, 128, 128],\r\n    thistle: [216, 191, 216],\r\n    tomato: [255, 99, 71],\r\n    turquoise: [64, 224, 208],\r\n    violet: [238, 130, 238],\r\n    wheat: [245, 222, 179],\r\n    white: [255, 255, 255],\r\n    whitesmoke: [245, 245, 245],\r\n    yellow: [255, 255, 0],\r\n    yellowgreen: [154, 205, 50]\r\n  };\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\nQmlWeb.QColor = QColor;\r\n","class QFont extends QmlWeb.QObject {\r\n  constructor(parent) {\r\n    super(parent);\r\n    this.Font = QFont.Font;\r\n\r\n    const Font = this.Font;\r\n\r\n    QmlWeb.createProperties(this, {\r\n      bold: \"bool\",\r\n      capitalization: { type: \"enum\", initialValue: Font.MixedCase },\r\n      family: { type: \"string\", initialValue: \"sans-serif\" },\r\n      italic: \"bool\",\r\n      letterSpacing: \"real\",\r\n      pixelSize: { type: \"int\", initialValue: 13 },\r\n      pointSize: { type: \"real\", initialValue: 10 },\r\n      strikeout: \"bool\",\r\n      underline: \"bool\",\r\n      weight: { type: \"enum\", initialValue: Font.Normal },\r\n      wordSpacing: \"real\"\r\n    });\r\n\r\n    this.$sizeLock = false;\r\n\r\n    this.boldChanged.connect(this, this.$onBoldChanged);\r\n    this.capitalizationChanged.connect(this, this.$onCapitalizationChanged);\r\n    this.familyChanged.connect(this, this.$onFamilyChanged);\r\n    this.italicChanged.connect(this, this.$onItalicChanged);\r\n    this.letterSpacingChanged.connect(this, this.$onLetterSpacingChanged);\r\n    this.pixelSizeChanged.connect(this, this.$onPixelSizeChanged);\r\n    this.pointSizeChanged.connect(this, this.$onPointSizeChanged);\r\n    this.strikeoutChanged.connect(this, this.$onStrikeoutChanged);\r\n    this.underlineChanged.connect(this, this.$onUnderlineChanged);\r\n    this.weightChanged.connect(this, this.$onWidthChanged);\r\n    this.wordSpacingChanged.connect(this, this.$onWordSpacingChanged);\r\n  }\r\n  $onBoldChanged(newVal) {\r\n    const Font = this.Font;\r\n    this.weight = newVal ? Font.Bold : Font.Normal;\r\n  }\r\n  $onCapitalizationChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.fontVariant = newVal === this.Font.SmallCaps ? \"small-caps\" : \"none\";\r\n    style.textTransform = this.$capitalizationToTextTransform(newVal);\r\n  }\r\n  $onFamilyChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.fontFamily = newVal;\r\n  }\r\n  $onItalicChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.fontStyle = newVal ? \"italic\" : \"normal\";\r\n  }\r\n  $onLetterSpacingChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.letterSpacing = newVal !== undefined ? `${newVal}px` : \"\";\r\n  }\r\n  $onPixelSizeChanged(newVal) {\r\n    if (!this.$sizeLock) {\r\n      this.pointSize = newVal * 0.75;\r\n    }\r\n    const val = `${newVal}px`;\r\n    this.$parent.dom.style.fontSize = val;\r\n    this.$parent.dom.firstChild.style.fontSize = val;\r\n  }\r\n  $onPointSizeChanged(newVal) {\r\n    this.$sizeLock = true;\r\n    this.pixelSize = Math.round(newVal / 0.75);\r\n    this.$sizeLock = false;\r\n  }\r\n  $onStrikeoutChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.textDecoration = newVal\r\n      ? \"line-through\"\r\n      : this.$parent.font.underline\r\n        ? \"underline\"\r\n        : \"none\";\r\n  }\r\n  $onUnderlineChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.textDecoration = this.$parent.font.strikeout\r\n      ? \"line-through\"\r\n      : newVal\r\n        ? \"underline\"\r\n        : \"none\";\r\n  }\r\n  $onWidthChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.fontWeight = this.$weightToCss(newVal);\r\n  }\r\n  $onWordSpacingChanged(newVal) {\r\n    const style = this.$parent.dom.firstChild.style;\r\n    style.wordSpacing = newVal !== undefined ? `${newVal}px` : \"\";\r\n  }\r\n\r\n  $weightToCss(weight) {\r\n    const Font = this.Font;\r\n    switch (weight) {\r\n      case Font.Thin: return \"100\";\r\n      case Font.ExtraLight: return \"200\";\r\n      case Font.Light: return \"300\";\r\n      case Font.Normal: return \"400\";\r\n      case Font.Medium: return \"500\";\r\n      case Font.DemiBold: return \"600\";\r\n      case Font.Bold: return \"700\";\r\n      case Font.ExtraBold: return \"800\";\r\n      case Font.Black: return \"900\";\r\n    }\r\n    return \"normal\";\r\n  }\r\n  $capitalizationToTextTransform(capitalization) {\r\n    const Font = this.Font;\r\n    switch (capitalization) {\r\n      case Font.AllUppercase: return \"uppercase\";\r\n      case Font.AllLowercase: return \"lowercase\";\r\n      case Font.Capitalize: return \"capitalize\";\r\n    }\r\n    return \"none\";\r\n  }\r\n\r\n  static Font = {\r\n    // Capitalization\r\n    MixedCase: 0,\r\n    AllUppercase: 1,\r\n    AllLowercase: 2,\r\n    SmallCaps: 3,\r\n    Capitalize: 4,\r\n    // Weight\r\n    Thin: 0,\r\n    ExtraLight: 12,\r\n    Light: 25,\r\n    Normal: 50,\r\n    Medium: 57,\r\n    DemiBold: 63,\r\n    Bold: 75,\r\n    ExtraBold: 81,\r\n    Black: 87\r\n  };\r\n  static requireParent = true;\r\n}\r\n\r\nQmlWeb.QFont = QFont;\r\nglobal.Font = QFont.Font; // HACK\r\n","class QMatrix4x4 extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 0) {\r\n      data = [];\r\n      for (let row = 1; row <= 4; row++) {\r\n        for (let col = 1; col <= 4; col++) {\r\n          data.push(col === row ? 1 : 0);\r\n        }\r\n      }\r\n    } else if (args.length === 1 && args[0] instanceof QMatrix4x4) {\r\n      data = [];\r\n      for (let row = 1; row <= 4; row++) {\r\n        for (let col = 1; col <= 4; col++) {\r\n          const name = `m${row}${col}`;\r\n          data.push(args[0][name]);\r\n        }\r\n      }\r\n    } else if (args.length !== 16) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    for (let row = 1; row <= 4; row++) {\r\n      for (let col = 1; col <= 4; col++) {\r\n        const name = `m${row}${col}`;\r\n        const value = data[4 * (row - 1) + col - 1];\r\n        QmlWeb.createProperty(\"real\", this, name, { initialValue: value });\r\n      }\r\n    }\r\n  }\r\n  toString() {\r\n    return super.$toString(\r\n      this.m11, this.m12, this.m13, this.m14,\r\n      this.m21, this.m22, this.m23, this.m24,\r\n      this.m31, this.m32, this.m33, this.m34,\r\n      this.m41, this.m42, this.m43, this.m44\r\n    );\r\n  }\r\n  times(a) {\r\n    if (a instanceof QmlWeb.QMatrix4x4) {\r\n      const t = this;\r\n      return new QmlWeb.QMatrix4x4(\r\n        t.m11 * a.m11 + t.m12 * a.m21 + t.m13 * a.m31 + t.m14 * a.m41,\r\n        t.m11 * a.m12 + t.m12 * a.m22 + t.m13 * a.m32 + t.m14 * a.m42,\r\n        t.m11 * a.m13 + t.m12 * a.m23 + t.m13 * a.m33 + t.m14 * a.m43,\r\n        t.m11 * a.m14 + t.m12 * a.m24 + t.m13 * a.m34 + t.m14 * a.m44,\r\n\r\n        t.m21 * a.m11 + t.m22 * a.m21 + t.m23 * a.m31 + t.m24 * a.m41,\r\n        t.m21 * a.m12 + t.m22 * a.m22 + t.m23 * a.m32 + t.m24 * a.m42,\r\n        t.m21 * a.m13 + t.m22 * a.m23 + t.m23 * a.m33 + t.m24 * a.m43,\r\n        t.m21 * a.m14 + t.m22 * a.m24 + t.m23 * a.m34 + t.m24 * a.m44,\r\n\r\n        t.m31 * a.m11 + t.m32 * a.m21 + t.m33 * a.m31 + t.m34 * a.m41,\r\n        t.m31 * a.m12 + t.m32 * a.m22 + t.m33 * a.m32 + t.m34 * a.m42,\r\n        t.m31 * a.m13 + t.m32 * a.m23 + t.m33 * a.m33 + t.m34 * a.m43,\r\n        t.m31 * a.m14 + t.m32 * a.m24 + t.m33 * a.m34 + t.m34 * a.m44,\r\n\r\n        t.m41 * a.m11 + t.m42 * a.m21 + t.m43 * a.m31 + t.m44 * a.m41,\r\n        t.m41 * a.m12 + t.m42 * a.m22 + t.m43 * a.m32 + t.m44 * a.m42,\r\n        t.m41 * a.m13 + t.m42 * a.m23 + t.m43 * a.m33 + t.m44 * a.m43,\r\n        t.m41 * a.m14 + t.m42 * a.m24 + t.m43 * a.m34 + t.m44 * a.m44\r\n      );\r\n    }\r\n    if (a instanceof QmlWeb.QVector4D) {\r\n      const t = this;\r\n      return new QmlWeb.QVector4D(\r\n        t.m11 * a.x + t.m12 * a.y + t.m13 * a.z + t.m14 * a.w,\r\n        t.m21 * a.x + t.m22 * a.y + t.m23 * a.z + t.m24 * a.w,\r\n        t.m31 * a.x + t.m32 * a.y + t.m33 * a.z + t.m34 * a.w,\r\n        t.m41 * a.x + t.m42 * a.y + t.m43 * a.z + t.m44 * a.w\r\n      );\r\n    }\r\n    if (a instanceof QmlWeb.QVector3D) {\r\n      const v = this.times(new QmlWeb.QVector4D(a.x, a.y, a.z, 1));\r\n      return new QmlWeb.QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\r\n    }\r\n    return new QMatrix4x4(\r\n      this.m11 * a, this.m12 * a, this.m13 * a, this.m14 * a,\r\n      this.m21 * a, this.m22 * a, this.m23 * a, this.m24 * a,\r\n      this.m31 * a, this.m32 * a, this.m33 * a, this.m34 * a,\r\n      this.m41 * a, this.m42 * a, this.m43 * a, this.m44 * a\r\n    );\r\n  }\r\n  plus(other) {\r\n    const a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\r\n    return new QMatrix4x4(\r\n      this.m11 + a.m11, this.m12 + a.m12, this.m13 + a.m13, this.m14 + a.m14,\r\n      this.m21 + a.m21, this.m22 + a.m22, this.m23 + a.m23, this.m24 + a.m24,\r\n      this.m31 + a.m31, this.m32 + a.m32, this.m33 + a.m33, this.m34 + a.m34,\r\n      this.m41 + a.m41, this.m42 + a.m42, this.m43 + a.m43, this.m44 + a.m44\r\n    );\r\n  }\r\n  minus(other) {\r\n    const a = other instanceof QMatrix4x4 ? other : new QMatrix4x4();\r\n    return new QMatrix4x4(\r\n      this.m11 - a.m11, this.m12 - a.m12, this.m13 - a.m13, this.m14 - a.m14,\r\n      this.m21 - a.m21, this.m22 - a.m22, this.m23 - a.m23, this.m24 - a.m24,\r\n      this.m31 - a.m31, this.m32 - a.m32, this.m33 - a.m33, this.m34 - a.m34,\r\n      this.m41 - a.m41, this.m42 - a.m42, this.m43 - a.m43, this.m44 - a.m44\r\n    );\r\n  }\r\n  row(i) {\r\n    const row = i + 1;\r\n    const arr = [1, 2, 3, 4].map(col => this[`m${row}${col}`]);\r\n    return new QmlWeb.QVector4D(...arr);\r\n  }\r\n  column(i) {\r\n    const col = i + 1;\r\n    const arr = [1, 2, 3, 4].map(row => this[`m${row}${col}`]);\r\n    return new QmlWeb.QVector4D(...arr);\r\n  }\r\n  determinant() {\r\n    // Laplace expansion\r\n    const t = this;\r\n    const s0 = t.m11 * t.m22 - t.m12 * t.m21;\r\n    const c5 = t.m33 * t.m44 - t.m34 * t.m43;\r\n    const s1 = t.m11 * t.m23 - t.m13 * t.m21;\r\n    const c4 = t.m32 * t.m44 - t.m34 * t.m42;\r\n    const s2 = t.m11 * t.m24 - t.m14 * t.m21;\r\n    const c3 = t.m32 * t.m43 - t.m33 * t.m42;\r\n    const s3 = t.m12 * t.m23 - t.m13 * t.m22;\r\n    const c2 = t.m31 * t.m44 - t.m34 * t.m41;\r\n    const s4 = t.m12 * t.m24 - t.m14 * t.m22;\r\n    const c1 = t.m31 * t.m43 - t.m33 * t.m41;\r\n    const s5 = t.m13 * t.m24 - t.m14 * t.m23;\r\n    const c0 = t.m31 * t.m42 - t.m32 * t.m41;\r\n    return s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\r\n  }\r\n  inverted() {\r\n    // Laplace expansion\r\n    const t = this;\r\n    const s0 = t.m11 * t.m22 - t.m12 * t.m21;\r\n    const c5 = t.m33 * t.m44 - t.m34 * t.m43;\r\n    const s1 = t.m11 * t.m23 - t.m13 * t.m21;\r\n    const c4 = t.m32 * t.m44 - t.m34 * t.m42;\r\n    const s2 = t.m11 * t.m24 - t.m14 * t.m21;\r\n    const c3 = t.m32 * t.m43 - t.m33 * t.m42;\r\n    const s3 = t.m12 * t.m23 - t.m13 * t.m22;\r\n    const c2 = t.m31 * t.m44 - t.m34 * t.m41;\r\n    const s4 = t.m12 * t.m24 - t.m14 * t.m22;\r\n    const c1 = t.m31 * t.m43 - t.m33 * t.m41;\r\n    const s5 = t.m13 * t.m24 - t.m14 * t.m23;\r\n    const c0 = t.m31 * t.m42 - t.m32 * t.m41;\r\n    const det = s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0;\r\n    const adj = [\r\n      +t.m22 * c5 - t.m23 * c4 + t.m24 * c3,\r\n      -t.m12 * c5 + t.m13 * c4 - t.m14 * c3,\r\n      +t.m42 * s5 - t.m43 * s4 + t.m44 * s3,\r\n      -t.m32 * s5 + t.m33 * s4 - t.m34 * s3,\r\n\r\n      -t.m21 * c5 + t.m23 * c2 - t.m24 * c1,\r\n      +t.m11 * c5 - t.m13 * c2 + t.m14 * c1,\r\n      -t.m41 * s5 + t.m43 * s2 - t.m44 * s1,\r\n      +t.m31 * s5 - t.m33 * s2 + t.m34 * s1,\r\n\r\n      +t.m21 * c4 - t.m22 * c2 + t.m24 * c0,\r\n      -t.m11 * c4 + t.m12 * c2 - t.m14 * c0,\r\n      +t.m41 * s4 - t.m42 * s2 + t.m44 * s0,\r\n      -t.m31 * s4 + t.m32 * s2 - t.m34 * s0,\r\n\r\n      -t.m21 * c3 + t.m22 * c1 - t.m23 * c0,\r\n      +t.m11 * c3 - t.m12 * c1 + t.m13 * c0,\r\n      -t.m41 * s3 + t.m42 * s1 - t.m43 * s0,\r\n      +t.m31 * s3 - t.m32 * s1 + t.m33 * s0\r\n    ];\r\n    return new QMatrix4x4(...adj.map(x => x / det));\r\n  }\r\n  transposed() {\r\n    return new QMatrix4x4(\r\n      this.m11, this.m21, this.m31, this.m41,\r\n      this.m12, this.m22, this.m32, this.m42,\r\n      this.m13, this.m23, this.m33, this.m43,\r\n      this.m14, this.m24, this.m34, this.m44\r\n    );\r\n  }\r\n  fuzzyEquals(a, epsilon = 0.00001) {\r\n    for (let row = 1; row <= 4; row++) {\r\n      for (let col = 1; col <= 4; col++) {\r\n        const name = `m${row}${col}`;\r\n        if (Math.abs(this[name] - a[name]) > epsilon) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QMatrix4x4 = QMatrix4x4;\r\n","class QPointF extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 0) {\r\n      data = [0, 0];\r\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\",\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 2) throw new Error(\"point expected\");\r\n    } else if (args.length === 1 && args[0] instanceof QPointF) {\r\n      data = [args[0].x, args[0].y];\r\n    } else if (args.length !== 2) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      x: { type: \"real\", initialValue: data[0] },\r\n      y: { type: \"real\", initialValue: data[1] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.x, this.y);\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QPointF = QPointF;\r\n","class QQuaternion extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\",\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 4) data = [];\r\n    } else if (args.length === 1 && args[0] instanceof QQuaternion) {\r\n      data = [args[0].scalar, args[0].x, args[0].y, args[0].z];\r\n    }\r\n    if (data.length === 0) {\r\n      data = [1, 0, 0, 0];\r\n    } else if (data.length !== 4) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      scalar: { type: \"real\", initialValue: data[0] },\r\n      x: { type: \"real\", initialValue: data[1] },\r\n      y: { type: \"real\", initialValue: data[2] },\r\n      z: { type: \"real\", initialValue: data[3] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.scalar, this.x, this.y, this.z);\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QQuaternion = QQuaternion;\r\n","class QRectF extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 0) {\r\n      data = [0, 0, 0, 0];\r\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\r\n      const mask = /^\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*,\\s*[-\\d.]+\\s*x\\s*[-\\d.]+\\s*$/;\r\n      if (!args[0].match(mask)) throw new Error(\"rect expected\");\r\n      data = args[0].replace(\"x\", \",\").split(\",\")\r\n                    .map(x => parseFloat(x.trim(), 10));\r\n    } else if (args.length === 1 && args[0] instanceof QRectF) {\r\n      data = [args[0].x, args[0].y, args[0].z, args[0].width];\r\n    } else if (args.length !== 4) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      x: { type: \"real\", initialValue: data[0] },\r\n      y: { type: \"real\", initialValue: data[1] },\r\n      width: { type: \"real\", initialValue: data[2] },\r\n      height: { type: \"real\", initialValue: data[3] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.x, this.y, this.width, this.height);\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QRectF = QRectF;\r\n","class QSizeF extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 0) {\r\n      data = [-1, -1];\r\n    } else if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\"x\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 2) throw new Error(\"size expected\");\r\n    } else if (args.length === 1 && args[0] instanceof QSizeF) {\r\n      data = [args[0].width, args[0].height];\r\n    } else if (args.length !== 2) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      width: { type: \"real\", initialValue: data[0] },\r\n      height: { type: \"real\", initialValue: data[1] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.width, this.height);\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QSizeF = QSizeF;\r\n","class QVector2D extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\",\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 2) data = [];\r\n    } else if (args.length === 1 && args[0] instanceof QVector2D) {\r\n      data = [args[0].x, args[0].y];\r\n    }\r\n    if (data.length === 0) {\r\n      data = [0, 0];\r\n    } else if (data.length !== 2) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      x: { type: \"real\", initialValue: data[0] },\r\n      y: { type: \"real\", initialValue: data[1] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.x, this.y);\r\n  }\r\n  dotProduct(a) {\r\n    if (a instanceof QVector2D) {\r\n      return a.x * this.x + a.y * this.y;\r\n    }\r\n    return 0;\r\n  }\r\n  times(a) {\r\n    if (a instanceof QVector2D) {\r\n      return new QVector2D(this.x * a.x, this.y * a.y);\r\n    }\r\n    return new QVector2D(this.x * a, this.y * a);\r\n  }\r\n  plus(a) {\r\n    if (a instanceof QVector2D) {\r\n      return new QVector2D(this.x + a.x, this.y + a.y);\r\n    }\r\n    return new QVector2D(this.x, this.y);\r\n  }\r\n  minus(a) {\r\n    if (a instanceof QVector2D) {\r\n      return new QVector2D(this.x - a.x, this.y - a.y);\r\n    }\r\n    return new QVector2D(this.x, this.y);\r\n  }\r\n  normalized() {\r\n    const length = this.length();\r\n    return this.times(1 / (length === 0 ? 1 : length));\r\n  }\r\n  length() {\r\n    return Math.sqrt(this.dotProduct(this));\r\n  }\r\n  toVector3d() {\r\n    return new QmlWeb.QVector3D(this.x, this.y, 0);\r\n  }\r\n  toVector4d() {\r\n    return new QmlWeb.QVector4D(this.x, this.y, 0, 0);\r\n  }\r\n  fuzzyEquals(a, epsilon = 0.00001) {\r\n    return [this.x - a.x, this.y - a.y].every(\r\n      delta => Math.abs(delta) <= epsilon\r\n    );\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QVector2D = QVector2D;\r\n","class QVector3D extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\",\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 3) data = [];\r\n    } else if (args.length === 1 && args[0] instanceof QVector3D) {\r\n      data = [args[0].x, args[0].y, args[0].z];\r\n    }\r\n    if (data.length === 0) {\r\n      data = [0, 0, 0];\r\n    } else if (data.length !== 3) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      x: { type: \"real\", initialValue: data[0] },\r\n      y: { type: \"real\", initialValue: data[1] },\r\n      z: { type: \"real\", initialValue: data[2] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.x, this.y, this.z);\r\n  }\r\n  crossProduct(a) {\r\n    if (a instanceof QVector3D) {\r\n      return new QVector3D(\r\n        this.y * a.z - this.z * a.y,\r\n        this.z * a.x - this.x * a.z,\r\n        this.x * a.y - this.y * a.x\r\n      );\r\n    }\r\n    return new QVector3D();\r\n  }\r\n  dotProduct(a) {\r\n    if (a instanceof QVector3D) {\r\n      return a.x * this.x + a.y * this.y + a.z * this.z;\r\n    }\r\n    return 0;\r\n  }\r\n  times(a) {\r\n    if (a instanceof QmlWeb.QMatrix4x4) {\r\n      const v = new QmlWeb.QVector4D(this.x, this.y, this.z, 1).times(a);\r\n      return new QVector3D(v.x / v.w, v.y / v.w, v.z / v.w);\r\n    }\r\n    if (a instanceof QVector3D) {\r\n      return new QVector3D(this.x * a.x, this.y * a.y, this.z * a.z);\r\n    }\r\n    return new QVector3D(this.x * a, this.y * a, this.z * a);\r\n  }\r\n  plus(a) {\r\n    if (a instanceof QVector3D) {\r\n      return new QVector3D(this.x + a.x, this.y + a.y, this.z + a.z);\r\n    }\r\n    return new QVector3D(this.x, this.y, this.z);\r\n  }\r\n  minus(a) {\r\n    if (a instanceof QVector3D) {\r\n      return new QVector3D(this.x - a.x, this.y - a.y, this.z - a.z);\r\n    }\r\n    return new QVector3D(this.x, this.y, this.z);\r\n  }\r\n  normalized() {\r\n    const length = this.length();\r\n    return this.times(1 / (length === 0 ? 1 : length));\r\n  }\r\n  length() {\r\n    return Math.sqrt(this.dotProduct(this));\r\n  }\r\n  toVector2d() {\r\n    return new QmlWeb.QVector2D(this.x, this.y);\r\n  }\r\n  toVector4d() {\r\n    return new QmlWeb.QVector4D(this.x, this.y, this.z, 0);\r\n  }\r\n  fuzzyEquals(a, epsilon = 0.00001) {\r\n    return [this.x - a.x, this.y - a.y, this.z - a.z].every(\r\n      delta => Math.abs(delta) <= epsilon\r\n    );\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QVector3D = QVector3D;\r\n","class QVector4D extends QmlWeb.QObject {\r\n  constructor(...args) {\r\n    super();\r\n    let data = args;\r\n    if (args.length === 1 && typeof args[0] === \"string\") {\r\n      data = args[0].split(\",\").map(x => parseFloat(x.trim(), 10));\r\n      if (data.length !== 4) data = [];\r\n    } else if (args.length === 1 && args[0] instanceof QVector4D) {\r\n      data = [args[0].x, args[0].y, args[0].z, args[0].w];\r\n    }\r\n    if (data.length === 0) {\r\n      data = [0, 0, 0, 0];\r\n    } else if (data.length !== 4) {\r\n      throw new Error(\"Invalid arguments\");\r\n    }\r\n    QmlWeb.createProperties(this, {\r\n      x: { type: \"real\", initialValue: data[0] },\r\n      y: { type: \"real\", initialValue: data[1] },\r\n      z: { type: \"real\", initialValue: data[2] },\r\n      w: { type: \"real\", initialValue: data[3] }\r\n    });\r\n  }\r\n  toString() {\r\n    return super.$toString(this.x, this.y, this.z, this.w);\r\n  }\r\n  dotProduct(a) {\r\n    if (a instanceof QVector4D) {\r\n      return a.x * this.x + a.y * this.y + a.z * this.z + a.w * this.w;\r\n    }\r\n    return 0;\r\n  }\r\n  times(a) {\r\n    if (a instanceof QmlWeb.QMatrix4x4) {\r\n      const t = this;\r\n      return new QVector4D(\r\n        t.x * a.m11 + t.y * a.m21 + t.z * a.m31 + t.w * a.m41,\r\n        t.x * a.m12 + t.y * a.m22 + t.z * a.m32 + t.w * a.m42,\r\n        t.x * a.m13 + t.y * a.m23 + t.z * a.m33 + t.w * a.m43,\r\n        t.x * a.m14 + t.y * a.m24 + t.z * a.m34 + t.w * a.m44\r\n      );\r\n    }\r\n    if (a instanceof QVector4D) {\r\n      const t = this;\r\n      return new QVector4D(t.x * a.x, t.y * a.y, t.z * a.z, t.w * a.w);\r\n    }\r\n    return new QVector4D(this.x * a, this.y * a, this.z * a, this.w * a);\r\n  }\r\n  plus(a) {\r\n    if (a instanceof QVector4D) {\r\n      const t = this;\r\n      return new QVector4D(t.x + a.x, t.y + a.y, t.z + a.z, t.w + a.w);\r\n    }\r\n    return new QVector4D(this.x, this.y, this.z, this.w);\r\n  }\r\n  minus(a) {\r\n    if (a instanceof QVector4D) {\r\n      const t = this;\r\n      return new QVector4D(t.x - a.x, t.y - a.y, t.z - a.z, t.w - a.w);\r\n    }\r\n    return new QVector4D(this.x, this.y, this.z, this.w);\r\n  }\r\n  normalized() {\r\n    const length = this.length();\r\n    return this.times(1 / (length === 0 ? 1 : length));\r\n  }\r\n  length() {\r\n    return Math.sqrt(this.dotProduct(this));\r\n  }\r\n  toVector2d() {\r\n    return new QmlWeb.QVector2D(this.x, this.y);\r\n  }\r\n  toVector3d() {\r\n    return new QmlWeb.QVector3D(this.x, this.y, this.z);\r\n  }\r\n  fuzzyEquals(a, epsilon = 0.00001) {\r\n    return [this.x - a.x, this.y - a.y, this.z - a.z, this.w - a.w].every(\r\n      delta => Math.abs(delta) <= epsilon\r\n    );\r\n  }\r\n\r\n  static nonNullableType = true;\r\n  static requireConstructor = true;\r\n}\r\n\r\nQmlWeb.QVector4D = QVector4D;\r\n","class Signal {\r\n  constructor(params = [], options = {}) {\r\n    this.connectedSlots = [];\r\n    this.obj = options.obj;\r\n    this.options = options;\r\n\r\n    this.signal = (...args) => this.execute(...args);\r\n    this.signal.parameters = params;\r\n    this.signal.connect = this.connect.bind(this);\r\n    this.signal.disconnect = this.disconnect.bind(this);\r\n    this.signal.isConnected = this.isConnected.bind(this);\r\n\r\n    // TODO Fix Keys that don't have an obj for the signal\r\n    if (this.obj && this.obj.$signals !== undefined) {\r\n      this.obj.$signals.push(this.signal);\r\n    }\r\n  }\r\n  execute(...args) {\r\n    QmlWeb.QMLProperty.pushEvalStack();\r\n    for (const i in this.connectedSlots) {\r\n      const desc = this.connectedSlots[i];\r\n      if (desc.type & Signal.QueuedConnection) {\r\n        Signal.$addQueued(desc, args);\r\n      } else {\r\n        Signal.$execute(desc, args);\r\n      }\r\n    }\r\n    QmlWeb.QMLProperty.popEvalStack();\r\n  }\r\n  connect(...args) {\r\n    let type = Signal.AutoConnection;\r\n    if (typeof args[args.length - 1] === \"number\") {\r\n      type = args.pop();\r\n    }\r\n    if (type & Signal.UniqueConnection) {\r\n      if (this.isConnected(...args)) {\r\n        return;\r\n      }\r\n    }\r\n    if (args.length === 1) {\r\n      this.connectedSlots.push({ thisObj: global, slot: args[0], type });\r\n    } else if (typeof args[1] === \"string\" || args[1] instanceof String) {\r\n      if (args[0].$tidyupList && args[0] !== this.obj) {\r\n        args[0].$tidyupList.push(this.signal);\r\n      }\r\n      const slot = args[0][args[1]];\r\n      this.connectedSlots.push({ thisObj: args[0], slot, type });\r\n    } else {\r\n      if (args[0].$tidyupList &&\r\n        (!this.obj || args[0] !== this.obj && args[0] !== this.obj.$parent)\r\n      ) {\r\n        args[0].$tidyupList.push(this.signal);\r\n      }\r\n      this.connectedSlots.push({ thisObj: args[0], slot: args[1], type });\r\n    }\r\n\r\n    // Notify object of connect\r\n    if (this.options.obj && this.options.obj.$connectNotify) {\r\n      this.options.obj.$connectNotify(this.options);\r\n    }\r\n  }\r\n  disconnect(...args) {\r\n    // type meaning:\r\n    //  1 = function, 2 = string\r\n    //  3 = object with string method,  4 = object with function\r\n    // No args means disconnect everything connected to this signal\r\n    const callType = args.length === 1\r\n      ? args[0] instanceof Function ? 1 : 2\r\n      : typeof args[1] === \"string\" || args[1] instanceof String ? 3 : 4;\r\n    for (let i = 0; i < this.connectedSlots.length; i++) {\r\n      const { slot, thisObj } = this.connectedSlots[i];\r\n      if (\r\n        args.length === 0 ||\r\n        callType === 1 && slot === args[0] ||\r\n        callType === 2 && thisObj === args[0] ||\r\n        callType === 3 && thisObj === args[0] && slot === args[0][args[1]] ||\r\n        thisObj === args[0] && slot === args[1]\r\n      ) {\r\n        if (thisObj) {\r\n          const index = thisObj.$tidyupList.indexOf(this.signal);\r\n          if (index >= 0) {\r\n            thisObj.$tidyupList.splice(index, 1);\r\n          }\r\n        }\r\n        this.connectedSlots.splice(i, 1);\r\n        // We have removed an item from the list so the indexes shifted one\r\n        // backwards\r\n        i--;\r\n      }\r\n    }\r\n\r\n    // Notify object of disconnect\r\n    if (this.options.obj && this.options.obj.$disconnectNotify) {\r\n      this.options.obj.$disconnectNotify(this.options);\r\n    }\r\n  }\r\n  isConnected(...args) {\r\n    const callType = args.length === 1 ? 1\r\n      : typeof args[1] === \"string\" || args[1] instanceof String ? 2 : 3;\r\n    for (const i in this.connectedSlots) {\r\n      const { slot, thisObj } = this.connectedSlots[i];\r\n      if (callType === 1 && slot === args[0] ||\r\n          callType === 2 && thisObj === args[0] && slot === args[0][args[1]] ||\r\n          thisObj === args[0] && slot === args[1]\r\n      ) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  static signal(...args) {\r\n    return (new Signal(...args)).signal;\r\n  }\r\n\r\n  static $execute(desc, args) {\r\n    try {\r\n      desc.slot.apply(desc.thisObj, args);\r\n    } catch (err) {\r\n      console.error(\"Signal slot error:\", err.message, err,\r\n        desc.slot\r\n        ? Function.prototype.toString.call(desc.slot)\r\n        : \"desc.slot is undefined!\"\r\n      );\r\n    }\r\n  }\r\n\r\n  static $addQueued(desc, args) {\r\n    if (Signal.$queued.length === 0) {\r\n      if (global.setImmediate) {\r\n        global.setImmediate(Signal.$executeQueued);\r\n      } else {\r\n        global.setTimeout(Signal.$executeQueued, 0);\r\n      }\r\n    }\r\n    Signal.$queued.push([desc, args]);\r\n  }\r\n  static $executeQueued() {\r\n    // New queued signals should be executed on next tick of the event loop\r\n    const queued = Signal.$queued;\r\n    Signal.$queued = [];\r\n\r\n    QmlWeb.QMLProperty.pushEvalStack();\r\n    for (const i in queued) {\r\n      Signal.$execute(...queued[i]);\r\n    }\r\n    QmlWeb.QMLProperty.popEvalStack();\r\n  }\r\n\r\n  static $queued = [];\r\n\r\n  static AutoConnection = 0;\r\n  static DirectConnection = 1;\r\n  static QueuedConnection = 2;\r\n  static UniqueConnection = 128;\r\n}\r\n\r\nQmlWeb.Signal = Signal;\r\n","const Qt = {\r\n  openUrlExternally: url => {\r\n    const page = window.open(url, \"_blank\");\r\n    page.focus();\r\n  },\r\n  // Load file, parse and construct as Component (.qml)\r\n  createComponent: name => {\r\n    const engine = QmlWeb.engine;\r\n\r\n    let file = engine.$resolvePath(name);\r\n\r\n    // If \"name\" was a full URL, \"file\" will be equivalent to name and this\r\n    // will try and load the Component from the full URL, otherwise, this\r\n    // doubles as checking for the file in the current directory.\r\n    let tree = engine.loadComponent(file);\r\n\r\n    // If the Component is not found, and it is not a URL, look for \"name\" in\r\n    // this context's importSearchPaths\r\n    if (!tree) {\r\n      const nameIsUrl = engine.$parseURI(name) !== undefined;\r\n      if (!nameIsUrl) {\r\n        const moreDirs = engine.importSearchPaths(\r\n          QmlWeb.executionContext.importContextId);\r\n        for (let i = 0; i < moreDirs.length; i++) {\r\n          file = `${moreDirs[i]}${name}`;\r\n          tree = engine.loadComponent(file);\r\n          if (tree) break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!tree) {\r\n      return undefined;\r\n    }\r\n\r\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n    const component = new QMLComponent({\r\n      object: tree,\r\n      context: QmlWeb.executionContext\r\n    });\r\n    component.$basePath = engine.extractBasePath(file);\r\n    component.$imports = tree.$imports;\r\n    component.$file = file; // just for debugging\r\n\r\n    engine.loadImports(tree.$imports, component.$basePath,\r\n      component.importContextId);\r\n\r\n    return component;\r\n  },\r\n\r\n  createQmlObject: (src, parent, file) => {\r\n    const tree = QmlWeb.parseQML(src, file);\r\n\r\n    // Create and initialize objects\r\n\r\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n    const component = new QMLComponent({\r\n      object: tree,\r\n      parent,\r\n      context: QmlWeb.executionContext\r\n    });\r\n\r\n    const engine = QmlWeb.engine;\r\n    engine.loadImports(tree.$imports, undefined, component.importContextId);\r\n\r\n    const resolvedFile = file || Qt.resolvedUrl(\"createQmlObject_function\");\r\n    component.$basePath = engine.extractBasePath(resolvedFile);\r\n    component.$imports = tree.$imports; // for later use\r\n    // not just for debugging, but for basepath too, see above\r\n    component.$file = resolvedFile;\r\n\r\n    const obj = component.createObject(parent);\r\n\r\n    const QMLOperationState = QmlWeb.QMLOperationState;\r\n    if (engine.operationState !== QMLOperationState.Init &&\r\n        engine.operationState !== QMLOperationState.Idle) {\r\n      // We don't call those on first creation, as they will be called\r\n      // by the regular creation-procedures at the right time.\r\n      engine.$initializePropertyBindings();\r\n\r\n      engine.callCompletedSignals();\r\n    }\r\n\r\n    return obj;\r\n  },\r\n\r\n  // Returns url resolved relative to the URL of the caller.\r\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\r\n  resolvedUrl: url => QmlWeb.qmlUrl(url),\r\n\r\n  // Basic QML types constructors\r\n  point: (...args) => new QmlWeb.QPointF(...args),\r\n  rect: (...args) => new QmlWeb.QRectF(...args),\r\n  size: (...args) => new QmlWeb.QSizeF(...args),\r\n  vector2d: (...args) => new QmlWeb.QVector2D(...args),\r\n  vector3d: (...args) => new QmlWeb.QVector3D(...args),\r\n  vector4d: (...args) => new QmlWeb.QVector4D(...args),\r\n  quaternion: (...args) => new QmlWeb.QQuaternion(...args),\r\n  matrix4x4: (...args) => new QmlWeb.QMatrix4x4(...args),\r\n\r\n  // Colors\r\n  rgba: (...args) => QmlWeb.QColor.rgba(...args),\r\n  hsla: (...args) => QmlWeb.QColor.hsla(...args),\r\n  hsva: (...args) => QmlWeb.QColor.hsva(...args),\r\n  colorEqual: (...args) => QmlWeb.QColor.equal(...args),\r\n  darker: (...args) => QmlWeb.QColor.darker(...args),\r\n  lighter: (...args) => QmlWeb.QColor.lighter(...args),\r\n\r\n  include(path) {\r\n    const engine = QmlWeb.engine;\r\n\r\n    const uri = engine.$resolvePath(path);\r\n\r\n    /* Handle recursive includes */\r\n    if (QmlWeb.executionContext.$qmlJsIncludes === undefined) {\r\n      QmlWeb.executionContext.$qmlJsIncludes = [];\r\n    }\r\n\r\n    if (QmlWeb.executionContext.$qmlJsIncludes.indexOf(uri) >= 0) {\r\n      return;\r\n    }\r\n\r\n    QmlWeb.executionContext.$qmlJsIncludes.push(uri);\r\n\r\n    const js = engine.loadJS(uri);\r\n\r\n    if (!js) {\r\n      console.error(\"Unable to load JavaScript module:\", uri, path);\r\n      return;\r\n    }\r\n\r\n    QmlWeb.importJavascriptInContext(js, QmlWeb.executionContext);\r\n  },\r\n\r\n  platform: {\r\n    os: \"qmlweb\"\r\n  },\r\n\r\n  // Buttons masks\r\n  LeftButton: 1,\r\n  RightButton: 2,\r\n  MiddleButton: 4,\r\n  // Modifiers masks\r\n  NoModifier: 0,\r\n  ShiftModifier: 1,\r\n  ControlModifier: 2,\r\n  AltModifier: 4,\r\n  MetaModifier: 8,\r\n  KeypadModifier: 16, // Note: Not available in web\r\n  // Layout directions\r\n  LeftToRight: 0,\r\n  RightToLeft: 1,\r\n  // Orientations\r\n  Vertical: 0,\r\n  Horizontal: 1,\r\n  // Keys\r\n  Key_Escape: 27,\r\n  Key_Tab: 9,\r\n  Key_Backtab: 245,\r\n  Key_Backspace: 8,\r\n  Key_Return: 13,\r\n  Key_Enter: 13,\r\n  Key_Insert: 45,\r\n  Key_Delete: 46,\r\n  Key_Pause: 19,\r\n  Key_Print: 42,\r\n  Key_SysReq: 0,\r\n  Key_Clear: 12,\r\n  Key_Home: 36,\r\n  Key_End: 35,\r\n  Key_Left: 37,\r\n  Key_Up: 38,\r\n  Key_Right: 39,\r\n  Key_Down: 40,\r\n  Key_PageUp: 33,\r\n  Key_PageDown: 34,\r\n  Key_Shift: 16,\r\n  Key_Control: 17,\r\n  Key_Meta: 91,\r\n  Key_Alt: 18,\r\n  Key_AltGr: 0,\r\n  Key_CapsLock: 20,\r\n  Key_NumLock: 144,\r\n  Key_ScrollLock: 145,\r\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117,\r\n  Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122,\r\n  Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127,\r\n  Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132,\r\n  Key_F22: 133, Key_F23: 134, Key_F24: 135,\r\n  Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0,\r\n  Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\r\n  Key_Super_L: 0,\r\n  Key_Super_R: 0,\r\n  Key_Menu: 0,\r\n  Key_Hyper_L: 0,\r\n  Key_Hyper_R: 0,\r\n  Key_Help: 6,\r\n  Key_Direction_L: 0,\r\n  Key_Direction_R: 0,\r\n  Key_Space: 32,\r\n  Key_Any: 32,\r\n  Key_Exclam: 161,\r\n  Key_QuoteDbl: 162,\r\n  Key_NumberSign: 163,\r\n  Key_Dollar: 164,\r\n  Key_Percent: 165,\r\n  Key_Ampersant: 166,\r\n  Key_Apostrophe: 222,\r\n  Key_ParenLeft: 168,\r\n  Key_ParenRight: 169,\r\n  Key_Asterisk: 170,\r\n  Key_Plus: 171,\r\n  Key_Comma: 188,\r\n  Key_Minus: 173,\r\n  Key_Period: 190,\r\n  Key_Slash: 191,\r\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52,\r\n  Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\r\n  Key_Colon: 58,\r\n  Key_Semicolon: 59,\r\n  Key_Less: 60,\r\n  Key_Equal: 61,\r\n  Key_Greater: 62,\r\n  Key_Question: 63,\r\n  Key_At: 64,\r\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71,\r\n  Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78,\r\n  Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85,\r\n  Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\r\n  Key_BracketLeft: 219,\r\n  Key_Backslash: 220,\r\n  Key_BracketRight: 221,\r\n  Key_AsciiCircum: 160,\r\n  Key_Underscore: 167,\r\n  Key_QuoteLeft: 0,\r\n  Key_BraceLeft: 174,\r\n  Key_Bar: 172,\r\n  Key_BraceRight: 175,\r\n  Key_AsciiTilde: 176,\r\n  Key_Back: 0,\r\n  Key_Forward: 0,\r\n  Key_Stop: 0,\r\n  Key_VolumeDown: 182,\r\n  Key_VolumeUp: 183,\r\n  Key_VolumeMute: 181,\r\n  Key_multiply: 106,\r\n  Key_add: 107,\r\n  Key_substract: 109,\r\n  Key_divide: 111,\r\n  Key_News: 0,\r\n  Key_OfficeHome: 0,\r\n  Key_Option: 0,\r\n  Key_Paste: 0,\r\n  Key_Phone: 0,\r\n  Key_Calendar: 0,\r\n  Key_Reply: 0,\r\n  Key_Reload: 0,\r\n  Key_RotateWindows: 0,\r\n  Key_RotationPB: 0,\r\n  Key_RotationKB: 0,\r\n  Key_Save: 0,\r\n  Key_Send: 0,\r\n  Key_Spell: 0,\r\n  Key_SplitScreen: 0,\r\n  Key_Support: 0,\r\n  Key_TaskPane: 0,\r\n  Key_Terminal: 0,\r\n  Key_Tools: 0,\r\n  Key_Travel: 0,\r\n  Key_Video: 0,\r\n  Key_Word: 0,\r\n  Key_Xfer: 0,\r\n  Key_ZoomIn: 0,\r\n  Key_ZoomOut: 0,\r\n  Key_Away: 0,\r\n  Key_Messenger: 0,\r\n  Key_WebCam: 0,\r\n  Key_MailForward: 0,\r\n  Key_Pictures: 0,\r\n  Key_Music: 0,\r\n  Key_Battery: 0,\r\n  Key_Bluetooth: 0,\r\n  Key_WLAN: 0,\r\n  Key_UWB: 0,\r\n  Key_AudioForward: 0,\r\n  Key_AudioRepeat: 0,\r\n  Key_AudioRandomPlay: 0,\r\n  Key_Subtitle: 0,\r\n  Key_AudioCycleTrack: 0,\r\n  Key_Time: 0,\r\n  Key_Hibernate: 0,\r\n  Key_View: 0,\r\n  Key_TopMenu: 0,\r\n  Key_PowerDown: 0,\r\n  Key_Suspend: 0,\r\n  Key_ContrastAdjust: 0,\r\n  Key_MediaLast: 0,\r\n  Key_unknown: -1,\r\n  Key_Call: 0,\r\n  Key_Camera: 0,\r\n  Key_CameraFocus: 0,\r\n  Key_Context1: 0,\r\n  Key_Context2: 0,\r\n  Key_Context3: 0,\r\n  Key_Context4: 0,\r\n  Key_Flip: 0,\r\n  Key_Hangup: 0,\r\n  Key_No: 0,\r\n  Key_Select: 93,\r\n  Key_Yes: 0,\r\n  Key_ToggleCallHangup: 0,\r\n  Key_VoiceDial: 0,\r\n  Key_LastNumberRedial: 0,\r\n  Key_Execute: 43,\r\n  Key_Printer: 42,\r\n  Key_Play: 250,\r\n  Key_Sleep: 95,\r\n  Key_Zoom: 251,\r\n  Key_Cancel: 3,\r\n  // Align\r\n  AlignLeft: 0x0001,\r\n  AlignRight: 0x0002,\r\n  AlignHCenter: 0x0004,\r\n  AlignJustify: 0x0008,\r\n  AlignTop: 0x0020,\r\n  AlignBottom: 0x0040,\r\n  AlignVCenter: 0x0080,\r\n  AlignCenter: 0x0084,\r\n  AlignBaseline: 0x0100,\r\n  AlignAbsolute: 0x0010,\r\n  AlignLeading: 0x0001,\r\n  AlignTrailing: 0x0002,\r\n  AlignHorizontal_Mask: 0x001f,\r\n  AlignVertical_Mask: 0x01e0,\r\n  // Screen\r\n  PrimaryOrientation: 0,\r\n  PortraitOrientation: 1,\r\n  LandscapeOrientation: 2,\r\n  InvertedPortraitOrientation: 4,\r\n  InvertedLandscapeOrientation: 8,\r\n  // CursorShape\r\n  ArrowCursor: 0,\r\n  UpArrowCursor: 1,\r\n  CrossCursor: 2,\r\n  WaitCursor: 3,\r\n  IBeamCursor: 4,\r\n  SizeVerCursor: 5,\r\n  SizeHorCursor: 6,\r\n  SizeBDiagCursor: 7,\r\n  SizeFDiagCursor: 8,\r\n  SizeAllCursor: 9,\r\n  BlankCursor: 10,\r\n  SplitVCursor: 11,\r\n  SplitHCursor: 12,\r\n  PointingHandCursor: 13,\r\n  ForbiddenCursor: 14,\r\n  WhatsThisCursor: 15,\r\n  BusyCursor: 16,\r\n  OpenHandCursor: 17,\r\n  ClosedHandCursor: 18,\r\n  DragCopyCursor: 19,\r\n  DragMoveCursor: 20,\r\n  DragLinkCursor: 21,\r\n  LastCursor: 21, //DragLinkCursor,\r\n  BitmapCursor: 24,\r\n  CustomCursor: 25,\r\n  // ScrollBar Policy\r\n  ScrollBarAsNeeded: 0,\r\n  ScrollBarAlwaysOff: 1,\r\n  ScrollBarAlwaysOn: 2\r\n};\r\n\r\nQmlWeb.Qt = Qt;\r\n","class QMLBinding {\r\n/**\r\n * Create QML binding.\r\n * @param {Variant} val Sourcecode or function representing the binding\r\n * @param {Array} tree Parser tree of the binding\r\n * @return {Object} Object representing the binding\r\n */\r\n  constructor(val, tree) {\r\n    // this.isFunction states whether the binding is a simple js statement or a\r\n    // function containing a return statement. We decide this on whether it is a\r\n    // code block or not. If it is, we require a return statement. If it is a\r\n    // code block it could though also be a object definition, so we need to\r\n    // check that as well (it is, if the content is labels).\r\n    this.isFunction = tree && tree[0] === \"block\" &&\r\n                      tree[1][0] && tree[1][0][0] !== \"label\";\r\n    this.src = val;\r\n    this.compiled = false;\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      src: this.src,\r\n      deps: JSON.stringify(this.deps),\r\n      tree: JSON.stringify(this.tree)\r\n    };\r\n  }\r\n\r\n  eval(object, context, basePath) {\r\n    QmlWeb.executionContext = context;\r\n    if (basePath) {\r\n      QmlWeb.engine.$basePath = basePath;\r\n    }\r\n    // .call is needed for `this` support\r\n    return this.impl.call(object, object, context);\r\n  }\r\n\r\n/**\r\n * Compile binding. Afterwards you may call binding.eval to evaluate.\r\n */\r\n  compile() {\r\n    this.src = this.src.trim();\r\n    this.impl = QMLBinding.bindSrc(this.src, this.isFunction);\r\n    this.compiled = true;\r\n  }\r\n\r\n  static bindSrc(src, isFunction) {\r\n    return new Function(\"__executionObject\", \"__executionContext\", `\r\n      with(QmlWeb) with(__executionContext) with(__executionObject) {\r\n        ${isFunction ? \"\" : \"return\"} ${src}\r\n      }\r\n    `);\r\n  }\r\n}\r\n\r\nQmlWeb.QMLBinding = QMLBinding;\r\n","// There can only be one running QMLEngine.\r\n// This variable points to the currently running engine.\r\nQmlWeb.engine = null;\r\n\r\nQmlWeb.useShadowDom = true;\r\n\r\nconst geometryProperties = [\r\n  \"width\", \"height\", \"fill\", \"x\", \"y\", \"left\", \"right\", \"top\", \"bottom\"\r\n];\r\n\r\n// QML engine. EXPORTED.\r\nclass QMLEngine {\r\n  constructor(element) {\r\n    //----------Public Members----------\r\n\r\n    this.fps = 60;\r\n    // Math.floor, causes bugs to timing?\r\n    this.$interval = Math.floor(1000 / this.fps);\r\n    this.dom = element || document.body;\r\n\r\n    // Target for the DOM children\r\n    this.domTarget = this.dom;\r\n    if (QmlWeb.useShadowDom && this.dom.attachShadow) {\r\n      this.domTarget = this.dom.attachShadow({ mode: \"open\" });\r\n    }\r\n\r\n    // Cached component trees (post-QmlWeb.convertToEngine)\r\n    this.components = {};\r\n\r\n    // Cached parsed JS files (post-QmlWeb.jsparse)\r\n    this.js = {};\r\n\r\n    // List of Component.completed signals\r\n    this.completedSignals = [];\r\n\r\n    // Current operation state of the engine (Idle, init, etc.)\r\n    this.operationState = 1;\r\n\r\n    // List of properties whose values are bindings. For internal use only.\r\n    this.bindedProperties = [];\r\n\r\n    // List of operations to perform later after init. For internal use only.\r\n    this.pendingOperations = [];\r\n\r\n    // Root object of the engine\r\n    this.rootObject = null;\r\n\r\n    // Base path of qml engine (used for resource loading)\r\n    this.$basePath = \"\";\r\n\r\n    // Module import paths overrides\r\n    this.userAddedModulePaths = {};\r\n\r\n    // Stores data for setImportPathList(), importPathList(), and addImportPath\r\n    this.userAddedImportPaths = [];\r\n\r\n    //----------Private Members---------\r\n\r\n    // Ticker resource id and ticker callbacks\r\n    this._tickers = [];\r\n    this._lastTick = Date.now();\r\n\r\n    // Callbacks for stopping or starting the engine\r\n    this._whenStop = [];\r\n    this._whenStart = [];\r\n\r\n    // Keyboard management\r\n    this.$initKeyboard();\r\n\r\n    //----------Construct----------\r\n\r\n    // No QML stuff should stand out the root element\r\n    this.dom.style.overflow = \"hidden\";\r\n\r\n    // Needed to make absolute positioning work\r\n    if (!this.dom.style.position) {\r\n      const style = window.getComputedStyle(this.dom);\r\n      if (style.getPropertyValue(\"position\") === \"static\") {\r\n        this.dom.style.position = \"relative\";\r\n        this.dom.style.top = \"0\";\r\n        this.dom.style.left = \"0\";\r\n      }\r\n    }\r\n\r\n    window.addEventListener(\"resize\", () => this.updateGeometry());\r\n  }\r\n\r\n  //---------- Public Methods ----------\r\n\r\n  updateGeometry() {\r\n    // we have to call `this.implicitHeight =` and `this.implicitWidth =`\r\n    // each time the root element changes it's geometry\r\n    // to reposition child elements of qml scene\r\n    let width;\r\n    let height;\r\n    if (this.dom === document.body) {\r\n      width = window.innerWidth;\r\n      height = window.innerHeight;\r\n    } else {\r\n      const style = window.getComputedStyle(this.dom);\r\n      width = parseFloat(style.getPropertyValue(\"width\"), 10);\r\n      height = parseFloat(style.getPropertyValue(\"height\"), 10);\r\n    }\r\n    if (width) {\r\n      this.rootObject.width = width;\r\n    }\r\n    if (height) {\r\n      this.rootObject.height = height;\r\n    }\r\n  }\r\n\r\n  // Start the engine\r\n  start() {\r\n    QmlWeb.engine = this;\r\n    const QMLOperationState = QmlWeb.QMLOperationState;\r\n    if (this.operationState !== QMLOperationState.Running) {\r\n      this.operationState = QMLOperationState.Running;\r\n      this._tickerId = setInterval(this._tick.bind(this), this.$interval);\r\n      this._whenStart.forEach(callback => callback());\r\n    }\r\n  }\r\n\r\n  // Stop the engine\r\n  stop() {\r\n    const QMLOperationState = QmlWeb.QMLOperationState;\r\n    if (this.operationState === QMLOperationState.Running) {\r\n      clearInterval(this._tickerId);\r\n      this.operationState = QMLOperationState.Idle;\r\n      this._whenStop.forEach(callback => callback());\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line max-len\r\n  /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\r\n   *\r\n   * Removes dot segments in given path component, as described in\r\n   * RFC 3986, section 5.2.4.\r\n   *\r\n   * @param {string} path A non-empty path component.\r\n   * @return {string} Path component with removed dot segments.\r\n   */\r\n  removeDotSegments(path) {\r\n    // path.startsWith(\"/\") is not supported in some browsers\r\n    let leadingSlash = path && path[0] === \"/\";\r\n    const segments = path.split(\"/\");\r\n    const out = [];\r\n\r\n    for (let pos = 0; pos < segments.length;) {\r\n      const segment = segments[pos++];\r\n\r\n      if (segment === \".\") {\r\n        if (leadingSlash && pos === segments.length) {\r\n          out.push(\"\");\r\n        }\r\n      } else if (segment === \"..\") {\r\n        if (out.length > 1 || out.length === 1 && out[0] !== \"\") {\r\n          out.pop();\r\n        }\r\n        if (leadingSlash && pos === segments.length) {\r\n          out.push(\"\");\r\n        }\r\n      } else {\r\n        out.push(segment);\r\n        leadingSlash = true;\r\n      }\r\n    }\r\n\r\n    return out.join(\"/\");\r\n  }\r\n\r\n  extractBasePath(file) {\r\n    // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\r\n    const basePath = file.split(/[/\\\\]/);\r\n    basePath[basePath.length - 1] = \"\";\r\n    return basePath.join(\"/\");\r\n  }\r\n\r\n  extractFileName(file) {\r\n    return file.split(/[/\\\\]/).pop();\r\n  }\r\n\r\n  // Load file, parse and construct (.qml or .qml.js)\r\n  loadFile(file, parentComponent = null) {\r\n    // Create an anchor element to get the absolute path from the DOM\r\n    if (!this.$basePathA) {\r\n      this.$basePathA = document.createElement(\"a\");\r\n    }\r\n    this.$basePathA.href = this.extractBasePath(file);\r\n    this.$basePath = this.$basePathA.href;\r\n    const fileName = this.extractFileName(file);\r\n    const tree = this.loadComponent(this.$resolvePath(fileName));\r\n    return this.loadQMLTree(tree, parentComponent, file);\r\n  }\r\n\r\n  // parse and construct qml\r\n  // file is not required; only for debug purposes\r\n  // This function is only used by the QmlWeb tests\r\n  loadQML(src, parentComponent = null, file = undefined) {\r\n    return this.loadQMLTree(QmlWeb.parseQML(src, file), parentComponent, file);\r\n  }\r\n\r\n  loadQMLTree(tree, parentComponent = null, file = undefined) {\r\n    QmlWeb.engine = this;\r\n\r\n    // Create and initialize objects\r\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n    const component = new QMLComponent({\r\n      object: tree,\r\n      parent: parentComponent\r\n    });\r\n\r\n    this.loadImports(tree.$imports, undefined, component.importContextId);\r\n    component.$basePath = this.$basePath;\r\n    component.$imports = tree.$imports; // for later use\r\n    component.$file = file; // just for debugging\r\n\r\n    this.rootObject = component.$createObject(parentComponent);\r\n    if (this.rootObject.dom) {\r\n      this.domTarget.appendChild(this.rootObject.dom);\r\n    }\r\n    this.$initializePropertyBindings();\r\n\r\n    this.start();\r\n\r\n    this.updateGeometry();\r\n\r\n    this.callCompletedSignals();\r\n\r\n    return component;\r\n  }\r\n\r\n  rootContext() {\r\n    return this.rootObject.$context;\r\n  }\r\n\r\n  // next 3 methods used in Qt.createComponent for qml files lookup\r\n  // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\r\n\r\n  addImportPath(dirpath) {\r\n    this.userAddedImportPaths.push(dirpath);\r\n  }\r\n\r\n  /* Add this dirpath to be checked for components. This is the result of\r\n   * something like:\r\n   *\r\n   * import \"SomeDir/AnotherDirectory\"\r\n   *\r\n   * The importContextId ensures it is only accessible from the file in which\r\n   * it was imported. */\r\n  addComponentImportPath(importContextId, dirpath, qualifier) {\r\n    if (!this.componentImportPaths) {\r\n      this.componentImportPaths = {};\r\n    }\r\n    if (!this.componentImportPaths[importContextId]) {\r\n      this.componentImportPaths[importContextId] = {};\r\n    }\r\n\r\n    const paths = this.componentImportPaths[importContextId];\r\n\r\n    if (qualifier) {\r\n      if (!paths.qualified) {\r\n        paths.qualified = {};\r\n      }\r\n      paths.qualified[qualifier] = dirpath;\r\n    } else {\r\n      if (!paths.unqualified) {\r\n        paths.unqualified = [];\r\n      }\r\n      paths.unqualified.push(dirpath);\r\n    }\r\n  }\r\n\r\n  importSearchPaths(importContextId) {\r\n    if (!this.componentImportPaths) {\r\n      return [];\r\n    }\r\n    const paths = this.componentImportPaths[importContextId];\r\n    if (!paths) {\r\n      return [];\r\n    }\r\n    return paths.unqualified || [];\r\n  }\r\n\r\n  qualifiedImportPath(importContextId, qualifier) {\r\n    if (!this.componentImportPaths) {\r\n      return \"\";\r\n    }\r\n    const paths = this.componentImportPaths[importContextId];\r\n    if (!paths || !paths.qualified) {\r\n      return \"\";\r\n    }\r\n    return paths.qualified[qualifier] || \"\";\r\n  }\r\n\r\n  setImportPathList(arrayOfDirs) {\r\n    this.userAddedImportPaths = arrayOfDirs;\r\n  }\r\n\r\n  importPathList() {\r\n    return this.userAddedImportPaths;\r\n  }\r\n\r\n  // `addModulePath` defines conrete path for module lookup\r\n  // e.g. addModulePath(\"QtQuick.Controls\", \"http://example.com/controls\")\r\n  // will force system to `import QtQuick.Controls` module from\r\n  // `http://example.com/controls/qmldir`\r\n\r\n  addModulePath(moduleName, dirPath) {\r\n    // Keep the mapping. It will be used in loadImports() function.\r\n    // Remove trailing slash as it required for `readQmlDir`.\r\n    this.userAddedModulePaths[moduleName] = dirPath.replace(/\\/$/, \"\");\r\n  }\r\n\r\n  registerProperty(obj, propName) {\r\n    const dependantProperties = [];\r\n    let value = obj[propName];\r\n\r\n    const getter = () => {\r\n      const QMLProperty = QmlWeb.QMLProperty;\r\n      if (QMLProperty.evaluatingProperty &&\r\n          dependantProperties.indexOf(QMLProperty.evaluatingProperty) === -1) {\r\n        dependantProperties.push(QMLProperty.evaluatingProperty);\r\n      }\r\n      return value;\r\n    };\r\n\r\n    const setter = newVal => {\r\n      value = newVal;\r\n      for (const i in dependantProperties) {\r\n        dependantProperties[i].update();\r\n      }\r\n    };\r\n\r\n    QmlWeb.setupGetterSetter(obj, propName, getter, setter);\r\n  }\r\n\r\n  loadImports(importsArray, currentFileDir = this.$basePath,\r\n      importContextId = -1) {\r\n    if (!this.qmldirsContents) {\r\n      this.qmldirsContents = {}; // cache\r\n\r\n      // putting initial keys in qmldirsContents - is a hack. We should find a\r\n      // way to explain to qmlweb, is this built-in module or qmldir-style\r\n      // module.\r\n      for (const module in QmlWeb.modules) {\r\n        if (module !== \"Main\") {\r\n          this.qmldirsContents[module] = {};\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!this.qmldirs) {\r\n      this.qmldirs = {}; // resulting components lookup table\r\n    }\r\n\r\n    if (!importsArray || importsArray.length === 0) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < importsArray.length; i++) {\r\n      this.loadImport(importsArray[i], currentFileDir, importContextId);\r\n    }\r\n  }\r\n\r\n  loadImport(entry, currentFileDir, importContextId) {\r\n    let name = entry[1];\r\n\r\n    // is it url to remote resource\r\n    const nameIsUrl = name.indexOf(\"//\") === 0 || name.indexOf(\"://\") >= 0;\r\n    // is it a module name, e.g. QtQuick, QtQuick.Controls, etc\r\n    const nameIsQualifiedModuleName = entry[4];\r\n    // is it a js file\r\n    const nameIsJs = name.slice(-3) === \".js\";\r\n    // local [relative] dir\r\n    const nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl && !nameIsJs;\r\n\r\n    if (nameIsDir) {\r\n      name = this.$resolvePath(name, currentFileDir);\r\n      if (name[name.length - 1] === \"/\") {\r\n        // remove trailing slash as it required for `readQmlDir`\r\n        name = name.substr(0, name.length - 1);\r\n      }\r\n    }\r\n\r\n    let content = this.qmldirsContents[name];\r\n    // check if we have already loaded that qmldir file\r\n    if (!content) {\r\n      if (nameIsQualifiedModuleName && this.userAddedModulePaths[name]) {\r\n        // 1. we have qualified module and user had configured path for that\r\n        // module with this.addModulePath\r\n        content = QmlWeb.readQmlDir(this.userAddedModulePaths[name]);\r\n      } else if (nameIsUrl || nameIsDir) {\r\n        // 2. direct load\r\n        // nameIsUrl => url do not need dirs\r\n        // nameIsDir => already computed full path above\r\n        content = QmlWeb.readQmlDir(name);\r\n      } else if (nameIsJs) {\r\n        // 3. Js file, don't need qmldir\r\n      } else {\r\n        // 4. qt-style lookup for qualified module\r\n        const probableDirs = [currentFileDir].concat(this.importPathList());\r\n        const diredName = name.replace(/\\./g, \"/\");\r\n\r\n        for (let k = 0; k < probableDirs.length; k++) {\r\n          const file = probableDirs[k] + diredName;\r\n          content = QmlWeb.readQmlDir(file);\r\n          if (content) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      this.qmldirsContents[name] = content;\r\n    }\r\n\r\n    /* If there is no qmldir, add these directories to the list of places to\r\n      * search for components (within this import scope). \"noqmldir\" is\r\n      * inserted into the qmldir cache to avoid future attempts at fetching\r\n      * the qmldir file, but we always need to the call to\r\n      * \"addComponentImportPath\" for these sorts of directories. */\r\n    if (!content || content === \"noqmldir\") {\r\n      if (nameIsDir) {\r\n        if (entry[3]) {\r\n          /* Use entry[1] directly, as we don't want to include the\r\n            * basePath, otherwise it gets prepended twice in\r\n            * createComponent. */\r\n          this.addComponentImportPath(importContextId,\r\n            `${entry[1]}/`, entry[3]);\r\n        } else {\r\n          this.addComponentImportPath(importContextId, `${name}/`);\r\n        }\r\n      }\r\n\r\n      this.qmldirsContents[name] = \"noqmldir\";\r\n      return;\r\n    }\r\n\r\n    // copy founded externals to global var\r\n    // TODO actually we have to copy it to current component\r\n    for (const attrname in content.externals) {\r\n      this.qmldirs[attrname] = content.externals[attrname];\r\n    }\r\n\r\n    // keep already loaded qmldir files\r\n    this.qmldirsContents[name] = content;\r\n  }\r\n\r\n  size() {\r\n    return {\r\n      width: this.rootObject.getWidth(),\r\n      height: this.rootObject.getHeight()\r\n    };\r\n  }\r\n\r\n  focusedElement() {\r\n    return this.rootContext().activeFocus;\r\n  }\r\n\r\n  //---------- Private Methods ----------\r\n\r\n  $initKeyboard() {\r\n    document.onkeypress = e => {\r\n      let focusedElement = this.focusedElement();\r\n      const event = QmlWeb.eventToKeyboard(e || window.event);\r\n      const eventName = QmlWeb.keyboardSignals[event.key];\r\n\r\n      while (focusedElement && !event.accepted) {\r\n        const backup = focusedElement.$context.event;\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.pressed(event);\r\n        if (eventName) {\r\n          focusedElement.Keys[eventName](event);\r\n        }\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted) {\r\n          e.preventDefault();\r\n        } else {\r\n          focusedElement = focusedElement.$parent;\r\n        }\r\n      }\r\n    };\r\n\r\n    document.onkeyup = e => {\r\n      let focusedElement = this.focusedElement();\r\n      const event = QmlWeb.eventToKeyboard(e || window.event);\r\n\r\n      while (focusedElement && !event.accepted) {\r\n        const backup = focusedElement.$context.event;\r\n        focusedElement.$context.event = event;\r\n        focusedElement.Keys.released(event);\r\n        focusedElement.$context.event = backup;\r\n        if (event.accepted) {\r\n          e.preventDefault();\r\n        } else {\r\n          focusedElement = focusedElement.$parent;\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  _tick() {\r\n    const now = Date.now();\r\n    const elapsed = now - this._lastTick;\r\n    this._lastTick = now;\r\n    this._tickers.forEach(ticker => ticker(now, elapsed));\r\n  }\r\n\r\n  // Load resolved file, parse and construct as Component (.qml)\r\n  loadComponent(file) {\r\n    if (file in this.components) {\r\n      return this.components[file];\r\n    }\r\n\r\n    const uri = this.$parseURI(file);\r\n    if (!uri) {\r\n      return undefined;\r\n    }\r\n\r\n    let tree;\r\n    if (uri.scheme === \"qrc://\") {\r\n      tree = QmlWeb.qrc[uri.path];\r\n      if (!tree) {\r\n        return undefined;\r\n      }\r\n      // QmlWeb.qrc contains pre-parsed Component objects, but they still need\r\n      // convertToEngine called on them.\r\n      tree = QmlWeb.convertToEngine(tree);\r\n    } else {\r\n      const src = QmlWeb.getUrlContents(file, true);\r\n      if (!src) {\r\n        console.error(\"QMLEngine.loadComponent: Failed to load:\", file);\r\n        return undefined;\r\n      }\r\n\r\n      console.log(\"QMLEngine.loadComponent: Loading file:\", file);\r\n      tree = QmlWeb.parseQML(src, file);\r\n    }\r\n\r\n    if (!tree) {\r\n      return undefined;\r\n    }\r\n\r\n    if (tree.$children.length !== 1) {\r\n      console.error(\"QMLEngine.loadComponent: Failed to load:\", file,\r\n        \": A QML component must only contain one root element!\");\r\n      return undefined;\r\n    }\r\n\r\n    tree.$file = file;\r\n    this.components[file] = tree;\r\n    return tree;\r\n  }\r\n\r\n  // Load resolved file and parse as JavaScript\r\n  loadJS(file) {\r\n    if (file in this.js) {\r\n      return this.js[file];\r\n    }\r\n\r\n    const uri = this.$parseURI(file);\r\n    if (!uri) {\r\n      return undefined;\r\n    }\r\n\r\n    let jsData;\r\n    if (uri.scheme === \"qrc://\") {\r\n      jsData = QmlWeb.qrc[uri.path];\r\n    } else {\r\n      QmlWeb.loadParser();\r\n      jsData = QmlWeb.jsparse(QmlWeb.getUrlContents(file));\r\n    }\r\n\r\n    if (!jsData) {\r\n      return undefined;\r\n    }\r\n\r\n    // Remove any \".pragma\" statements, as they are not valid JavaScript\r\n    jsData.source = jsData.source.replace(/\\.pragma.*(?:\\r\\n|\\r|\\n)/, \"\\n\");\r\n\r\n    const contextSetter = new Function(\"$context\", `\r\n      with(QmlWeb) with ($context) {\r\n        ${jsData.source}\r\n      }\r\n      ${jsData.exports.map(sym => `$context.${sym} = ${sym};`).join(\"\")}\r\n    `);\r\n\r\n    this.js[file] = contextSetter;\r\n\r\n    return contextSetter;\r\n  }\r\n\r\n  $registerStart(f) {\r\n    this._whenStart.push(f);\r\n  }\r\n\r\n  $registerStop(f) {\r\n    this._whenStop.push(f);\r\n  }\r\n\r\n  $addTicker(t) {\r\n    this._tickers.push(t);\r\n  }\r\n\r\n  $removeTicker(t) {\r\n    const index = this._tickers.indexOf(t);\r\n    if (index !== -1) {\r\n      this._tickers.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  $initializePropertyBindings() {\r\n    // Initialize property bindings\r\n    // we use `while`, because $initializePropertyBindings may be called\r\n    // recursive (because of Loader and/or createQmlObject )\r\n    while (this.bindedProperties.length > 0) {\r\n      const property = this.bindedProperties.shift();\r\n\r\n      if (!property.binding) {\r\n        // Probably, the binding was overwritten by an explicit value. Ignore.\r\n        continue;\r\n      }\r\n\r\n      if (property.needsUpdate) {\r\n        property.update();\r\n      } else if (geometryProperties.indexOf(property.name) >= 0) {\r\n        // It is possible that bindings with these names was already evaluated\r\n        // during eval of other bindings but in that case $updateHGeometry and\r\n        // $updateVGeometry could be blocked during their eval.\r\n        // So we call them explicitly, just in case.\r\n        const { obj, changed } = property;\r\n        if (obj.$updateHGeometry &&\r\n            changed.isConnected(obj, obj.$updateHGeometry)) {\r\n          obj.$updateHGeometry(property.val, property.val, property.name);\r\n        }\r\n        if (obj.$updateVGeometry &&\r\n            changed.isConnected(obj, obj.$updateVGeometry)) {\r\n          obj.$updateVGeometry(property.val, property.val, property.name);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.$initializeAliasSignals();\r\n  }\r\n\r\n  // This parses the full URL into scheme, authority and path\r\n  $parseURI(uri) {\r\n    const match = uri.match(/^([^/]*?:\\/\\/)(.*?)(\\/.*)$/);\r\n    if (match) {\r\n      return {\r\n        scheme: match[1],\r\n        authority: match[2],\r\n        path: match[3]\r\n      };\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // Return a path to load the file\r\n  $resolvePath(file, basePath = this.$basePath) {\r\n    // probably, replace :// with :/ ?\r\n    if (!file || file.indexOf(\"://\") !== -1) {\r\n      return file;\r\n    }\r\n\r\n    const schemes = [\"data:\", \"blob:\", \"about:\"];\r\n    for (let i = 0; i < schemes.length; i++) {\r\n      if (file.lastIndexOf(schemes[i], 0) === 0) {\r\n        return file;\r\n      }\r\n    }\r\n\r\n    const basePathURI = this.$parseURI(basePath);\r\n    if (!basePathURI) {\r\n      return file;\r\n    }\r\n\r\n    let path = basePathURI.path;\r\n    if (file.indexOf(\"/\") === 0) {\r\n      path = file;\r\n    } else {\r\n      path = `${path}${file}`;\r\n    }\r\n\r\n    // Remove duplicate slashes and dot segments in the path\r\n    path = this.removeDotSegments(path.replace(/([^:]\\/)\\/+/g, \"$1\"));\r\n\r\n    return `${basePathURI.scheme}${basePathURI.authority}${path}`;\r\n  }\r\n\r\n  // Return a DOM-valid path to load the image (fileURL is an already-resolved\r\n  // URL)\r\n  $resolveImageURL(fileURL) {\r\n    const uri = this.$parseURI(fileURL);\r\n    // If we are within the resource system, look up a \"real\" path that can be\r\n    // used by the DOM. If not found, return the path itself without the\r\n    // \"qrc://\" scheme.\r\n    if (uri && uri.scheme === \"qrc://\") {\r\n      return QmlWeb.qrc[uri.path] || uri.path;\r\n    }\r\n\r\n    // Something we can't parse, just pass it through\r\n    return fileURL;\r\n  }\r\n\r\n  $initializeAliasSignals() {\r\n    // Perform pending operations. Now we use it only to init alias's \"changed\"\r\n    // handlers, that's why we have such strange function name.\r\n    while (this.pendingOperations.length > 0) {\r\n      const op = this.pendingOperations.shift();\r\n      op[0](op[1], op[2], op[3]);\r\n    }\r\n    this.pendingOperations = [];\r\n  }\r\n\r\n  callCompletedSignals() {\r\n    // the while loop is better than for..in loop, because completedSignals\r\n    // array might change dynamically when some completed signal handlers will\r\n    // create objects dynamically via createQmlObject or Loader\r\n    while (this.completedSignals.length > 0) {\r\n      const handler = this.completedSignals.shift();\r\n      handler();\r\n    }\r\n  }\r\n}\r\n\r\nQmlWeb.QMLEngine = QMLEngine;\r\n","const QMLOperationState = {\r\n  Idle: 1,\r\n  Init: 2,\r\n  Running: 3\r\n};\r\n\r\nQmlWeb.QMLOperationState = QMLOperationState;\r\n","class QMLProperty {\r\n  constructor(type, obj, name) {\r\n    this.obj = obj;\r\n    this.name = name;\r\n    this.changed = QmlWeb.Signal.signal([], { obj });\r\n    this.binding = null;\r\n    this.objectScope = null;\r\n    this.componentScope = null;\r\n    this.value = undefined;\r\n    this.type = type;\r\n    this.animation = null;\r\n    this.needsUpdate = true;\r\n\r\n    // This list contains all signals that hold references to this object.\r\n    // It is needed when deleting, as we need to tidy up all references to this\r\n    // object.\r\n    this.$tidyupList = [];\r\n  }\r\n\r\n  // Called by update and set to actually set this.val, performing any type\r\n  // conversion required.\r\n  $setVal(val, componentScope) {\r\n    const constructors = QmlWeb.constructors;\r\n    if (constructors[this.type] === QmlWeb.qmlList) {\r\n      this.val = QmlWeb.qmlList({\r\n        object: val,\r\n        parent: this.obj,\r\n        context: componentScope\r\n      });\r\n    } else if (val instanceof QmlWeb.QMLMetaElement) {\r\n      const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n      if (constructors[val.$class] === QMLComponent ||\r\n          constructors[this.type] === QMLComponent) {\r\n        this.val = new QMLComponent({\r\n          object: val,\r\n          parent: this.obj,\r\n          context: componentScope\r\n        });\r\n        /* $basePath must be set here so that Components that are assigned to\r\n         * properties (e.g. Repeater delegates) can properly resolve child\r\n         * Components that live in the same directory in\r\n         * Component.createObject. */\r\n        this.val.$basePath = componentScope.$basePath;\r\n      } else {\r\n        this.val = QmlWeb.construct({\r\n          object: val,\r\n          parent: this.obj,\r\n          context: componentScope\r\n        });\r\n      }\r\n    } else if (!constructors[this.type]) {\r\n      this.val = val;\r\n    } else if (constructors[this.type].requireParent) {\r\n      this.val = new constructors[this.type](this.obj, val);\r\n    } else if (val === undefined && constructors[this.type].nonNullableType) {\r\n      this.val = new constructors[this.type]();\r\n    } else if (constructors[this.type].requireConstructor) {\r\n      this.val = new constructors[this.type](val);\r\n    } else if (val instanceof Object || val === undefined || val === null) {\r\n      this.val = val;\r\n    } else if (constructors[this.type].plainType) {\r\n      this.val = constructors[this.type](val);\r\n    } else {\r\n      this.val = new constructors[this.type](val);\r\n    }\r\n    if (this.val && this.val.$changed) {\r\n      this.val.$changed.connect(() => {\r\n        const oldVal = this.val; // TODO\r\n        this.changed(this.val, oldVal, this.name);\r\n      });\r\n    } else if (this.val && this.val.$properties) {\r\n      Object.keys(this.val.$properties).forEach(pname => {\r\n        const prop = this.val.$properties[pname];\r\n        if (!prop || !prop.connect) return;\r\n        // TODO: oldVal\r\n        prop.connect(() => this.changed(this.val, this.val, this.name));\r\n      });\r\n    }\r\n  }\r\n\r\n  // Updater recalculates the value of a property if one of the dependencies\r\n  // changed\r\n  update() {\r\n    this.needsUpdate = false;\r\n\r\n    if (!this.binding) {\r\n      return;\r\n    }\r\n\r\n    const oldVal = this.val;\r\n\r\n    try {\r\n      QMLProperty.pushEvaluatingProperty(this);\r\n      if (!this.binding.compiled) {\r\n        this.binding.compile();\r\n      }\r\n      this.$setVal(this.binding.eval(this.objectScope, this.componentScope,\r\n        this.componentScopeBasePath), this.componentScope);\r\n    } catch (e) {\r\n      console.log(\"QMLProperty.update binding error:\",\r\n        e,\r\n        Function.prototype.toString.call(this.binding.eval)\r\n      );\r\n    } finally {\r\n      QMLProperty.popEvaluatingProperty();\r\n    }\r\n\r\n    if (this.animation) {\r\n      this.animation.$actions = [{\r\n        target: this.animation.target || this.obj,\r\n        property: this.animation.property || this.name,\r\n        from: this.animation.from || oldVal,\r\n        to: this.animation.to || this.val\r\n      }];\r\n      this.animation.restart();\r\n    }\r\n\r\n    if (this.val !== oldVal) {\r\n      this.changed(this.val, oldVal, this.name);\r\n    }\r\n  }\r\n\r\n  // Define getter\r\n  get() {\r\n    //if (this.needsUpdate && !QMLProperty.evaluatingPropertyPaused) {\r\n    if (this.needsUpdate &&\r\n        QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\r\n      this.update();\r\n    }\r\n\r\n    // If this call to the getter is due to a property that is dependant on this\r\n    // one, we need it to take track of changes\r\n    if (QMLProperty.evaluatingProperty) {\r\n      //console.log(this,QMLProperty.evaluatingPropertyStack.slice(0),this.val);\r\n      this.changed.connect(\r\n        QMLProperty.evaluatingProperty,\r\n        QMLProperty.prototype.update,\r\n        QmlWeb.Signal.UniqueConnection\r\n      );\r\n    }\r\n\r\n    return this.val;\r\n  }\r\n  // Define setter\r\n  set(newVal, reason, objectScope, componentScope) {\r\n    const oldVal = this.val;\r\n\r\n    let val = newVal;\r\n    if (val instanceof QmlWeb.QMLBinding) {\r\n      if (!objectScope || !componentScope) {\r\n        throw new Error(\"Internal error: binding assigned without scope\");\r\n      }\r\n      this.binding = val;\r\n      this.objectScope = objectScope;\r\n      this.componentScope = componentScope;\r\n      this.componentScopeBasePath = componentScope.$basePath;\r\n\r\n      if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\r\n        if (!val.compiled) {\r\n          val.compile();\r\n        }\r\n        try {\r\n          QMLProperty.pushEvaluatingProperty(this);\r\n          this.needsUpdate = false;\r\n          val = this.binding.eval(objectScope, componentScope,\r\n            this.componentScopeBasePath);\r\n        } finally {\r\n          QMLProperty.popEvaluatingProperty();\r\n        }\r\n      } else {\r\n        QmlWeb.engine.bindedProperties.push(this);\r\n        return;\r\n      }\r\n    } else {\r\n      if (reason !== QMLProperty.ReasonAnimation) {\r\n        this.binding = null;\r\n      }\r\n      if (val instanceof Array) {\r\n        val = val.slice(); // Copies the array\r\n      }\r\n    }\r\n\r\n    if (reason === QMLProperty.ReasonInit && typeof val === \"undefined\") {\r\n      if (QMLProperty.typeInitialValues.hasOwnProperty(this.type)) {\r\n        val = QMLProperty.typeInitialValues[this.type];\r\n      }\r\n    }\r\n\r\n    this.$setVal(val, componentScope);\r\n\r\n    if (this.val !== oldVal) {\r\n      if (this.animation && reason === QMLProperty.ReasonUser) {\r\n        this.animation.running = false;\r\n        this.animation.$actions = [{\r\n          target: this.animation.target || this.obj,\r\n          property: this.animation.property || this.name,\r\n          from: this.animation.from || oldVal,\r\n          to: this.animation.to || this.val\r\n        }];\r\n        this.animation.running = true;\r\n      }\r\n      if (this.obj.$syncPropertyToRemote instanceof Function &&\r\n          reason === QMLProperty.ReasonUser) {\r\n        // is a remote object from e.g. a QWebChannel\r\n        this.obj.$syncPropertyToRemote(this.name, val);\r\n      } else {\r\n        this.changed(this.val, oldVal, this.name);\r\n      }\r\n    }\r\n  }\r\n\r\n  static pushEvalStack() {\r\n    QMLProperty.evaluatingPropertyStackOfStacks.push(\r\n      QMLProperty.evaluatingPropertyStack\r\n    );\r\n    QMLProperty.evaluatingPropertyStack = [];\r\n    QMLProperty.evaluatingProperty = undefined;\r\n  //  console.log(\"evaluatingProperty=>undefined due to push stck \");\r\n  }\r\n\r\n  static popEvalStack() {\r\n    QMLProperty.evaluatingPropertyStack =\r\n      QMLProperty.evaluatingPropertyStackOfStacks.pop() || [];\r\n    QMLProperty.evaluatingProperty =\r\n      QMLProperty.evaluatingPropertyStack[\r\n        QMLProperty.evaluatingPropertyStack.length - 1\r\n      ];\r\n  }\r\n\r\n  static pushEvaluatingProperty(prop) {\r\n    // TODO say warnings if already on stack. This means binding loop.\r\n    // BTW actually we do not loop because needsUpdate flag is reset before\r\n    // entering update again.\r\n    if (QMLProperty.evaluatingPropertyStack.indexOf(prop) >= 0) {\r\n      console.error(\"Property binding loop detected for property\",\r\n        prop.name,\r\n        [prop].slice(0)\r\n      );\r\n    }\r\n    QMLProperty.evaluatingProperty = prop;\r\n    QMLProperty.evaluatingPropertyStack.push(prop); //keep stack of props\r\n  }\r\n\r\n  static popEvaluatingProperty() {\r\n    QMLProperty.evaluatingPropertyStack.pop();\r\n    QMLProperty.evaluatingProperty = QMLProperty.evaluatingPropertyStack[\r\n      QMLProperty.evaluatingPropertyStack.length - 1\r\n    ];\r\n  }\r\n}\r\n\r\n// Property that is currently beeing evaluated. Used to get the information\r\n// which property called the getter of a certain other property for\r\n// evaluation and is thus dependant on it.\r\nQMLProperty.evaluatingProperty = undefined;\r\nQMLProperty.evaluatingPropertyPaused = false;\r\nQMLProperty.evaluatingPropertyStack = [];\r\nQMLProperty.evaluatingPropertyStackOfStacks = [];\r\n\r\nQMLProperty.typeInitialValues = {\r\n  int: 0,\r\n  real: 0,\r\n  double: 0,\r\n  string: \"\",\r\n  bool: false,\r\n  list: [],\r\n  enum: 0,\r\n  url: \"\"\r\n};\r\n\r\nQMLProperty.ReasonUser = 0;\r\nQMLProperty.ReasonInit = 1;\r\nQMLProperty.ReasonAnimation = 2;\r\n\r\nQmlWeb.QMLProperty = QMLProperty;\r\n","window.addEventListener(\"load\", () => {\r\n  const metaTags = document.getElementsByTagName(\"body\");\r\n  for (let i = 0; i < metaTags.length; ++i) {\r\n    const metaTag = metaTags[i];\r\n    const source = metaTag.getAttribute(\"data-qml\");\r\n    if (source) {\r\n      QmlWeb.qmlEngine = new QmlWeb.QMLEngine();\r\n      QmlWeb.qmlEngine.loadFile(source);\r\n      QmlWeb.qmlEngine.start();\r\n      break;\r\n    }\r\n  }\r\n});\r\n","const Easing = {\r\n  Linear: 1,\r\n  InQuad: 2, OutQuad: 3, InOutQuad: 4, OutInQuad: 5,\r\n  InCubic: 6, OutCubic: 7, InOutCubic: 8, OutInCubic: 9,\r\n  InQuart: 10, OutQuart: 11, InOutQuart: 12, OutInQuart: 13,\r\n  InQuint: 14, OutQuint: 15, InOutQuint: 16, OutInQuint: 17,\r\n  InSine: 18, OutSine: 19, InOutSine: 20, OutInSine: 21,\r\n  InExpo: 22, OutExpo: 23, InOutExpo: 24, OutInExpo: 25,\r\n  InCirc: 26, OutCirc: 27, InOutCirc: 28, OutInCirc: 29,\r\n  InElastic: 30, OutElastic: 31, InOutElastic: 32, OutInElastic: 33,\r\n  InBack: 34, OutBack: 35, InOutBack: 36, OutInBack: 37,\r\n  InBounce: 38, OutBounce: 39, InOutBounce: 40, OutInBounce: 41\r\n};\r\n\r\n// eslint-disable-next-line complexity\r\nQmlWeb.$ease = (type, period, amplitude, overshoot, t) => {\r\n  switch (type) {\r\n    // Linear\r\n    case Easing.Linear:\r\n      return t;\r\n\r\n    // Quad\r\n    case Easing.InQuad:\r\n      return Math.pow(t, 2);\r\n    case Easing.OutQuad:\r\n      return -Math.pow(t - 1, 2) + 1;\r\n    case Easing.InOutQuad:\r\n      if (t < 0.5) {\r\n        return 2 * Math.pow(t, 2);\r\n      }\r\n      return -2 * Math.pow(t - 1, 2) + 1;\r\n    case Easing.OutInQuad:\r\n      if (t < 0.5) {\r\n        return -2 * Math.pow(t - 0.5, 2) + 0.5;\r\n      }\r\n      return 2 * Math.pow(t - 0.5, 2) + 0.5;\r\n\r\n    // Cubic\r\n    case Easing.InCubic:\r\n      return Math.pow(t, 3);\r\n    case Easing.OutCubic:\r\n      return Math.pow(t - 1, 3) + 1;\r\n    case Easing.InOutCubic:\r\n      if (t < 0.5) {\r\n        return 4 * Math.pow(t, 3);\r\n      }\r\n      return 4 * Math.pow(t - 1, 3) + 1;\r\n    case Easing.OutInCubic:\r\n      return 4 * Math.pow(t - 0.5, 3) + 0.5;\r\n\r\n    // Quart\r\n    case Easing.InQuart:\r\n      return Math.pow(t, 4);\r\n    case Easing.OutQuart:\r\n      return -Math.pow(t - 1, 4) + 1;\r\n    case Easing.InOutQuart:\r\n      if (t < 0.5) {\r\n        return 8 * Math.pow(t, 4);\r\n      }\r\n      return -8 * Math.pow(t - 1, 4) + 1;\r\n    case Easing.OutInQuart:\r\n      if (t < 0.5) {\r\n        return -8 * Math.pow(t - 0.5, 4) + 0.5;\r\n      }\r\n      return 8 * Math.pow(t - 0.5, 4) + 0.5;\r\n\r\n    // Quint\r\n    case Easing.InQuint:\r\n      return Math.pow(t, 5);\r\n    case Easing.OutQuint:\r\n      return Math.pow(t - 1, 5) + 1;\r\n    case Easing.InOutQuint:\r\n      if (t < 0.5) {\r\n        return 16 * Math.pow(t, 5);\r\n      }\r\n      return 16 * Math.pow(t - 1, 5) + 1;\r\n    case Easing.OutInQuint:\r\n      if (t < 0.5) {\r\n        return 16 * Math.pow(t - 0.5, 5) + 0.5;\r\n      }\r\n      return 16 * Math.pow(t - 0.5, 5) + 0.5;\r\n\r\n    // Sine\r\n    case Easing.InSine:\r\n      return -Math.cos(0.5 * Math.PI * t) + 1;\r\n    case Easing.OutSine:\r\n      return Math.sin(0.5 * Math.PI * t);\r\n    case Easing.InOutSine:\r\n      return -0.5 * Math.cos(Math.PI * t) + 0.5;\r\n    case Easing.OutInSine:\r\n      if (t < 0.5) {\r\n        return 0.5 * Math.sin(Math.PI * t);\r\n      }\r\n      return -0.5 * Math.sin(Math.PI * t) + 1;\r\n\r\n    // Expo\r\n    case Easing.InExpo:\r\n      return 1 / 1023 * (Math.pow(2, 10 * t) - 1);\r\n    case Easing.OutExpo:\r\n      return -1024 / 1023 * (Math.pow(2, -10 * t) - 1);\r\n    case Easing.InOutExpo:\r\n      if (t < 0.5) {\r\n        return 1 / 62 * (Math.pow(2, 10 * t) - 1);\r\n      }\r\n      return -512 / 31 * Math.pow(2, -10 * t) + 63 / 62;\r\n    case Easing.OutInExpo:\r\n      if (t < 0.5) {\r\n        return -16 / 31 * (Math.pow(2, -10 * t) - 1);\r\n      }\r\n      return 1 / 1984 * Math.pow(2, 10 * t) + 15 / 31;\r\n\r\n    // Circ\r\n    case Easing.InCirc:\r\n      return 1 - Math.sqrt(1 - t * t);\r\n    case Easing.OutCirc:\r\n      return Math.sqrt(1 - Math.pow(t - 1, 2));\r\n    case Easing.InOutCirc:\r\n      if (t < 0.5) {\r\n        return 0.5 * (1 - Math.sqrt(1 - 4 * t * t));\r\n      }\r\n      return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\r\n    case Easing.OutInCirc:\r\n      if (t < 0.5) {\r\n        return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\r\n      }\r\n      return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\r\n\r\n    // Elastic\r\n    case Easing.InElastic:\r\n      return -amplitude * Math.pow(2, 10 * t - 10) *\r\n        Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude));\r\n    case Easing.OutElastic:\r\n      return amplitude * Math.pow(2, -10 * t) *\r\n        Math.sin(2 * t * Math.PI / period - Math.asin(1 / amplitude)) + 1;\r\n    case Easing.InOutElastic:\r\n      if (t < 0.5) {\r\n        return -0.5 * amplitude * Math.pow(2, 20 * t - 10) *\r\n          Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude));\r\n      }\r\n      return -0.5 * amplitude * Math.pow(2, -20 * t + 10) *\r\n        Math.sin(4 * t * Math.PI / period + Math.asin(1 / amplitude)) + 1;\r\n    case Easing.OutInElastic:\r\n      if (t < 0.5) {\r\n        return 0.5 * amplitude * Math.pow(2, -20 * t) *\r\n          Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\r\n      }\r\n      return -0.5 * amplitude * Math.pow(2, 20 * t - 20) *\r\n        Math.sin(4 * t * Math.PI / period - Math.asin(1 / amplitude)) + 0.5;\r\n\r\n    // Back\r\n    case Easing.InBack:\r\n      return (overshoot + 1) * Math.pow(t, 3) - overshoot * Math.pow(t, 2);\r\n    case Easing.OutBack:\r\n      return (overshoot + 1) * Math.pow(t - 1, 3) +\r\n             overshoot * Math.pow(t - 1, 2) + 1;\r\n    case Easing.InOutBack:\r\n      if (t < 0.5) {\r\n        return 4 * (overshoot + 1) * Math.pow(t, 3) -\r\n               2 * overshoot * Math.pow(t, 2);\r\n      }\r\n      return 0.5 * (overshoot + 1) * Math.pow(2 * t - 2, 3) +\r\n             overshoot / 2 * Math.pow(2 * t - 2, 2) + 1;\r\n    case Easing.OutInBack:\r\n      if (t < 0.5) {\r\n        return 0.5 * ((overshoot + 1) * Math.pow(2 * t - 1, 3) +\r\n               overshoot * Math.pow(2 * t - 1, 2) + 1);\r\n      }\r\n      return 4 * (overshoot + 1) * Math.pow(t - 0.5, 3) -\r\n             2 * overshoot * Math.pow(t - 0.5, 2) + 0.5;\r\n    // Bounce\r\n    case Easing.InBounce:\r\n      if (t < 1 / 11) {\r\n        return -amplitude * 121 / 16 * (t * t - 1 / 11 * t);\r\n      } else if (t < 3 / 11) {\r\n        return -amplitude * 121 / 16 * (t * t - 4 / 11 * t + 3 / 121);\r\n      } else if (t < 7 / 11) {\r\n        return -amplitude * 121 / 16 * (t * t - 10 / 11 * t + 21 / 121);\r\n      }\r\n      return -(121 / 16) * (t * t - 2 * t + 1) + 1;\r\n    case Easing.OutBounce:\r\n      if (t < 4 / 11) {\r\n        return 121 / 16 * t * t;\r\n      } else if (t < 8 / 11) {\r\n        return amplitude * (121 / 16) * (t * t - 12 / 11 * t + 32 / 121) + 1;\r\n      } else if (t < 10 / 11) {\r\n        return amplitude * (121 / 16) * (t * t - 18 / 11 * t + 80 / 121) + 1;\r\n      }\r\n      return amplitude * (121 / 16) * (t * t - 21 / 11 * t + 10 / 11) + 1;\r\n    case Easing.InOutBounce:\r\n      if (t < 1 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 1 / 22 * t);\r\n      } else if (t < 3 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 2 / 11 * t + 3 / 484);\r\n      } else if (t < 7 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 5 / 11 * t + 21 / 484);\r\n      } else if (t < 11 / 22) {\r\n        return -121 / 8 * (t * t - t + 0.25) + 0.5;\r\n      } else if (t < 15 / 22) {\r\n        return 121 / 8 * (t * t - t) + 137 / 32;\r\n      } else if (t < 19 / 22) {\r\n        return amplitude * 121 / 8 * (t * t - 17 / 11 * t + 285 / 484) + 1;\r\n      } else if (t < 21 / 22) {\r\n        return amplitude * 121 / 8 * (t * t - 20 / 11 * t + 399 / 484) + 1;\r\n      }\r\n      return amplitude * 121 / 8 * (t * t - 43 / 22 * t + 21 / 22) + 1;\r\n    case Easing.OutInBounce:\r\n      if (t < 4 / 22) {\r\n        return 121 / 8 * t * t;\r\n      } else if (t < 8 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 6 / 11 * t + 8 / 121) + 0.5;\r\n      } else if (t < 10 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 9 / 11 * t + 20 / 121) + 0.5;\r\n      } else if (t < 11 / 22) {\r\n        return -amplitude * 121 / 8 * (t * t - 21 / 22 * t + 5 / 22) + 0.5;\r\n      } else if (t < 12 / 22) {\r\n        return amplitude * 121 / 8 * (t * t - 23 / 22 * t + 3 / 11) + 0.5;\r\n      } else if (t < 14 / 22) {\r\n        return amplitude * 121 / 8 * (t * t - 13 / 11 * t + 42 / 121) + 0.5;\r\n      } else if (t < 18 / 22) {\r\n        return amplitude * 121 / 8 * (t * t - 16 / 11 * t + 63 / 121) + 0.5;\r\n      }\r\n      return -121 / 8 * (t * t - 2 * t + 117 / 121) + 0.5;\r\n\r\n    // Default\r\n    default:\r\n      console.error(\"Unsupported animation type: \", type);\r\n      return t;\r\n  }\r\n};\r\n\r\nQmlWeb.Easing = Easing;\r\n","class QmlWebHelpers {\r\n  static arrayFindIndex(array, callback) {\r\n    // Note: does not support thisArg, we don't need that\r\n    if (!Array.prototype.findIndex) {\r\n      for (const key in array) {\r\n        if (callback(array[key], key, array)) {\r\n          return key;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n    return Array.prototype.findIndex.call(array, callback);\r\n  }\r\n  static mergeObjects(...args) {\r\n    const merged = {};\r\n    for (const i in args) {\r\n      const arg = args[i];\r\n      if (!arg) {\r\n        continue;\r\n      }\r\n      for (const key in arg) {\r\n        merged[key] = arg[key];\r\n      }\r\n    }\r\n    return merged;\r\n  }\r\n}\r\n\r\nQmlWeb.helpers = QmlWebHelpers;\r\n","QmlWeb.keyCodeToQt = e => {\r\n  const Qt = QmlWeb.Qt;\r\n  e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\r\n  if (e.keyCode === Qt.Key_Tab && e.shiftKey) {\r\n    return Qt.Key_Backtab;\r\n  }\r\n  if (e.keyCode >= 97 && e.keyCode <= 122) {\r\n    return e.keyCode - (97 - Qt.Key_A);\r\n  }\r\n  return e.keyCode;\r\n};\r\n\r\nQmlWeb.eventToKeyboard = e => ({\r\n  accepted: false,\r\n  count: 1,\r\n  isAutoRepeat: false,\r\n  key: QmlWeb.keyCodeToQt(e),\r\n  modifiers: e.ctrlKey * QmlWeb.Qt.CtrlModifier\r\n           | e.altKey * QmlWeb.Qt.AltModifier\r\n           | e.shiftKey * QmlWeb.Qt.ShiftModifier\r\n           | e.metaKey * QmlWeb.Qt.MetaModifier\r\n           | e.keypad * QmlWeb.Qt.KeypadModifier,\r\n  text: String.fromCharCode(e.charCode)\r\n});\r\n\r\nQmlWeb.keyboardSignals = {};\r\n[\r\n  \"asterisk\", \"back\", \"backtab\", \"call\", \"cancel\", \"delete\", \"escape\", \"flip\",\r\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"hangup\", \"menu\", \"no\", \"return\", \"select\",\r\n  \"space\", \"tab\", \"volumeDown\", \"volumeUp\", \"yes\", \"up\", \"right\", \"down\", \"left\"\r\n].forEach(key => {\r\n  const name = key.toString();\r\n  const qtName = `Key_${name[0].toUpperCase()}${name.slice(1)}`;\r\n  const prefix = typeof key === \"number\" ? \"digit\" : \"\";\r\n  QmlWeb.keyboardSignals[QmlWeb.Qt[qtName]] = `${prefix}${name}Pressed`;\r\n});\r\n","/*\r\n\r\nQmlWeb.qrc is analogous to the Qt Resource System. It is expected to map a path\r\nwithin the resource system to the following pieces of data:\r\n\r\n1) For a QML Component, it is the return value of QmlWeb.parse\r\n2) For a JavaScript file, it is the return value of QmlWeb.jsparse\r\n2) For an image, it is any URL that an <img> tag can accept (e.g. a standard\r\n   URL to an image resource, or a \"data:\" URI). If there is no entry for a\r\n   given qrc image path, it will fall back to passing the path right through to\r\n   the DOM. This is mainly a convenience until support for images is added to\r\n   gulp-qmlweb.\r\n\r\nThe \"data-qml\" tag on <body> can be set to a \"qrc://\" URL like\r\n\"qrc:///root.qml\" to use a pre-parsed \"/root.qml\" from QmlWeb.qrc.\r\n\r\nSince relative URLs are resolved relative to the URL of the containing\r\ncomponent, any relative URL set within a file in the resource system will also\r\nresolve within the resource system. To access a Component, JavaScript or image\r\nfile that is stored outside of the resources system from within the resource\r\nsystem, a full URL must be used (e.g. \"http://www.example.com/images/foo.png\").\r\n\r\nVice-versa, in order to access a Component, JavaScript or image file that is\r\nstored within the resource system from outside of the resource system, a full\r\n\"qrc://\" URL must be used (e.g. \"qrc:///images/foo.png\").\r\n\r\nMore details here: http://doc.qt.io/qt-5/qml-url.html\r\n\r\n*/\r\nQmlWeb.qrc = {};\r\n","QmlWeb.registerQmlType({\r\n  module: \"QmlWeb.Dom\",\r\n  name: \"DomElement\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    tagName: { type: \"string\", initialValue: \"div\" }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    meta.tagName = meta.object.tagName;\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: support properties, styles, perhaps changing the tagName\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QmlWeb\",\r\n  name: \"RestModel\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    url: \"string\",\r\n    isLoading: \"bool\",\r\n    mimeType: { type: \"string\", initialValue: \"application/json\" },\r\n    queryMimeType: {\r\n      type: \"string\",\r\n      initialValue: \"application/x-www-urlencoded\"\r\n    }\r\n  },\r\n  signals: {\r\n    fetched: [],\r\n    saved: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.attributes = this.getAttributes();\r\n    this.runningRequests = 0;\r\n  }\r\n  fetch() {\r\n    this.$ajax({\r\n      method: \"GET\",\r\n      mimeType: this.mimetype,\r\n      success: xhr => {\r\n        this.$xhrReadResponse(xhr);\r\n        this.fetched();\r\n      }\r\n    });\r\n  }\r\n  remove() {\r\n    this.$ajax({\r\n      method: \"DELETE\",\r\n      success: () => {\r\n        this.destroy();\r\n      }\r\n    });\r\n  }\r\n  create() {\r\n    this.$sendToServer(\"POST\");\r\n  }\r\n  save() {\r\n    this.$sendToServer(\"PUT\");\r\n  }\r\n  $sendToServer(method) {\r\n    this.$ajax({\r\n      method,\r\n      mimeType: this.queryMimeType,\r\n      body: this.$generateBodyForPostQuery(),\r\n      success: xhr => {\r\n        this.$xhrReadResponse(xhr);\r\n        this.saved();\r\n      }\r\n    });\r\n  }\r\n  $generateBodyForPostQuery() {\r\n    const object = {};\r\n    for (let i = 0; i < this.attributes.length; ++i) {\r\n      object[this.attributes[i]] = this.$properties[this.attributes[i]].get();\r\n    }\r\n    console.log(object);\r\n    switch (this.queryMimeType) {\r\n      case \"application/json\":\r\n      case \"text/json\":\r\n        return JSON.stringify(object);\r\n      case \"application/x-www-urlencoded\":\r\n        return this.$objectToUrlEncoded(object);\r\n    }\r\n    return undefined;\r\n  }\r\n  $objectToUrlEncoded(object, prefix) {\r\n    const parts = [];\r\n    for (let key in object) {\r\n      if (object.hasOwnProperty(key)) {\r\n        const value = object[key];\r\n        if (typeof prefix !== \"undefined\") {\r\n          key = `${prefix}[${key}]`;\r\n        }\r\n        if (typeof value === \"object\") {\r\n          parts.push(this.$objectToUrlEncoded(value, key));\r\n        } else {\r\n          const ekey = this.$myEncodeURIComponent(key);\r\n          const evalue = this.$myEncodeURIComponent(value);\r\n          parts.push(`${ekey}=${evalue}`);\r\n        }\r\n      }\r\n    }\r\n    return parts.join(\"&\");\r\n  }\r\n  $myEncodeURIComponent(str) {\r\n    return encodeURIComponent(str).replace(/[!'()*]/g, c =>\r\n      `%${c.charCodeAt(0).toString(16)}`\r\n    );\r\n  }\r\n  $ajax(options) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.overrideMimeType(this.mimeType);\r\n    xhr.onreadystatechange = () => {\r\n      if (xhr.readyState === XMLHttpRequest.DONE) {\r\n        if (xhr.status === 200) {\r\n          options.success(xhr);\r\n        } else {\r\n          options.failure(xhr);\r\n        }\r\n        this.runningRequests -= 1;\r\n        if (this.runningRequests <= 0) {\r\n          this.isLoading = false;\r\n        }\r\n      }\r\n    };\r\n    xhr.open(options.method, this.url, true);\r\n    if (typeof options.body !== \"undefined\") {\r\n      xhr.setRequestHeader(\"Content-Type\", this.queryMimeType);\r\n      xhr.send(options.body);\r\n    } else {\r\n      xhr.send(null);\r\n    }\r\n    this.runningRequests += 1;\r\n    this.isLoading = true;\r\n  }\r\n  $xhrReadResponse(xhr) {\r\n    let responseObject;\r\n    if (this.mimeType === \"application/json\" || this.mimeType === \"text/json\") {\r\n      responseObject = JSON.parse(xhr.responseText);\r\n    }\r\n    this.$updatePropertiesFromResponseObject(responseObject);\r\n  }\r\n  $updatePropertiesFromResponseObject(responseObject) {\r\n    const QMLProperty = QmlWeb.QMLProperty;\r\n    for (const key in responseObject) {\r\n      if (responseObject.hasOwnProperty(key) && this.$hasProperty(key)) {\r\n        this.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\r\n      }\r\n    }\r\n  }\r\n  $hasProperty(name) {\r\n    return typeof this.$properties[name] !== \"undefined\";\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"Qt.labs.settings\",\r\n  name: \"Settings\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    category: \"string\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    if (typeof window.localStorage === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n  }\r\n  Component$onCompleted() {\r\n    this.$loadProperties();\r\n    this.$initializeProperties();\r\n  }\r\n  $getKey(attrName) {\r\n    return `${this.category}/${attrName}`;\r\n  }\r\n  $loadProperties() {\r\n    this.$attributes.forEach(attrName => {\r\n      if (!this.$properties[attrName]) return;\r\n\r\n      const key = this.$getKey(attrName);\r\n      this[attrName] = localStorage.getItem(key);\r\n    });\r\n  }\r\n  $initializeProperties() {\r\n    this.$attributes.forEach(attrName => {\r\n      if (!this.$properties[attrName]) return;\r\n\r\n      let emitter = this;\r\n      let signalName = `${attrName}Changed`;\r\n\r\n      if (this.$properties[attrName].type === \"alias\") {\r\n        emitter = this.$context[this.$properties[attrName].val.objectName];\r\n        signalName = `${this.$properties[attrName].val.propertyName}Changed`;\r\n      }\r\n\r\n      emitter[signalName].connect(this, () => {\r\n        localStorage.setItem(this.$getKey(attrName), this[attrName]);\r\n      });\r\n    });\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtBluetooth\",\r\n  name: \"BluetoothDiscoveryModel\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    BluetoothDiscoveryModel: {\r\n      FullServiceDiscovery: 1, MinimalServiceDiscovery: 0, DeviceDiscovery: 2,\r\n      NoError: 0, InputOutputError: 1, PoweredOffError: 2,\r\n      InvalidBluetoothAdapterError: 4, UnknownError: 3\r\n    }\r\n  },\r\n  properties: {\r\n    discoveryMode: { type: \"enum\", initialValue: 3 }, // MinimalServiceDiscovery\r\n    error: { type: \"enum\", initialValue: 0 }, // NoError\r\n    remoteAddress: \"string\",\r\n    running: \"bool\",\r\n    uuidFilter: \"string\",\r\n    url: \"url\"\r\n  },\r\n  signals: {\r\n    deviceDiscovered: [{ type: \"string\", name: \"device\" }],\r\n    serviceDiscovered: [{ type: \"string\", name: \"device\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: implementation based on navigator.bluetooth\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtGraphicalEffects\",\r\n  name: \"FastBlur\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    radius: \"real\",\r\n    source: { type: \"var\", initialValue: null }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$previousSource = null;\r\n    this.$filterObject = undefined;\r\n\r\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n  }\r\n  $onRadiusChanged() {\r\n    this.$updateEffect(this.source);\r\n  }\r\n  $onSourceChanged() {\r\n    this.$updateEffect(this.source);\r\n  }\r\n  $updateFilterObject() {\r\n    this.$filterObject = {\r\n      transformType: \"filter\",\r\n      operation: \"blur\",\r\n      parameters: `${this.radius}px`\r\n    };\r\n  }\r\n  $updateEffect(source) {\r\n    console.log(\"updating effect\");\r\n    if (this.$previousSource) {\r\n      const index = this.$previousSource.transform.indexOf(this.$filterObject);\r\n      this.$previousSource.transform.splice(index, 1);\r\n      this.$previousSource.$updateTransform();\r\n    }\r\n    if (source && source.transform) {\r\n      this.$updateFilterObject();\r\n      console.log(\"updating effect:\", this.$filterObject, source);\r\n      source.transform.push(this.$filterObject);\r\n      source.$updateTransform();\r\n      this.$previousSource = source;\r\n    } else {\r\n      this.$previousSource = null;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtGraphicalEffects\",\r\n  name: \"RectangularGlow\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    cached: \"bool\",\r\n    color: { type: \"color\", initialValue: \"white\" },\r\n    cornerRadius: \"real\",\r\n    glowRadius: \"real\",\r\n    spread: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.impl = document.createElement(\"div\");\r\n    const style = this.impl.style;\r\n    style.pointerEvents = \"none\";\r\n    style.position = \"absolute\";\r\n    style.left = style.right = style.top = style.bottom = \"0px\";\r\n    style.border = \"none\";\r\n    style.backgroundColor = this.color.$css;\r\n    this.dom.appendChild(this.impl);\r\n\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n    this.glowRadiusChanged.connect(this, this.$updateBoxShadow);\r\n    this.cornerRadiusChanged.connect(this, this.$updateBoxShadow);\r\n    this.widthChanged.connect(this, this.$updateBoxShadow);\r\n    this.heightChanged.connect(this, this.$updateBoxShadow);\r\n    this.spreadChanged.connect(this, this.$onSpreadChanged);\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.impl.style.backgroundColor = newVal.$css;\r\n    this.$updateBoxShadow();\r\n  }\r\n  $onSpreadChanged(newVal) {\r\n    if (newVal > 1) {\r\n      this.spread = 1;\r\n    } else if (newVal < 0) {\r\n      this.spread = 0;\r\n    }\r\n    this.$updateBoxShadow();\r\n  }\r\n  $updateBoxShadow() {\r\n    const { color, glowRadius, cornerRadius, spread, width, height } = this;\r\n    const style = this.impl.style;\r\n\r\n    // Calculate boxShadow\r\n    const totle = glowRadius + cornerRadius * (1 - spread);\r\n    const glow = (1 - spread) * totle;\r\n    const blur_radius = glow * 0.64;\r\n    const spread_radius = totle - blur_radius;\r\n    const glow2 = glowRadius / 5;\r\n    const blur_radius_2 = glow2 * 0.8;\r\n    const spread_radius_2 = glow2 - blur_radius_2;\r\n\r\n    style.boxShadow = `${color} 0px 0px ${blur_radius}px ${spread_radius}px,` +\r\n      `${color} 0px 0px ${blur_radius_2}px ${spread_radius_2}px`;\r\n\r\n    // Calculate glow css\r\n    const spread_cornerR = cornerRadius * (1 - spread);\r\n    const rest_cornerR = cornerRadius - spread_cornerR;\r\n    const xScale = (width - spread_cornerR / 4) / width;\r\n    const yScale = (height - spread_cornerR / 4) / height;\r\n\r\n    style.width = `${width - spread_cornerR}px`;\r\n    style.height = `${height - spread_cornerR}px`;\r\n    style.top = `${spread_cornerR / 2}px`;\r\n    style.left = `${spread_cornerR / 2}px`;\r\n    style.filter = `blur(${spread_cornerR / 2}px)`;\r\n    style.borderRadius = `${rest_cornerR / 2}px`;\r\n    style.transform = `scale(${xScale},${yScale})`;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMobility\",\r\n  name: \"GeoLocation\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    accuracy: \"double\",\r\n    altitude: \"double\",\r\n    altitudeAccuracy: \"double\",\r\n    heading: \"double\",\r\n    latitude: \"double\",\r\n    longitude: \"double\",\r\n    speed: \"double\",\r\n    timestamp: \"date\",\r\n    label: \"string\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    if (!navigator.geolocation) {\r\n      return;\r\n    }\r\n\r\n    navigator.geolocation.getCurrentPosition(pos => this.$updatePosition(pos));\r\n    navigator.geolocation.watchPosition(pos => this.$updatePosition(pos));\r\n  }\r\n  $updatePosition(position) {\r\n    this.accuracy = position.coords.accuracy;\r\n    this.altitude = position.coords.altitude;\r\n    this.altitudeAccuracy = position.coords.altitudeAccuracy;\r\n    this.heading = position.coords.heading;\r\n    this.latitude = position.coords.latitude;\r\n    this.longitude = position.coords.longitude;\r\n    this.speed = position.coords.speed;\r\n    this.timestamp = position.timestamp;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMultimedia\",\r\n  name: \"Audio\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    Audio: {\r\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\r\n\r\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\r\n      AccessDenied: 8, ServiceMissing: 16,\r\n\r\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\r\n\r\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\r\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\r\n    }\r\n  },\r\n  properties: {\r\n    audioRole: \"enum\", // TODO\r\n    autoLoad: { type: \"bool\", initialValue: true },\r\n    autoPlay: \"bool\",\r\n    availability: \"enum\", // Audio.Available\r\n    duration: \"int\",\r\n    error: \"enum\", // Audio.NoError\r\n    errorString: \"string\",\r\n    hasAudio: \"bool\",\r\n    hasVideo: \"bool\",\r\n    loops: { type: \"int\", initialValue: 1 },\r\n    mediaObject: \"var\",\r\n    // TODO: metaData\r\n    muted: \"bool\",\r\n    playbackRate: { type: \"real\", initialValue: 1 },\r\n    playbackState: \"enum\", // Audio.StoppedState\r\n    playlinst: \"Playlist\",\r\n    position: \"int\",\r\n    seekable: \"bool\",\r\n    source: \"url\",\r\n    status: \"enum\", // Audio.NoMedia\r\n    volume: { type: \"real\", initialValue: 1 }\r\n  },\r\n  signals: {\r\n    error: [\r\n      { type: \"enum\", name: \"error\" },\r\n      { type: \"string\", name: \"errorString\" }\r\n    ],\r\n    paused: [],\r\n    playing: [],\r\n    stopped: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n  pause() {\r\n    // TODO\r\n  }\r\n  play() {\r\n    // TODO\r\n  }\r\n  seek(/* offset */) {\r\n    // TODO\r\n  }\r\n  stop() {\r\n    // TODO\r\n  }\r\n  supportedAudioRoles() {\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMultimedia\",\r\n  name: \"Camera\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    Camera: {\r\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\r\n\r\n      UnloadedState: 0, LoadedState: 1, ActiveState: 2\r\n    }\r\n  },\r\n  properties: {\r\n    availability: \"enum\", // Camera.Available\r\n    cameraState: { type: \"enum\", initialValue: 2 }, // Camera.ActiveState\r\n    cameraStatus: \"enum\", // TODO\r\n    captureMode: \"enum\", // TODO\r\n    deviceId: \"string\",\r\n    digitalZoom: { type: \"real\", initialValue: 1 },\r\n    displayName: \"string\",\r\n    errorCode: \"enum\", // TODO\r\n    errorString: \"string\",\r\n    lockStatus: \"enum\", // TODO\r\n    maximumDigitalZoom: \"real\",\r\n    maximumOpticalZoom: \"real\",\r\n    opticalZoom: { type: \"real\", initialValue: 1 },\r\n    orientation: \"int\",\r\n    position: \"enum\", // TODO\r\n  },\r\n  signals: {\r\n    error: [\r\n      { type: \"enum\", name: \"errorCode\" },\r\n      { type: \"string\", name: \"errorString\" }\r\n    ]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: impl\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMultimedia\",\r\n  name: \"MediaPlayer\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    MediaPlayer: {\r\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\r\n\r\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\r\n      AccessDenied: 8, ServiceMissing: 16,\r\n\r\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\r\n\r\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\r\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\r\n    }\r\n  },\r\n  properties: {\r\n    audioRole: \"enum\", // TODO\r\n    autoLoad: { type: \"bool\", initialValue: true },\r\n    autoPlay: \"bool\",\r\n    availability: \"enum\", // MediaPlayer.Available\r\n    bufferProgress: \"real\",\r\n    duration: \"int\",\r\n    error: \"enum\", // MediaPlayer.NoError\r\n    errorString: \"string\",\r\n    hasAudio: \"bool\",\r\n    hasVideo: \"bool\",\r\n    loops: \"int\",\r\n    muted: \"bool\",\r\n    playbackRate: { type: \"real\", initialValue: 1 },\r\n    playbackState: \"enum\", // MediaPlayer.StoppedState\r\n    position: \"int\",\r\n    seekable: \"bool\",\r\n    source: \"url\",\r\n    status: \"enum\", // MediaPlayer.NoMedia\r\n    volume: \"real\"\r\n  },\r\n  signals: {\r\n    error: [\r\n      { type: \"enum\", name: \"error\" },\r\n      { type: \"string\", name: \"errorString\" }\r\n    ],\r\n    paused: [],\r\n    playing: [],\r\n    stopped: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: impl\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMultimedia\",\r\n  name: \"Video\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  enums: {\r\n    MediaPlayer: {\r\n      Available: 0, Busy: 2, Unavailable: 1, ResourceMissing: 3,\r\n\r\n      NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4,\r\n      AccessDenied: 8, ServiceMissing: 16,\r\n\r\n      StoppedState: 0, PlayingState: 1, PausedState: 2,\r\n\r\n      NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8,\r\n      EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\r\n    },\r\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\r\n  },\r\n  properties: {\r\n    audioRole: \"enum\", // TODO\r\n    autoLoad: { type: \"bool\", initialValue: true },\r\n    autoPlay: \"bool\",\r\n    availability: \"enum\", // MediaPlayer.Available\r\n    bufferProgress: \"real\",\r\n    duration: \"int\",\r\n    error: \"enum\", // MediaPlayer.NoError\r\n    errorString: \"string\",\r\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\r\n    hasAudio: \"bool\",\r\n    hasVideo: \"bool\",\r\n    muted: \"bool\",\r\n    orientation: \"int\",\r\n    playbackRate: { type: \"real\", initialValue: 1 },\r\n    playbackState: \"enum\", // MediaPlayer.StoppedState\r\n    position: \"int\",\r\n    seekable: \"bool\",\r\n    source: \"url\",\r\n    status: \"enum\", // MediaPlayer.NoMedia\r\n    volume: \"real\"\r\n  },\r\n  signals: {\r\n    paused: [],\r\n    playing: [],\r\n    stopped: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$runningEventListener = 0;\r\n\r\n    this.impl = document.createElement(\"video\");\r\n    this.impl.style.width = this.impl.style.height = \"100%\";\r\n    this.impl.style.margin = \"0\";\r\n    this.dom.appendChild(this.impl);\r\n\r\n    this.volume = this.impl.volume;\r\n    this.duration = this.impl.duration;\r\n\r\n    this.impl.addEventListener(\"play\", () => {\r\n      this.playing();\r\n      this.playbackState = this.MediaPlayer.PlayingState;\r\n    });\r\n\r\n    this.impl.addEventListener(\"pause\", () => {\r\n      this.paused();\r\n      this.playbackState = this.MediaPlayer.PausedState;\r\n    });\r\n\r\n    this.impl.addEventListener(\"timeupdate\", () => {\r\n      this.$runningEventListener++;\r\n      this.position = this.impl.currentTime * 1000;\r\n      this.$runningEventListener--;\r\n    });\r\n\r\n    this.impl.addEventListener(\"ended\", () => {\r\n      this.stopped();\r\n      this.playbackState = this.MediaPlayer.StoppedState;\r\n    });\r\n\r\n    this.impl.addEventListener(\"progress\", () => {\r\n      if (this.impl.buffered.length > 0) {\r\n        this.progress = this.impl.buffered.end(0) / this.impl.duration;\r\n        this.status = this.progress < 1 ?\r\n          this.MediaPlayer.Buffering :\r\n          this.MediaPlayer.Buffered;\r\n      }\r\n    });\r\n\r\n    this.impl.addEventListener(\"stalled\", () => {\r\n      this.status = this.MediaPlayer.Stalled;\r\n    });\r\n\r\n    this.impl.addEventListener(\"canplaythrough\", () => {\r\n      this.status = this.MediaPlayer.Buffered;\r\n    });\r\n\r\n    this.impl.addEventListener(\"loadstart\", () => {\r\n      this.status = this.MediaPlayer.Loading;\r\n    });\r\n\r\n    this.impl.addEventListener(\"durationchanged\", () => {\r\n      this.duration = this.impl.duration;\r\n    });\r\n\r\n    this.impl.addEventListener(\"volumechanged\", () => {\r\n      this.$runningEventListener++;\r\n      this.volume = this.impl.volume;\r\n      this.$runningEventListener--;\r\n    });\r\n\r\n    this.impl.addEventListener(\"suspend\", () => {\r\n      this.error |= this.MediaPlayer.NetworkError;\r\n    });\r\n\r\n    this.impl.addEventListener(\"error\", () => {\r\n      this.error |= this.MediaPlayer.ResourceError;\r\n    });\r\n\r\n    this.impl.addEventListener(\"ratechange\", () => {\r\n      this.$runningEventListener++;\r\n      this.playbackRate = this.impl.playbackRate;\r\n      this.$runningEventListener--;\r\n    });\r\n\r\n    this.autoPlayChanged.connect(this, this.$onAutoPlayChanged);\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n    this.positionChanged.connect(this, this.$onPositionChanged);\r\n    this.volumeChanged.connect(this, this.$onVolumeChanged);\r\n    this.playbackRateChanged.connect(this, this.$onPlaybackRateChanged);\r\n    this.mutedChanged.connect(this, this.$onMutedChanged);\r\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\r\n  }\r\n  $onAutoPlayChanged(newVal) {\r\n    this.impl.autoplay = newVal;\r\n  }\r\n  $onSourceChanged(source) {\r\n    const parts = source.split(\".\");\r\n    const extension = parts[parts.length - 1].toLowerCase();\r\n    const mime = this.mimetypeFromExtension(extension);\r\n    this.impl.src = source;\r\n    if (!this.impl.canPlayType(mime)) {\r\n      this.error |= this.MediaPlayer.FormatError;\r\n    }\r\n  }\r\n  $onPositionChanged(currentTime) {\r\n    if (this.$runningEventListener > 0) return;\r\n    this.impl.currentTime = currentTime / 1000;\r\n  }\r\n  $onVolumeChanged(volume) {\r\n    if (this.$runningEventListener > 0) return;\r\n    this.impl.volume = volume;\r\n  }\r\n  $onPlaybackRateChanged(playbackRate) {\r\n    if (this.$runningEventListener > 0) return;\r\n    this.impl.playbackRate = playbackRate;\r\n  }\r\n  $onMutedChanged(newValue) {\r\n    if (newValue) {\r\n      this.$volulmeBackup = this.impl.volume;\r\n      this.volume = 0;\r\n    } else {\r\n      this.volume = this.$volumeBackup;\r\n    }\r\n  }\r\n  $onFillModeChanged(newValue) {\r\n    switch (newValue) {\r\n      case this.VideoOutput.Stretch:\r\n        this.impl.style.objectFit = \"fill\";\r\n        break;\r\n      case this.VideoOutput.PreserveAspectFit:\r\n        this.impl.style.objectFit = \"\";\r\n        break;\r\n      case this.VideoOutput.PreserveAspectCrop:\r\n        this.impl.style.objectFit = \"cover\";\r\n        break;\r\n    }\r\n  }\r\n  pause() {\r\n    this.impl.pause();\r\n  }\r\n  play() {\r\n    this.impl.play();\r\n  }\r\n  seek(offset) {\r\n    this.impl.currentTime = offset * 1000;\r\n  }\r\n  stop() {\r\n  }\r\n  mimetypeFromExtension(extension) {\r\n    const mimetypes = {\r\n      ogg: \"video/ogg\",\r\n      ogv: \"video/ogg\",\r\n      ogm: \"video/ogg\",\r\n      mp4: \"video/mp4\",\r\n      webm: \"video/webm\"\r\n    };\r\n    return mimetypes[extension] || \"\";\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtMultimedia\",\r\n  name: \"VideoOutput\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  enums: {\r\n    VideoOutput: { PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2 }\r\n  },\r\n  properties: {\r\n    autoOrientation: \"bool\",\r\n    contentRect: \"rect\",\r\n    fillMode: \"enum\", // VideoOutput.PreserveAspectFit\r\n    filters: \"list\",\r\n    orientation: \"int\",\r\n    source: \"variant\",\r\n    sourceRect: \"rect\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: impl\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtNfc\",\r\n  name: \"NearField\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    filter: \"list\",\r\n    messageRecords: \"list\",\r\n    orderMatch: \"bool\",\r\n    polling: \"bool\"\r\n  },\r\n  signals: {\r\n    tagFound: [],\r\n    tagRemoved: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: implementation based on Web NFC API\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQml.Modules\",\r\n  name: \"ListElement\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.ListElement\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQml.Modules\",\r\n  name: \"ListModel\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.ListModel\",\r\n  defaultProperty: \"$items\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQml\",\r\n  name: \"Binding\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    target: { type: \"QtObject\", initialValue: null },\r\n    property: { type: \"string\", initialValue: \"\" },\r\n    value: { type: \"var\", initialValue: undefined },\r\n    when: { type: \"bool\", initialValue: true }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$property = undefined;\r\n\r\n    this.valueChanged.connect(this, this.$onValueChanged);\r\n    this.targetChanged.connect(this, this.$updateBinding);\r\n    this.propertyChanged.connect(this, this.$updateBinding);\r\n    this.whenChanged.connect(this, this.$updateBinding);\r\n  }\r\n\r\n  $updateBinding() {\r\n    if (!this.when || !this.target\r\n        || !this.target.hasOwnProperty(this.property)\r\n        || this.value === undefined) {\r\n      this.$property = undefined;\r\n      return;\r\n    }\r\n    this.$property = this.target.$properties[this.property];\r\n    this.$onValueChanged(this.value); // trigger value update\r\n  }\r\n\r\n  $onValueChanged(value) {\r\n    if (value !== undefined && this.$property) {\r\n      this.$property.set(value);\r\n    }\r\n  }\r\n});\r\n","class QMLContext {\r\n  nameForObject(obj) {\r\n    for (const name in this) {\r\n      if (this[name] === obj) {\r\n        return name;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\nclass QMLComponent {\r\n  constructor(meta) {\r\n    if (QmlWeb.constructors[meta.object.$class] === QMLComponent) {\r\n      this.$metaObject = meta.object.$children[0];\r\n    } else {\r\n      this.$metaObject = meta.object;\r\n    }\r\n    this.$context = meta.context;\r\n\r\n    this.$jsImports = [];\r\n\r\n    if (meta.object.$imports instanceof Array) {\r\n      const moduleImports = [];\r\n      const loadImport = importDesc => {\r\n        if (/\\.js$/.test(importDesc[1])) {\r\n          this.$jsImports.push(importDesc);\r\n        } else {\r\n          moduleImports.push(importDesc);\r\n        }\r\n      };\r\n\r\n      for (let i = 0; i < meta.object.$imports.length; ++i) {\r\n        loadImport(meta.object.$imports[i]);\r\n      }\r\n      QmlWeb.loadImports(this, moduleImports);\r\n    }\r\n\r\n    /* If this Component does not have any imports, it is likely one that was\r\n     * created within another Component file. It should inherit the\r\n     * importContextId of the Component file it was created within. */\r\n    if (this.importContextId === undefined) {\r\n      this.importContextId = meta.context.importContextId;\r\n    }\r\n  }\r\n  finalizeImports($context) {\r\n    const engine = QmlWeb.engine;\r\n    for (let i = 0; i < this.$jsImports.length; ++i) {\r\n      const importDesc = this.$jsImports[i];\r\n      const js = engine.loadJS(engine.$resolvePath(importDesc[1]));\r\n\r\n      if (!js) {\r\n        console.log(\"Component.finalizeImports: failed to import JavaScript\",\r\n          importDesc[1]);\r\n        continue;\r\n      }\r\n\r\n      if (importDesc[3] !== \"\") {\r\n        $context[importDesc[3]] = {};\r\n        QmlWeb.importJavascriptInContext(js, $context[importDesc[3]]);\r\n      } else {\r\n        QmlWeb.importJavascriptInContext(js, $context);\r\n      }\r\n    }\r\n  }\r\n  $createObject(parent, properties = {}, context = this.$context) {\r\n    const engine = QmlWeb.engine;\r\n    const oldState = engine.operationState;\r\n    engine.operationState = QmlWeb.QMLOperationState.Init;\r\n    // change base path to current component base path\r\n    const bp = engine.$basePath;\r\n    engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\r\n\r\n    const newContext = context ? Object.create(context) : new QMLContext();\r\n\r\n    if (this.importContextId !== undefined) {\r\n      newContext.importContextId = this.importContextId;\r\n    }\r\n\r\n    const item = QmlWeb.construct({\r\n      object: this.$metaObject,\r\n      parent,\r\n      context: newContext,\r\n      isComponentRoot: true\r\n    });\r\n\r\n    this.finalizeImports(item.$context);\r\n\r\n    Object.keys(properties).forEach(propname => {\r\n      item[propname] = properties.propname;\r\n    });\r\n\r\n    // change base path back\r\n    // TODO looks a bit hacky\r\n    engine.$basePath = bp;\r\n\r\n    engine.operationState = oldState;\r\n    return item;\r\n  }\r\n  createObject(parent, properties = {}) {\r\n    const item = this.$createObject(parent, properties);\r\n    const QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\r\n\r\n    if (item instanceof QMLItem) {\r\n      item.$properties.parent.set(parent, QmlWeb.QMLProperty.ReasonInit);\r\n    }\r\n\r\n    return item;\r\n  }\r\n  static getAttachedObject() {\r\n    // see QMLEngine.js for explanation how it is used.\r\n    if (!this.$Component) {\r\n      this.$Component = new QmlWeb.QObject(this);\r\n      this.$Component.completed = QmlWeb.Signal.signal([]);\r\n      QmlWeb.engine.completedSignals.push(this.$Component.completed);\r\n\r\n      this.$Component.destruction = QmlWeb.Signal.signal([]);\r\n    }\r\n    return this.$Component;\r\n  }\r\n}\r\n\r\nQmlWeb.registerQmlType({\r\n  global: true,\r\n  module: \"QtQml\",\r\n  name: \"Component\",\r\n  versions: /.*/,\r\n  baseClass: \"QtObject\",\r\n  constructor: QMLComponent\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQml\",\r\n  name: \"Connections\",\r\n  versions: /.*/,\r\n  baseClass: \"QtObject\",\r\n  properties: {\r\n    target: \"QtObject\",\r\n    ignoreUnknownSignals: \"bool\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    this.target = this.$parent;\r\n    this.$connections = {};\r\n\r\n    this.$old_target = this.target;\r\n    this.targetChanged.connect(this, this.$onTargetChanged);\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n  }\r\n  $onTargetChanged() {\r\n    this.$reconnectTarget();\r\n  }\r\n  Component$onCompleted() {\r\n    this.$reconnectTarget();\r\n  }\r\n  $reconnectTarget() {\r\n    const old_target = this.$old_target;\r\n    for (const i in this.$connections) {\r\n      const c = this.$connections[i];\r\n      if (c._currentConnection && old_target && old_target[i] &&\r\n          typeof old_target[i].disconnect === \"function\") {\r\n        old_target[i].disconnect(c._currentConnection);\r\n      }\r\n      if (this.target) {\r\n        c._currentConnection = QmlWeb.connectSignal(this.target, i, c.value,\r\n          c.objectScope, c.componentScope);\r\n      }\r\n    }\r\n    this.$old_target = this.target;\r\n  }\r\n  $setCustomSlot(propName, value, objectScope, componentScope) {\r\n    this.$connections[propName] = { value, objectScope, componentScope };\r\n  }\r\n});\r\n","// Base object for all qml elements\r\n\r\nQmlWeb.registerQmlType({\r\n  module: \"QtQml\",\r\n  name: \"QtObject\",\r\n  versions: /.*/,\r\n}, class extends QmlWeb.QObject {\r\n  constructor(meta) {\r\n    super(meta.parent);\r\n\r\n    this.$isComponentRoot = meta.isComponentRoot;\r\n    this.$context = meta.context;\r\n\r\n    // Component get own properties\r\n    this.$attributes = [];\r\n    for (const key in meta.object) {\r\n      if (!meta.object.hasOwnProperty(key) || !meta.object[key]) {\r\n        continue;\r\n      }\r\n      const name = meta.object[key].__proto__.constructor.name;\r\n      if (name === \"QMLPropertyDefinition\" || name === \"QMLAliasDefinition\") {\r\n        this.$attributes.push(key);\r\n      }\r\n    }\r\n\r\n    const Signal = QmlWeb.Signal;\r\n\r\n    this.Keys = new QmlWeb.QObject(this);\r\n    this.Keys.asteriskPresed = Signal.signal();\r\n    this.Keys.backPressed = Signal.signal();\r\n    this.Keys.backtabPressed = Signal.signal();\r\n    this.Keys.callPressed = Signal.signal();\r\n    this.Keys.cancelPressed = Signal.signal();\r\n    this.Keys.deletePressed = Signal.signal();\r\n    for (let i = 0; i < 10; ++i) {\r\n      this.Keys[`digit${i}Pressed`] = Signal.signal();\r\n    }\r\n    this.Keys.escapePressed = Signal.signal();\r\n    this.Keys.flipPressed = Signal.signal();\r\n    this.Keys.hangupPressed = Signal.signal();\r\n    this.Keys.leftPressed = Signal.signal();\r\n    this.Keys.menuPressed = Signal.signal();\r\n    this.Keys.noPressed = Signal.signal();\r\n    this.Keys.pressed = Signal.signal();\r\n    this.Keys.released = Signal.signal();\r\n    this.Keys.returnPressed = Signal.signal();\r\n    this.Keys.rightPressed = Signal.signal();\r\n    this.Keys.selectPressed = Signal.signal();\r\n    this.Keys.spacePressed = Signal.signal();\r\n    this.Keys.tabPressed = Signal.signal();\r\n    this.Keys.upPressed = Signal.signal();\r\n    this.Keys.volumeDownPressed = Signal.signal();\r\n    this.Keys.volumeUpPressed = Signal.signal();\r\n    this.Keys.yesPressed = Signal.signal();\r\n  }\r\n  getAttributes() {\r\n    return this.$attributes;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQml\",\r\n  name: \"Timer\",\r\n  versions: /.*/,\r\n  baseClass: \"QtObject\",\r\n  properties: {\r\n    interval: { type: \"int\", initialValue: 1000 },\r\n    parent: { type: \"QtObject\", readOnly: true },\r\n    repeat: \"bool\",\r\n    running: \"bool\",\r\n    triggeredOnStart: \"bool\"\r\n  },\r\n  signals: {\r\n    triggered: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$properties.parent.set(this.$parent, QmlWeb.QMLProperty.ReasonInit);\r\n\r\n    /* This ensures that if the user toggles the \"running\" property manually,\r\n     * the timer will trigger. */\r\n    this.runningChanged.connect(this, this.$onRunningChanged);\r\n\r\n    QmlWeb.engine.$addTicker((...args) => this.$ticker(...args));\r\n\r\n    QmlWeb.engine.$registerStart(() => {\r\n      if (this.running) {\r\n        this.restart();\r\n      }\r\n    });\r\n\r\n    QmlWeb.engine.$registerStop(() => this.stop());\r\n  }\r\n  start() {\r\n    this.running = true;\r\n  }\r\n  stop() {\r\n    this.running = false;\r\n  }\r\n  restart() {\r\n    this.stop();\r\n    this.start();\r\n  }\r\n  $ticker(now) {\r\n    if (!this.running) return;\r\n    if (now - this.$prevTrigger >= this.interval) {\r\n      this.$prevTrigger = now;\r\n      this.$trigger();\r\n    }\r\n  }\r\n  $onRunningChanged() {\r\n    if (this.running) {\r\n      this.$prevTrigger = Date.now();\r\n      if (this.triggeredOnStart) {\r\n        this.$trigger();\r\n      }\r\n    }\r\n  }\r\n  $trigger() {\r\n    if (!this.repeat) {\r\n      // We set the value directly in order to be able to emit the\r\n      // runningChanged signal after triggered, like Qt does it.\r\n      this.$properties.running.val = false;\r\n    }\r\n\r\n    // Trigger this.\r\n    this.triggered();\r\n\r\n    if (!this.repeat) {\r\n      // Emit changed signal manually after setting the value manually above.\r\n      this.runningChanged();\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"ApplicationWindow\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.Window.Window\",\r\n  properties: {\r\n    font: \"font\",\r\n    activeFocusControl: \"Control\",\r\n    background: \"Item\",\r\n    contentData: \"list\",\r\n    //contentItem: \"ContentItem\", // TODO\r\n    footer: \"Item\",\r\n    header: \"Item\",\r\n    overlay: \"Item\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"ApplicationWindow\",\r\n  versions: /^1\\./,\r\n  baseClass: \"QtQuick.Window.Window\",\r\n  properties: {\r\n    //contentItem: \"ContentItem\", // TODO\r\n    menuBar: \"MenuBar\",\r\n    statusBar: \"Item\",\r\n    style: \"Component\",\r\n    toolBar: \"Item\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"Button\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    text: \"string\",\r\n    enabled: { type: \"bool\", initialValue: true }\r\n  },\r\n  signals: {\r\n    clicked: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\r\n\r\n    const button = this.impl = document.createElement(\"button\");\r\n    button.style.pointerEvents = \"auto\";\r\n    this.dom.appendChild(button);\r\n\r\n    button.onclick = () => {\r\n      this.clicked();\r\n    };\r\n  }\r\n  Component$onCompleted() {\r\n    this.implicitWidth = this.impl.offsetWidth;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n  }\r\n  $onTextChanged(newVal) {\r\n    this.impl.textContent = newVal;\r\n    //TODO: Replace those statically sized borders\r\n    this.implicitWidth = this.impl.offsetWidth;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n  }\r\n  $onEnabledChanged(newVal) {\r\n    this.impl.disabled = !newVal;\r\n  }\r\n\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"CheckBox\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    text: \"string\",\r\n    font: \"font\",\r\n    checked: \"bool\",\r\n    color: \"color\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.impl = document.createElement(\"label\");\r\n    this.impl.style.pointerEvents = \"auto\";\r\n\r\n    const checkbox = document.createElement(\"input\");\r\n    checkbox.type = \"checkbox\";\r\n    checkbox.style.verticalAlign = \"text-bottom\";\r\n    checkbox.addEventListener(\"change\", () => {\r\n      this.checked = checkbox.checked;\r\n    });\r\n    this.impl.appendChild(checkbox);\r\n\r\n    const span = document.createElement(\"span\");\r\n    this.impl.appendChild(span);\r\n\r\n    this.dom.appendChild(this.impl);\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n    this.checkedChanged.connect(this, this.$onCheckedChanged);\r\n  }\r\n  $onTextChanged(newVal) {\r\n    this.impl.children[1].innerHTML = newVal;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n    this.implicitWidth = this.impl.offsetWidth > 0 ?\r\n                          this.impl.offsetWidth + 4 :\r\n                          0;\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.impl.children[1].style.color = newVal.$css;\r\n  }\r\n  $onCheckedChanged() {\r\n    this.impl.children[0].checked = this.checked;\r\n  }\r\n  Component$onCompleted() {\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n    this.implicitWidth = this.impl.offsetWidth > 0 ?\r\n                          this.impl.offsetWidth + 4 :\r\n                          0;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"ComboBox\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    count: \"int\",\r\n    currentIndex: \"int\",\r\n    currentText: \"string\",\r\n    menu: { type: \"array\", initialValue: [] },\r\n    model: { type: \"array\", initialValue: [] },\r\n    pressed: \"bool\"\r\n  },\r\n  signals: {\r\n    accepted: [],\r\n    activated: [{ type: \"int\", name: \"index\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.dom.style.pointerEvents = \"auto\";\r\n    this.name = \"QMLComboBox\";\r\n\r\n    // TODO change innerHTML to DOM\r\n    this.dom.innerHTML = \"<select></select>\";\r\n    this.impl = this.dom.firstChild;\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.modelChanged.connect(this, this.$onModelChanged);\r\n    this.currentIndexChanged.connect(this, this.$onCurrentIndexChanged);\r\n    this.heightChanged.connect(this, this.$onHeightChanged);\r\n    this.widthChanged.connect(this, this.$onWidthChanged);\r\n\r\n    this.dom.onclick = () => {\r\n      const index = this.dom.firstChild.selectedIndex;\r\n      this.currentIndex = index;\r\n      this.currentText = this.model[index];\r\n      this.accepted();\r\n      this.activated(index);\r\n    };\r\n  }\r\n  find(text) {\r\n    return this.model.indexOf(text);\r\n  }\r\n  selectAll() {\r\n    // TODO\r\n  }\r\n  textAt(index) {\r\n    return this.model[index];\r\n  }\r\n  $updateImpl() {\r\n    this.count = this.model.length;\r\n\r\n    const k = this.count; const m = this.model;\r\n\r\n    this.impl.options.length = k;\r\n    for (let i = 0; i < k; i++) {\r\n      this.impl.options[i] = new Option(m[i]);\r\n    }\r\n\r\n    // should call this, because width()/heights() invoke updateV(H)Geometry,\r\n    // which in turn sets valid $useImplicitHeight flag\r\n    const h = this.height; const w = this.width;\r\n\r\n    this.implicitWidth = this.impl.offsetWidth;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n\r\n    this.$onHeightChanged(h);\r\n    this.$onWidthChanged(w);\r\n\r\n    this.impl.selectedIndex = this.currentIndex;\r\n    this.$updateCurrentText();\r\n  }\r\n  Component$onCompleted() {\r\n    this.$updateImpl();\r\n  }\r\n  $onModelChanged() {\r\n    this.$updateImpl();\r\n  }\r\n  $onCurrentIndexChanged() {\r\n    const i = this.currentIndex;\r\n    if (this.impl.selectedIndex !== i) {\r\n      this.impl.selectedIndex = i;\r\n      this.$updateCurrentText();\r\n      this.activated(i);\r\n    }\r\n  }\r\n  $updateCurrentText() {\r\n    if (typeof this.currentIndex === \"undefined\" || !this.model) {\r\n      this.currentText = undefined;\r\n    } else if (this.currentIndex >= 0 &&\r\n              this.currentIndex < this.model.length) {\r\n      this.currentText = this.model[ this.currentIndex ];\r\n    }\r\n  }\r\n  $onHeightChanged() {\r\n    if (this.height > 0 && this.impl\r\n     && this.height !== this.impl.offsetHeight) {\r\n      this.impl.style.height = `${this.height}px`;\r\n    }\r\n  }\r\n  $onWidthChanged() {\r\n    if (this.width > 0 && this.impl && this.width !== this.impl.offsetWidth) {\r\n      this.impl.style.width = `${this.width}px`;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"ScrollView\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    contentItem: \"Item\",\r\n    flickableItem: \"Item\", // TODO  0) implement it  1) make it read-only\r\n    viewport: \"Item\", // TODO\r\n    frameVisible: \"bool\",\r\n    highlightOnFocus: \"bool\", // TODO test\r\n    verticalScrollBarPolicy: \"enum\",\r\n    horizontalScrollBarPolicy: \"enum\",\r\n    style: \"Component\" // TODO\r\n  },\r\n  defaultProperty: \"contentItem\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.css.pointerEvents = \"auto\";\r\n    this.setupFocusOnDom(this.dom);\r\n\r\n    this.contentItemChanged.connect(this, this.$onContentItemChanged);\r\n    this.flickableItemChanged.connect(this, this.$onFlickableItemChanged);\r\n    this.viewportChanged.connect(this, this.$onViewportChanged);\r\n    this.frameVisibleChanged.connect(this, this.$onFrameVisibleChanged);\r\n    this.highlightOnFocusChanged.connect(this, this.$onHighlightOnFocusChanged);\r\n    this.horizontalScrollBarPolicyChanged.connect(this,\r\n                                      this.$onHorizontalScrollBarPolicyChanged);\r\n    this.verticalScrollBarPolicyChanged.connect(this,\r\n                                        this.$onVerticalScrollBarPolicyChanged);\r\n    this.styleChanged.connect(this, this.$onStyleChanged);\r\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\r\n    this.focusChanged.connect(this, this.$onFocusChanged);\r\n\r\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\r\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\r\n    this.width = this.implicitWidth;\r\n    this.height = this.implicitHeight;\r\n\r\n    const Qt = QmlWeb.Qt;\r\n    this.contentItem = undefined;\r\n    this.flickableItem = undefined;\r\n    this.viewport = undefined;\r\n    this.frameVisible = false;\r\n    this.highlightOnFocus = false;\r\n\r\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\r\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\r\n    this.style = undefined;\r\n\r\n    this.$onVerticalScrollBarPolicyChanged(this.verticalScrollBarPolicy);\r\n    this.$onHorizontalScrollBarPolicyChanged(this.horizontalScrollBarPolicy);\r\n  }\r\n  $onContentItemChanged(newItem) {\r\n    if (typeof newItem !== undefined) {\r\n      newItem.parent = this;\r\n    }\r\n  }\r\n  $onFlickableItemChanged() {\r\n  }\r\n  $onHighlightOnFocusChanged() {\r\n  }\r\n  $onViewportChanged() {\r\n  }\r\n  $onFocusChanged(focus) {\r\n    this.css.outline = this.highlight && focus\r\n      ? \"outline: lightblue solid 2px;\"\r\n      : \"\";\r\n  }\r\n  $onFrameVisibleChanged(visible) {\r\n    this.css.border = visible ? \"1px solid gray\" : \"hidden\";\r\n  }\r\n  $onHorizontalScrollBarPolicyChanged(newPolicy) {\r\n    this.css.overflowX = this.$scrollBarPolicyToCssOverflow(newPolicy);\r\n  }\r\n  $onVerticalScrollBarPolicyChanged(newPolicy) {\r\n    this.css.overflowY = this.$scrollBarPolicyToCssOverflow(newPolicy);\r\n  }\r\n  $onStyleChanged() {\r\n  }\r\n  $onChildrenChanged() {\r\n    if (typeof this.contentItem === \"undefined\" && this.children.length === 1) {\r\n      this.contentItem = this.children[0];\r\n    }\r\n  }\r\n  $scrollBarPolicyToCssOverflow(policy) {\r\n    const Qt = QmlWeb.Qt;\r\n    switch (policy) {\r\n      case Qt.ScrollBarAsNeeded:\r\n        return \"auto\";\r\n      case Qt.ScrollBarAlwaysOff:\r\n        return \"hidden\";\r\n      case Qt.ScrollBarAlwaysOn:\r\n        return \"scroll\";\r\n    }\r\n    return \"auto\";\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"TextArea\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.TextEdit\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    const textarea = this.impl;\r\n    textarea.style.padding = \"5px\";\r\n    textarea.style.borderWidth = \"1px\";\r\n    textarea.style.backgroundColor = \"#fff\";\r\n  }\r\n});\r\n","/**\r\n *\r\n * TextField is used to accept a line of text input.\r\n * Input constraints can be placed on a TextField item\r\n * (for example, through a validator or inputMask).\r\n * Setting echoMode to an appropriate value enables TextField\r\n * to be used for a password input field.\r\n *\r\n * Valid entries for echoMode and alignment are defined in TextInput.\r\n *\r\n */\r\n\r\nQmlWeb.registerQmlType({\r\n  module: \"QtQuick.Controls\",\r\n  name: \"TextField\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQuick.Item\",\r\n  enums: {\r\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\r\n  },\r\n  properties: {\r\n    text: \"string\",\r\n    font: \"font\",\r\n    maximumLength: { type: \"int\", initialValue: -1 },\r\n    readOnly: \"bool\",\r\n    validator: \"var\",\r\n    echoMode: \"enum\" // TextInput.Normal\r\n  },\r\n  signals: {\r\n    accepted: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    const input = this.impl = document.createElement(\"input\");\r\n    input.type = \"text\";\r\n    input.disabled = true;\r\n    input.style.pointerEvents = \"auto\";\r\n    input.style.margin = \"0\";\r\n    input.style.width = \"100%\";\r\n    this.dom.appendChild(input);\r\n    this.setupFocusOnDom(input);\r\n    input.disabled = false;\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\r\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\r\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\r\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\r\n\r\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\r\n  }\r\n  Component$onCompleted() {\r\n    this.implicitWidth = this.impl.offsetWidth;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n  }\r\n  $onTextChanged(newVal) {\r\n    // See TextInput for comments\r\n    if (this.impl.value !== newVal) {\r\n      this.impl.value = newVal;\r\n    }\r\n  }\r\n  $onEchoModeChanged(newVal) {\r\n    const TextInput = this.TextInput;\r\n    const input = this.impl;\r\n    switch (newVal) {\r\n      case TextInput.Normal:\r\n        input.type = \"text\";\r\n        break;\r\n      case TextInput.Password:\r\n        input.type = \"password\";\r\n        break;\r\n      case TextInput.NoEcho:\r\n        // Not supported, use password, that's nearest\r\n        input.type = \"password\";\r\n        break;\r\n      case TextInput.PasswordEchoOnEdit:\r\n        // Not supported, use password, that's nearest\r\n        input.type = \"password\";\r\n        break;\r\n    }\r\n  }\r\n  $onMaximumLengthChanged(newVal) {\r\n    this.impl.maxLength = newVal < 0 ? null : newVal;\r\n  }\r\n  $onReadOnlyChanged(newVal) {\r\n    this.impl.disabled = newVal;\r\n  }\r\n  Keys$onPressed(e) {\r\n    const Qt = QmlWeb.Qt;\r\n    const submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\r\n    if (submit && this.$testValidator()) {\r\n      this.accepted();\r\n      e.accepted = true;\r\n    }\r\n  }\r\n  $testValidator() {\r\n    if (this.validator) {\r\n      return this.validator.validate(this.text);\r\n    }\r\n    return true;\r\n  }\r\n  $updateValue() {\r\n    if (this.text !== this.impl.value) {\r\n      this.$canEditReadOnlyProperties = true;\r\n      this.text = this.impl.value;\r\n      this.$canEditReadOnlyProperties = false;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"AngleDirection\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Direction\",\r\n  properties: {\r\n    angle: \"real\",\r\n    angleVariation: \"real\",\r\n    magnitude: \"real\",\r\n    magnitudeVariation: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"CustomParticle\",\r\n  versions: /^2\\./,\r\n  baseClass: \"ParticlePainter\",\r\n  properties: {\r\n    fragmentShader: \"string\",\r\n    vertexShader: \"string\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"Direction\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQml.QtObject\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"Emitter\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    acceleration: \"StochasticDirection\",\r\n    emitRate: { type: \"real\", initialValue: 10 },\r\n    enabled: { type: \"bool\", initialValue: true },\r\n    endSize: { type: \"real\", initialValue: -1 },\r\n    group: \"string\",\r\n    lifeSpan: { type: \"int\", initialValue: 1000 },\r\n    lifeSpanVariation: \"int\",\r\n    maximumEmitted: { type: \"int\", initialValue: -1 },\r\n    shape: \"Shape\",\r\n    size: { type: \"real\", initialValue: 16 },\r\n    sizeVariation: \"real\",\r\n    startTime: \"int\",\r\n    system: \"ParticleSystem\",\r\n    velocity: \"StochasticDirection\",\r\n    velocityFromMovement: \"real\"\r\n  },\r\n  signals: {\r\n    emitParticles: [{ type: \"Array\", name: \"particles\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n  burst(/*count, x, y*/) {\r\n    // TODO\r\n  }\r\n  pulse(duration) {\r\n    if (this.enabled) return;\r\n    this.enabled = true;\r\n    setTimeout(() => {\r\n      this.enabled = false;\r\n    }, duration);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"ParticlePainter\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    groups: \"list\",\r\n    system: \"ParticleSystem\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Particles\",\r\n  name: \"ParticleSystem\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    empty: \"bool\",\r\n    particleStates: \"list\",\r\n    paused: \"bool\",\r\n    running: { type: \"bool\", initialValue: true }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n  pause() {\r\n    this.paused = true;\r\n  }\r\n  reset() {\r\n    // TODO\r\n  }\r\n  restart() {\r\n    this.running = false;\r\n    this.running = true;\r\n  }\r\n  resume() {\r\n    this.paused = false;\r\n  }\r\n  start() {\r\n    this.running = true;\r\n  }\r\n  stop() {\r\n    this.running = false;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Window\",\r\n  name: \"Screen\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\"\r\n}, class Screen {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    throw new Error(\"Screen can only be used via the attached property.\");\r\n  }\r\n  static getAttachedObject() {\r\n    if (!Screen.$Screen) {\r\n      const screen = Screen.$Screen = new QmlWeb.QObject();\r\n      // TODO: read-only\r\n      QmlWeb.createProperties(screen, {\r\n        name: \"string\",\r\n        orientation: \"enum\",\r\n        orientationUpdateMask: \"enum\",\r\n        primaryOrientation: \"enum\",\r\n        pixelDensity: \"real\",\r\n        devicePixelRatio: \"real\",\r\n        desktopAvailableHeight: \"int\",\r\n        desktopAvailableWidth: \"int\",\r\n        height: \"int\",\r\n        width: \"int\"\r\n      });\r\n      screen.name = window.navigator.appName;\r\n      screen.devicePixelRatio = window.devicePixelRatio;\r\n      screen.pixelDensity = window.devicePixelRatio * 96 / 25.4; // per mm\r\n      Screen.$populateScreen();\r\n      window.addEventListener(\"resize\", () => Screen.$populateScreen());\r\n\r\n      // TODO: orientation\r\n      const Qt = QmlWeb.Qt;\r\n      screen.orientationUpdateMask = 0;\r\n      screen.orientation = Qt.PrimaryOrientation;\r\n      screen.primaryOrientation = Qt.PrimaryOrientation;\r\n    }\r\n    return Screen.$Screen;\r\n  }\r\n  static $populateScreen() {\r\n    const screen = Screen.$Screen;\r\n    screen.desktopAvailableHeight = window.outerHeight;\r\n    screen.desktopAvailableWidth = window.outerWidth;\r\n    screen.height = window.innerHeight;\r\n    screen.width = window.innerWidth;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick.Window\",\r\n  name: \"Window\",\r\n  versions: /^2\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    active: \"bool\",\r\n    activeFocusItem: \"Item\",\r\n    color: { type: \"color\", initialValue: \"#ffffff\" },\r\n    //contentItem: \"Item\", // TODO\r\n    contentOrientation: \"enum\",\r\n    flags: \"int\",\r\n    maximumHeight: \"int\",\r\n    maximumWidth: \"int\",\r\n    minimumHeight: \"int\",\r\n    minimumWidth: \"int\",\r\n    modality: \"enum\",\r\n    title: \"string\",\r\n    visibility: \"enum\"\r\n  },\r\n  signals: {\r\n    closing: [{ type: \"CloseEvent\", name: \"close\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.dom.style.backgroundColor = newVal.$css;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"AnimatedImage\",\r\n  versions: /.*/,\r\n  baseClass: \"Image\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Animation\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    Animation: { Infinite: -1 },\r\n    Easing: QmlWeb.Easing\r\n  },\r\n  properties: {\r\n    alwaysRunToEnd: \"bool\",\r\n    loops: { type: \"int\", initialValue: 1 },\r\n    paused: \"bool\",\r\n    running: \"bool\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n  restart() {\r\n    this.stop();\r\n    this.start();\r\n  }\r\n  start() {\r\n    this.running = true;\r\n  }\r\n  stop() {\r\n    this.running = false;\r\n  }\r\n  pause() {\r\n    this.paused = true;\r\n  }\r\n  resume() {\r\n    this.paused = false;\r\n  }\r\n  complete() {\r\n    // To be overridden\r\n    console.log(\"Unbound method for\", this);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Animator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animation\",\r\n  properties: {\r\n    duration: { type: \"int\", initialValue: 250 },\r\n    from: \"real\",\r\n    target: \"Item\",\r\n    to: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.easing = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.easing, {\r\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\r\n      amplitude: { type: \"real\", initialValue: 1 },\r\n      overshoot: { type: \"real\", initialValue: 1.70158 },\r\n      period: { type: \"real\", initialValue: 0.3 },\r\n      bezierCurve: \"list\"\r\n    });\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Behavior\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    animation: \"Animation\",\r\n    enabled: { type: \"bool\", initialValue: true }\r\n  },\r\n  defaultProperty: \"animation\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    this.$on = meta.object.$on;\r\n\r\n    this.animationChanged.connect(this, this.$onAnimationChanged);\r\n    this.enabledChanged.connect(this, this.$onEnabledChanged);\r\n  }\r\n  $onAnimationChanged(newVal) {\r\n    newVal.target = this.$parent;\r\n    newVal.property = this.$on;\r\n    this.$parent.$properties[this.$on].animation = newVal;\r\n  }\r\n  $onEnabledChanged(newVal) {\r\n    this.$parent.$properties[this.$on].animation = newVal\r\n      ? this.animation\r\n      : null;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"BorderImage\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    BorderImage: {\r\n      Stretch: \"stretch\", Repeat: \"repeat\", Round: \"round\",\r\n      Null: 1, Ready: 2, Loading: 3, Error: 4\r\n    }\r\n  },\r\n  properties: {\r\n    source: \"url\",\r\n    smooth: { type: \"bool\", initialValue: true },\r\n    // BorderImage.Stretch\r\n    horizontalTileMode: { type: \"enum\", initialValue: \"stretch\" },\r\n    // BorderImage.Stretch\r\n    verticalTileMode: { type: \"enum\", initialValue: \"stretch\" },\r\n    progress: \"real\",\r\n    status: { type: \"enum\", initialValue: 1 } // BorderImage.Null\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.border = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.border, {\r\n      left: \"int\",\r\n      right: \"int\",\r\n      top: \"int\",\r\n      bottom: \"int\"\r\n    });\r\n\r\n    const bg = this.impl = document.createElement(\"div\");\r\n    bg.style.pointerEvents = \"none\";\r\n    bg.style.height = \"100%\";\r\n    bg.style.boxSizing = \"border-box\";\r\n    this.dom.appendChild(bg);\r\n\r\n    this.$img = new Image();\r\n    this.$img.addEventListener(\"load\", () => {\r\n      this.progress = 1;\r\n      this.status = this.BorderImage.Ready;\r\n    });\r\n    this.$img.addEventListener(\"error\", () => {\r\n      this.status = this.BorderImage.Error;\r\n    });\r\n\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n    this.border.leftChanged.connect(this, this.$updateBorder);\r\n    this.border.rightChanged.connect(this, this.$updateBorder);\r\n    this.border.topChanged.connect(this, this.$updateBorder);\r\n    this.border.bottomChanged.connect(this, this.$updateBorder);\r\n    this.horizontalTileModeChanged.connect(this, this.$updateBorder);\r\n    this.verticalTileModeChanged.connect(this, this.$updateBorder);\r\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\r\n  }\r\n  $onSourceChanged(source) {\r\n    this.progress = 0;\r\n    this.status = this.BorderImage.Loading;\r\n    const style = this.impl.style;\r\n    const imageURL = QmlWeb.engine.$resolveImageURL(source);\r\n    style.OBorderImageSource = `url(\"${imageURL}\")`;\r\n    style.borderImageSource = `url(\"${imageURL}\")`;\r\n    this.$img.src = imageURL;\r\n    if (this.$img.complete) {\r\n      this.progress = 1;\r\n      this.status = this.BorderImage.Ready;\r\n    }\r\n  }\r\n  $updateBorder() {\r\n    const style = this.impl.style;\r\n    const { right, left, top, bottom } = this.border;\r\n    const slice = `${top} ${right} ${bottom} ${left} fill`;\r\n    const width = `${top}px ${right}px ${bottom}px ${left}px`;\r\n    const repeat = `${this.horizontalTileMode} ${this.verticalTileMode}`;\r\n    style.OBorderImageSlice = slice;\r\n    style.OBorderImageRepeat = repeat;\r\n    style.OBorderImageWidth = width;\r\n    style.borderImageSlice = slice;\r\n    style.borderImageRepeat = repeat;\r\n    style.borderImageWidth = width;\r\n  }\r\n  $onSmoothChanged(val) {\r\n    const style = this.impl.style;\r\n    if (val) {\r\n      style.imageRendering = \"auto\";\r\n    } else {\r\n      style.imageRendering = \"-webkit-optimize-contrast\";\r\n      style.imageRendering = \"-moz-crisp-edges\";\r\n      style.imageRendering = \"crisp-edges\";\r\n      style.imageRendering = \"pixelated\";\r\n    }\r\n  }\r\n});\r\n","// TODO\r\n// Currently only a skeleton implementation\r\n\r\nQmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Canvas\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    available: { type: \"bool\", initialValue: true },\r\n    canvasSize: { type: \"var\", initialValue: [0, 0] },\r\n    canvasWindow: { type: \"var\", initialValue: [0, 0, 0, 0] },\r\n    context: { type: \"var\", initialValue: {} },\r\n    contextType: { type: \"string\", initialValue: \"contextType\" },\r\n    renderStrategy: \"enum\",\r\n    renderTarget: \"enum\",\r\n    tileSize: { type: \"var\", initialValue: [0, 0] }\r\n  },\r\n  signals: {\r\n    imageLoaded: [],\r\n    paint: [{ type: \"var\", name: \"region\" }],\r\n    painted: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n  cancelRequestAnimationFrame(/*handle*/) {\r\n    return false;\r\n  }\r\n  getContext(/*context_id, ...args*/) {\r\n    return {};\r\n  }\r\n  isImageError(/*image*/) {\r\n    return true;\r\n  }\r\n  isImageLoaded(/*image*/) {\r\n    return false;\r\n  }\r\n  isImageLoading(/*image*/) {\r\n    return false;\r\n  }\r\n  loadImage(image) {\r\n    //loadImageAsync(image);\r\n    if (this.isImageLoaded(image)) {\r\n      this.imageLoaded();\r\n    }\r\n  }\r\n  markDirty(area) {\r\n    // if dirty\r\n    this.paint(area);\r\n  }\r\n  requestAnimationFrame(/*callback*/) {\r\n    return 0;\r\n  }\r\n  requestPaint() {\r\n  }\r\n  save(/*file_name*/) {\r\n    return false;\r\n  }\r\n  toDataURL(/*mime_type*/) {\r\n    return \"\";\r\n  }\r\n  unloadImage(/*image*/) {\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Column\",\r\n  versions: /.*/,\r\n  baseClass: \"Positioner\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n  layoutChildren() {\r\n    let curPos = this.padding;\r\n    let maxWidth = 0;\r\n    for (let i = 0; i < this.children.length; i++) {\r\n      const child = this.children[i];\r\n      if (!child.visible || !child.width || !child.height) {\r\n        continue;\r\n      }\r\n      maxWidth = child.width > maxWidth ? child.width : maxWidth;\r\n      child.y = curPos + this.padding;\r\n      if (this.padding > 0) child.x = this.padding;\r\n      curPos += child.height + this.spacing;\r\n    }\r\n    this.implicitWidth = maxWidth + this.padding * 2;\r\n    this.implicitHeight = curPos - this.spacing + this.padding;\r\n    // We want no spacing at the bottom side\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"DoubleValidator\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    DoubleValidator: { StandardNotation: 1, ScientificNotation: 2 }\r\n  },\r\n  properties: {\r\n    bottom: { type: \"real\", initialValue: -Infinity },\r\n    top: { type: \"real\", initialValue: Infinity },\r\n    decimals: { type: \"int\", initialValue: 1000 },\r\n    // DoubleValidator.ScientificNotation\r\n    notation: { type: \"enum\", initialValue: 2 }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    this.$standardRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\r\n    this.$scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\r\n  }\r\n  getRegExpForNotation(notation) {\r\n    switch (notation) {\r\n      case this.DoubleValidator.ScientificNotation:\r\n        return this.$scientificRegExp;\r\n      case this.DoubleValidator.StandardNotation:\r\n        return this.$standardRegExp;\r\n    }\r\n    return null;\r\n  }\r\n  $getDecimalsForNumber(number) {\r\n    if (Math.round(number) === number) {\r\n      return 0;\r\n    }\r\n    const str = `${number}`;\r\n    return /\\d*$/.exec(str)[0].length;\r\n  }\r\n  validate(string) {\r\n    const regExp = this.getRegExpForNotation(this.notation);\r\n    if (!regExp.test(string.trim())) {\r\n      return false;\r\n    }\r\n    const value = parseFloat(string);\r\n    return this.bottom <= value && this.top >= value &&\r\n           this.$getDecimalsForNumber(value) <= this.decimals;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Flow\",\r\n  versions: /.*/,\r\n  baseClass: \"Positioner\",\r\n  enums: {\r\n    Flow: { LeftToRight: 0, TopToBottom: 1 }\r\n  },\r\n  properties: {\r\n    flow: \"enum\", // Flow.LeftToRight\r\n    layoutDirection: \"enum\" // Flow.LeftToRight\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.flowChanged.connect(this, this.layoutChildren);\r\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\r\n    this.widthChanged.connect(this, this.layoutChildren);\r\n    this.heightChanged.connect(this, this.layoutChildren);\r\n    this.layoutChildren();\r\n  }\r\n\r\n  layoutChildren() {\r\n    if (this.flow === undefined) {\r\n      // Flow has not been fully initialized yet\r\n      return;\r\n    }\r\n\r\n    let curHPos = 0;\r\n    let curVPos = 0;\r\n    let rowSize = 0;\r\n    for (let i = 0; i < this.children.length; i++) {\r\n      const child = this.children[i];\r\n      if (!child.visible || !child.width || !child.height) {\r\n        continue;\r\n      }\r\n\r\n      if (this.flow === this.Flow.LeftToRight) {\r\n        if (!this.$isUsingImplicitWidth && curHPos + child.width > this.width) {\r\n          curHPos = 0;\r\n          curVPos += rowSize + this.spacing;\r\n          rowSize = 0;\r\n        }\r\n        rowSize = child.height > rowSize ? child.height : rowSize;\r\n        child.x = this.layoutDirection === this.Flow.TopToBottom\r\n                ? this.width - curHPos - child.width : curHPos;\r\n        child.y = curVPos;\r\n        curHPos += child.width + this.spacing;\r\n      } else { // Flow.TopToBottom\r\n        if (!this.$isUsingImplicitHeight\r\n            && curVPos + child.height > this.height) {\r\n          curVPos = 0;\r\n          curHPos += rowSize + this.spacing;\r\n          rowSize = 0;\r\n        }\r\n        rowSize = child.width > rowSize ? child.width : rowSize;\r\n        child.x = this.layoutDirection === this.Flow.TopToBottom\r\n                ? this.width - curHPos - child.width : curHPos;\r\n        child.y = curVPos;\r\n        curVPos += child.height + this.spacing;\r\n      }\r\n    }\r\n\r\n    if (this.flow === this.Flow.LeftToRight) {\r\n      this.implicitWidth = curHPos - this.spacing;\r\n      this.implicitHeight = curVPos + rowSize;\r\n    } else { // Flow.TopToBottom\r\n      this.implicitWidth = curHPos + rowSize;\r\n      this.implicitHeight = curVPos - this.spacing;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"FocusScope\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"FontLoader\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    FontLoader: { Null: 0, Ready: 1, Loading: 2, Error: 3 }\r\n  },\r\n  properties: {\r\n    name: \"string\",\r\n    source: \"url\",\r\n    status: \"enum\" // FontLoader.Null\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$lastName = \"\";\r\n    this.$inTouchName = false;\r\n\r\n    /*\r\n      Maximum timeout is the maximum time for a font to load. If font isn't\r\n      loaded in this time, the status is set to Error.\r\n      For both cases (with and without FontLoader.js) if the font takes more\r\n      than the maximum timeout to load, dimensions recalculations for elements\r\n      that are using this font will not be triggered or will have no effect.\r\n\r\n      FontLoader.js uses only the last timeout. The state and name properties\r\n      are set immediately when the font loads. If the font could not be loaded,\r\n      the Error status will be set only when this timeout expires. If the font\r\n      loading takes more than the timeout, the name property is set, but the\r\n      status is set to Error.\r\n\r\n      Fallback sets the font name immediately and touches it several times to\r\n      trigger dimensions recalcuations. The status is set to Error and should\r\n      not be used.\r\n    */\r\n    // 15 seconds maximum\r\n    this.$timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000];\r\n\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n    this.nameChanged.connect(this, this.$onNameChanged);\r\n  }\r\n  $loadFont(fontName, fontFace) {\r\n    /* global FontLoader */\r\n    if (this.$lastName === fontName || this.$inTouchName) {\r\n      return;\r\n    }\r\n    this.$lastName = fontName;\r\n\r\n    if (!fontName) {\r\n      this.status = this.FontLoader.Null;\r\n      return;\r\n    }\r\n    this.status = this.FontLoader.Loading;\r\n\r\n    let promise;\r\n    if (fontFace) {\r\n      promise = fontFace.loaded;\r\n    } else if (document.fonts && document.fonts.load) {\r\n      promise = document.fonts.load(fontName);\r\n    }\r\n\r\n    if (promise) {\r\n      promise.then(\r\n        () => {\r\n          if (this.$lastName !== fontName) return;\r\n          this.name = fontName;\r\n          this.status = this.FontLoader.Ready;\r\n        },\r\n        () => {\r\n          if (this.$lastName !== fontName) return;\r\n          this.status = this.FontLoader.Error;\r\n        }\r\n      );\r\n    } else if (typeof FontLoader === \"function\") {\r\n      const fontLoader = new FontLoader([fontName], {\r\n        fontsLoaded: error => {\r\n          if (error !== null) {\r\n            if (this.$lastName === fontName &&\r\n                error.notLoadedFontFamilies[0] === fontName) {\r\n              // Set the name for the case of font loading after the timeout.\r\n              this.name = fontName;\r\n              this.status = this.FontLoader.Error;\r\n            }\r\n          }\r\n        },\r\n        fontLoaded: fontFamily => {\r\n          if (this.$lastName === fontName && fontFamily === fontName) {\r\n            this.name = fontName;\r\n            this.status = this.FontLoader.Ready;\r\n          }\r\n        }\r\n      }, this.$timeouts[this.$timeouts.length - 1]);\r\n      // Else I get problems loading multiple fonts (FontLoader.js bug?)\r\n      FontLoader.testDiv = null;\r\n      fontLoader.loadFonts();\r\n    } else {\r\n      console.warn(`FontLoader.js library is not loaded.\r\nYou should load FontLoader.js if you want to use QtQuick FontLoader elements.\r\nRefs: https://github.com/smnh/FontLoader.`);\r\n      // You should not rely on 'status' property without FontLoader.js.\r\n      this.status = this.FontLoader.Error;\r\n      this.name = fontName;\r\n      this.$cycleTouchName(fontName, 0);\r\n    }\r\n  }\r\n  $cycleTouchName(fontName, i) {\r\n    if (this.$lastName !== fontName) {\r\n      return;\r\n    }\r\n    if (i > 0) {\r\n      const name = this.name;\r\n      this.$inTouchName = true;\r\n      // Calling this.nameChanged() is not enough, we have to actually change\r\n      // the value to flush the bindings.\r\n      this.name = \"sans-serif\";\r\n      this.name = name;\r\n      this.$inTouchName = false;\r\n    }\r\n    if (i < this.$timeouts.length) {\r\n      setTimeout(() => {\r\n        this.$cycleTouchName(fontName, i + 1);\r\n      }, this.$timeouts[i] - (i > 0 ? this.$timeouts[i - 1] : 0));\r\n    }\r\n  }\r\n  $onSourceChanged(font_src) {\r\n    // Load font by source url\r\n    const rand = Math.round(Math.random() * 1e15);\r\n    const fontName = `font_${Date.now().toString(36)}_${rand.toString(36)}`;\r\n    if (typeof FontFace !== undefined && document.fonts && document.fonts.add) {\r\n      const fontFace = new FontFace(fontName, `url('${font_src}')`);\r\n      document.fonts.add(fontFace);\r\n      fontFace.load();\r\n      this.$loadFont(fontName, fontFace);\r\n      return;\r\n    }\r\n    if (!this.$domStyle) {\r\n      this.$domStyle = document.createElement(\"style\");\r\n    }\r\n    this.$domStyle.innerHTML = `@font-face {\r\n      font-family: ${fontName};\r\n      src: url('${font_src}');\r\n    }`;\r\n    document.getElementsByTagName(\"head\")[0].appendChild(this.$domStyle);\r\n    this.$loadFont(fontName);\r\n  }\r\n  $onNameChanged(fontName) {\r\n    // Load font by the name\r\n    this.$loadFont(fontName);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Grid\",\r\n  versions: /.*/,\r\n  baseClass: \"Positioner\",\r\n  enums: {\r\n    Grid: { LeftToRight: 0, TopToBottom: 1 }\r\n  },\r\n  properties: {\r\n    columns: \"int\",\r\n    rows: \"int\",\r\n    flow: \"enum\",\r\n    layoutDirection: \"enum\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.columnsChanged.connect(this, this.layoutChildren);\r\n    this.rowsChanged.connect(this, this.layoutChildren);\r\n    this.flowChanged.connect(this, this.layoutChildren);\r\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\r\n    this.layoutChildren();\r\n  }\r\n  layoutChildren() {\r\n    // How many items are actually visible?\r\n    const visibleItems = this.$getVisibleItems();\r\n\r\n    // How many rows and columns do we need?\r\n    const [c, r] = this.$calculateSize(visibleItems.length);\r\n\r\n    // How big are the colums/rows?\r\n    const [colWidth, rowHeight] = this.$calculateGrid(visibleItems, c, r);\r\n\r\n    // Do actual positioning\r\n    // When layoutDirection is RightToLeft we need oposite order of coumns\r\n    const step = this.layoutDirection === 1 ? -1 : 1;\r\n    const startingPoint = this.layoutDirection === 1 ? c - 1 : 0;\r\n    const endPoint = this.layoutDirection === 1 ? -1 : c;\r\n    let curHPos = 0;\r\n    let curVPos = 0;\r\n    if (this.flow === 0) {\r\n      for (let i = 0; i < r; i++) {\r\n        for (let j = startingPoint; j !== endPoint; j += step) {\r\n          const item = visibleItems[i * c + j];\r\n          if (!item) {\r\n            break;\r\n          }\r\n          item.x = curHPos;\r\n          item.y = curVPos;\r\n\r\n          curHPos += colWidth[j] + this.spacing;\r\n        }\r\n        curVPos += rowHeight[i] + this.spacing;\r\n        curHPos = 0;\r\n      }\r\n    } else {\r\n      for (let i = startingPoint; i !== endPoint; i += step) {\r\n        for (let j = 0; j < r; j++) {\r\n          const item = visibleItems[i * r + j];\r\n          if (!item) {\r\n            break;\r\n          }\r\n          item.x = curHPos;\r\n          item.y = curVPos;\r\n\r\n          curVPos += rowHeight[j] + this.spacing;\r\n        }\r\n        curHPos += colWidth[i] + this.spacing;\r\n        curVPos = 0;\r\n      }\r\n    }\r\n\r\n    // Set implicit size\r\n    let gridWidth = -this.spacing;\r\n    let gridHeight = -this.spacing;\r\n    for (const i in colWidth) {\r\n      gridWidth += colWidth[i] + this.spacing;\r\n    }\r\n    for (const i in rowHeight) {\r\n      gridHeight += rowHeight[i] + this.spacing;\r\n    }\r\n    this.implicitWidth = gridWidth;\r\n    this.implicitHeight = gridHeight;\r\n  }\r\n  $getVisibleItems() {\r\n    return this.children.filter(child =>\r\n      child.visible && child.width && child.height\r\n    );\r\n  }\r\n  $calculateSize(length) {\r\n    let cols;\r\n    let rows;\r\n    if (!this.columns && !this.rows) {\r\n      cols = 4;\r\n      rows = Math.ceil(length / cols);\r\n    } else if (!this.columns) {\r\n      rows = this.rows;\r\n      cols = Math.ceil(length / rows);\r\n    } else {\r\n      cols = this.columns;\r\n      rows = Math.ceil(length / cols);\r\n    }\r\n    return [cols, rows];\r\n  }\r\n  $calculateGrid(visibleItems, cols, rows) {\r\n    const colWidth = [];\r\n    const rowHeight = [];\r\n\r\n    if (this.flow === 0) {\r\n      for (let i = 0; i < rows; i++) {\r\n        for (let j = 0; j < cols; j++) {\r\n          const item = visibleItems[i * cols + j];\r\n          if (!item) {\r\n            break;\r\n          }\r\n          if (!colWidth[j] || item.width > colWidth[j]) {\r\n            colWidth[j] = item.width;\r\n          }\r\n          if (!rowHeight[i] || item.height > rowHeight[i]) {\r\n            rowHeight[i] = item.height;\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      for (let i = 0; i < cols; i++) {\r\n        for (let j = 0; j < rows; j++) {\r\n          const item = visibleItems[i * rows + j];\r\n          if (!item) {\r\n            break;\r\n          }\r\n          if (!rowHeight[j] || item.height > rowHeight[j]) {\r\n            rowHeight[j] = item.height;\r\n          }\r\n          if (!colWidth[i] || item.width > colWidth[i]) {\r\n            colWidth[i] = item.width;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return [colWidth, rowHeight];\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Image\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    Image: {\r\n      Stretch: 1, PreserveAspectFit: 2, PreserveAspectCrop: 3,\r\n      Tile: 4, TileVertically: 5, TileHorizontally: 6,\r\n\r\n      Null: 1, Ready: 2, Loading: 3, Error: 4\r\n    }\r\n  },\r\n  properties: {\r\n    asynchronous: { type: \"bool\", initialValue: true },\r\n    cache: { type: \"bool\", initialValue: true },\r\n    smooth: { type: \"bool\", initialValue: true },\r\n    fillMode: { type: \"enum\", initialValue: 1 }, // Image.Stretch\r\n    mirror: \"bool\",\r\n    progress: \"real\",\r\n    source: \"url\",\r\n    status: { type: \"enum\", initialValue: 1 } // Image.Null\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.sourceSize = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.sourceSize, {\r\n      width: \"int\",\r\n      height: \"int\"\r\n    });\r\n\r\n    const bg = this.impl = document.createElement(\"div\");\r\n    bg.style.pointerEvents = \"none\";\r\n    bg.style.height = \"100%\";\r\n    this.dom.appendChild(bg);\r\n\r\n    this.$img = new Image();\r\n    this.$img.addEventListener(\"load\", () => {\r\n      const w = this.$img.naturalWidth;\r\n      const h = this.$img.naturalHeight;\r\n      this.sourceSize.width = w;\r\n      this.sourceSize.height = h;\r\n      this.implicitWidth = w;\r\n      this.implicitHeight = h;\r\n      this.progress = 1;\r\n      this.status = this.Image.Ready;\r\n    });\r\n    this.$img.addEventListener(\"error\", () => {\r\n      this.status = this.Image.Error;\r\n    });\r\n\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n    this.mirrorChanged.connect(this, this.$onMirrorChanged);\r\n    this.fillModeChanged.connect(this, this.$onFillModeChanged);\r\n    this.smoothChanged.connect(this, this.$onSmoothChanged);\r\n  }\r\n  $updateFillMode(val = this.fillMode) {\r\n    const style = this.impl.style;\r\n    switch (val) {\r\n      default:\r\n      case this.Image.Stretch:\r\n        style.backgroundRepeat = \"auto\";\r\n        style.backgroundSize = \"100% 100%\";\r\n        style.backgroundPosition = \"auto\";\r\n        break;\r\n      case this.Image.Tile:\r\n        style.backgroundRepeat = \"auto\";\r\n        style.backgroundSize = \"auto\";\r\n        style.backgroundPosition = \"center\";\r\n        break;\r\n      case this.Image.PreserveAspectFit:\r\n        style.backgroundRepeat = \"no-repeat\";\r\n        style.backgroundSize = \"contain\";\r\n        style.backgroundPosition = \"center\";\r\n        break;\r\n      case this.Image.PreserveAspectCrop:\r\n        style.backgroundRepeat = \"no-repeat\";\r\n        style.backgroundSize = \"cover\";\r\n        style.backgroundPosition = \"center\";\r\n        break;\r\n      case this.Image.TileVertically:\r\n        style.backgroundRepeat = \"repeat-y\";\r\n        style.backgroundSize = \"100% auto\";\r\n        style.backgroundPosition = \"auto\";\r\n        break;\r\n      case this.Image.TileHorizontally:\r\n        style.backgroundRepeat = \"repeat-x\";\r\n        style.backgroundSize = \"auto 100%\";\r\n        style.backgroundPosition = \"auto\";\r\n        break;\r\n    }\r\n  }\r\n  $onSourceChanged(source) {\r\n    this.progress = 0;\r\n    this.status = this.Image.Loading;\r\n    const imageURL = QmlWeb.engine.$resolveImageURL(source);\r\n    this.impl.style.backgroundImage = `url(\"${imageURL}\")`;\r\n    this.$img.src = imageURL;\r\n    if (this.$img.complete) {\r\n      this.progress = 1;\r\n      this.status = this.Image.Ready;\r\n    }\r\n    this.$updateFillMode();\r\n  }\r\n  $onMirrorChanged(val) {\r\n    const transformRule = \"scale(-1,1)\";\r\n    if (!val) {\r\n      const index = this.transform.indexOf(transformRule);\r\n      if (index >= 0) {\r\n        this.transform.splice(index, 1);\r\n      }\r\n    } else {\r\n      this.transform.push(transformRule);\r\n    }\r\n    this.$updateTransform();\r\n  }\r\n  $onFillModeChanged(val) {\r\n    this.$updateFillMode(val);\r\n  }\r\n  $onSmoothChanged(val) {\r\n    const style = this.impl.style;\r\n    if (val) {\r\n      style.imageRendering = \"auto\";\r\n    } else {\r\n      style.imageRendering = \"-webkit-optimize-contrast\";\r\n      style.imageRendering = \"-moz-crisp-edges\";\r\n      style.imageRendering = \"crisp-edges\";\r\n      style.imageRendering = \"pixelated\";\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"IntValidator\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    bottom: { type: \"int\", initialValue: -2147483647 },\r\n    top: { type: \"int\", initialValue: 2147483647 }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n  validate(string) {\r\n    const regExp = /^(-|\\+)?\\s*[0-9]+$/;\r\n    let acceptable = regExp.test(string.trim());\r\n\r\n    if (acceptable) {\r\n      const value = parseInt(string, 10);\r\n      acceptable = this.bottom <= value && this.top >= value;\r\n    }\r\n    return acceptable;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Item\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    $opacity: { type: \"real\", initialValue: 1 },\r\n    parent: \"Item\",\r\n    antialiasing: \"bool\",\r\n    state: \"string\",\r\n    states: \"list\",\r\n    transitions: \"list\",\r\n    data: \"list\",\r\n    children: \"list\",\r\n    resources: \"list\",\r\n    transform: \"list\",\r\n    x: \"real\",\r\n    y: \"real\",\r\n    z: \"real\",\r\n    width: \"real\",\r\n    height: \"real\",\r\n    implicitWidth: \"real\",\r\n    implicitHeight: \"real\",\r\n    left: \"real\",\r\n    right: \"real\",\r\n    top: \"real\",\r\n    bottom: \"real\",\r\n    horizontalCenter: \"real\",\r\n    verticalCenter: \"real\",\r\n    rotation: \"real\",\r\n    scale: { type: \"real\", initialValue: 1 },\r\n    opacity: { type: \"real\", initialValue: 1 },\r\n    visible: { type: \"bool\", initialValue: true },\r\n    clip: \"bool\",\r\n    focus: \"bool\"\r\n  },\r\n  defaultProperty: \"data\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    if (!this.dom) { // Create a dom element for this item.\r\n      this.dom = document.createElement(meta.tagName || \"div\");\r\n    }\r\n    this.dom.style.position = \"absolute\";\r\n    this.dom.style.pointerEvents = \"none\";\r\n    // In case the class is qualified, only use the last part for the css class\r\n    // name.\r\n    const classComponent = meta.object.$class.split(\".\").pop();\r\n    this.dom.className = `${classComponent}${this.id ? ` ${this.id}` : \"\"}`;\r\n    this.css = this.dom.style;\r\n    this.impl = null; // Store the actually drawn element\r\n\r\n    this.css.boxSizing = \"border-box\";\r\n\r\n    if (this.$isComponentRoot) {\r\n      QmlWeb.createProperty(\"var\", this, \"activeFocus\");\r\n    }\r\n\r\n    this.parentChanged.connect(this, this.$onParentChanged_);\r\n    this.dataChanged.connect(this, this.$onDataChanged);\r\n    this.stateChanged.connect(this, this.$onStateChanged);\r\n    this.visibleChanged.connect(this, this.$onVisibleChanged_);\r\n    this.clipChanged.connect(this, this.$onClipChanged);\r\n    this.zChanged.connect(this, this.$onZChanged);\r\n    this.xChanged.connect(this, this.$onXChanged);\r\n    this.yChanged.connect(this, this.$onYChanged);\r\n    this.widthChanged.connect(this, this.$onWidthChanged_);\r\n    this.heightChanged.connect(this, this.$onHeightChanged_);\r\n    this.focusChanged.connect(this, this.$onFocusChanged_);\r\n\r\n    this.widthChanged.connect(this, this.$updateHGeometry);\r\n    this.heightChanged.connect(this, this.$updateVGeometry);\r\n    this.implicitWidthChanged.connect(this, this.$onImplicitWidthChanged);\r\n    this.implicitHeightChanged.connect(this, this.$onImplicitHeightChanged);\r\n\r\n    this.$isUsingImplicitWidth = true;\r\n    this.$isUsingImplicitHeight = true;\r\n\r\n    this.anchors = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.anchors, {\r\n      left: \"var\",\r\n      right: \"var\",\r\n      top: \"var\",\r\n      bottom: \"var\",\r\n      horizontalCenter: \"var\",\r\n      verticalCenter: \"var\",\r\n      fill: \"Item\",\r\n      centerIn: \"Item\",\r\n      margins: \"real\",\r\n      leftMargin: \"real\",\r\n      rightMargin: \"real\",\r\n      topMargin: \"real\",\r\n      bottomMargin: \"real\"\r\n    });\r\n    this.anchors.leftChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.rightChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.topChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.bottomChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.horizontalCenterChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.verticalCenterChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.fillChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.fillChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.centerInChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.centerInChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.leftMarginChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.rightMarginChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.topMarginChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.bottomMarginChanged.connect(this, this.$updateVGeometry);\r\n    this.anchors.marginsChanged.connect(this, this.$updateHGeometry);\r\n    this.anchors.marginsChanged.connect(this, this.$updateVGeometry);\r\n\r\n    // childrenRect property\r\n    this.childrenRect = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.childrenRect, {\r\n      x: \"real\", // TODO ro\r\n      y: \"real\", // TODO ro\r\n      width: \"real\", // TODO ro\r\n      height: \"real\" // TODO ro\r\n    });\r\n\r\n    this.rotationChanged.connect(this, this.$updateTransform);\r\n    this.scaleChanged.connect(this, this.$updateTransform);\r\n    this.transformChanged.connect(this, this.$updateTransform);\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted_);\r\n    this.opacityChanged.connect(this, this.$calculateOpacity);\r\n    if (this.$parent) {\r\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\r\n    }\r\n\r\n    this.spacing = 0;\r\n    this.$revertActions = [];\r\n    this.css.left = `${this.x}px`;\r\n    this.css.top = `${this.y}px`;\r\n  }\r\n  $onParentChanged_(newParent, oldParent, propName) {\r\n    if (oldParent) {\r\n      oldParent.children.splice(oldParent.children.indexOf(this), 1);\r\n      oldParent.childrenChanged();\r\n      oldParent.dom.removeChild(this.dom);\r\n    }\r\n    if (newParent && newParent.children.indexOf(this) === -1) {\r\n      newParent.children.push(this);\r\n      newParent.childrenChanged();\r\n    }\r\n    if (newParent) {\r\n      newParent.dom.appendChild(this.dom);\r\n    }\r\n    this.$updateHGeometry(newParent, oldParent, propName);\r\n    this.$updateVGeometry(newParent, oldParent, propName);\r\n  }\r\n  $onDataChanged(newData) {\r\n    const QMLItem = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Item\");\r\n    for (const i in newData) {\r\n      const child = newData[i];\r\n      if (child instanceof QMLItem) {\r\n        child.parent = this; // This will also add it to children.\r\n      } else {\r\n        this.resources.push(child);\r\n      }\r\n    }\r\n  }\r\n  $onStateChanged(newVal, oldVal) {\r\n    // let oldState; // TODO: do we need oldState?\r\n    let newState;\r\n    for (let i = 0; i < this.states.length; i++) {\r\n      if (this.states[i].name === newVal) {\r\n        newState = this.states[i];\r\n      }\r\n      /*\r\n      else if (this.states[i].name === oldVal) {\r\n        oldState = this.states[i];\r\n      }\r\n      */\r\n    }\r\n\r\n    const actions = this.$revertActions.slice();\r\n\r\n    // Get current values for revert actions\r\n    for (const i in actions) {\r\n      const action = actions[i];\r\n      action.from = action.target[action.property];\r\n    }\r\n    if (newState) {\r\n      const changes = newState.$getAllChanges();\r\n\r\n      // Get all actions we need to do and create actions to revert them\r\n      for (let i = 0; i < changes.length; i++) {\r\n        this.$applyChange(actions, changes[i]);\r\n      }\r\n    }\r\n\r\n    // Set all property changes and fetch the actual values afterwards\r\n    // The latter is needed for transitions. We need to set all properties\r\n    // before we fetch the values because properties can be interdependent.\r\n    for (const i in actions) {\r\n      const action = actions[i];\r\n      action.target.$properties[action.property].set(\r\n        action.value, QmlWeb.QMLProperty.ReasonUser, action.target,\r\n        newState ? newState.$context : action.target.$context\r\n      );\r\n    }\r\n    for (const i in actions) {\r\n      const action = actions[i];\r\n      action.to = action.target[action.property];\r\n      if (action.explicit) {\r\n        // Remove binding\r\n        action.target[action.property] = action.target[action.property];\r\n        action.value = action.target[action.property];\r\n      }\r\n    }\r\n\r\n    // Find the best transition to use\r\n    let transition;\r\n    let rating = 0;\r\n    for (let i = 0; i < this.transitions.length; i++) {\r\n      // We need to stop running transitions, so let's do\r\n      // it while iterating through the transitions anyway\r\n      this.transitions[i].$stop();\r\n      const curTransition = this.transitions[i];\r\n      let curRating = 0;\r\n      if (curTransition.from === oldVal ||\r\n          curTransition.reversible && curTransition.from === newVal) {\r\n        curRating += 2;\r\n      } else if (curTransition.from === \"*\") {\r\n        curRating++;\r\n      } else {\r\n        continue;\r\n      }\r\n      if (curTransition.to === newVal ||\r\n        curTransition.reversible && curTransition.to === oldVal) {\r\n        curRating += 2;\r\n      } else if (curTransition.to === \"*\") {\r\n        curRating++;\r\n      } else {\r\n        continue;\r\n      }\r\n      if (curRating > rating) {\r\n        rating = curRating;\r\n        transition = curTransition;\r\n      }\r\n    }\r\n    if (transition) {\r\n      transition.$start(actions);\r\n    }\r\n  }\r\n  $applyChange(actions, change) {\r\n    const arrayFindIndex = QmlWeb.helpers.arrayFindIndex;\r\n    for (let j = 0; j < change.$actions.length; j++) {\r\n      const item = change.$actions[j];\r\n\r\n      const action = {\r\n        target: change.target,\r\n        property: item.property,\r\n        origValue: change.target.$properties[item.property].binding ||\r\n                    change.target.$properties[item.property].val,\r\n        value: item.value,\r\n        from: change.target[item.property],\r\n        to: undefined,\r\n        explicit: change.explicit\r\n      };\r\n\r\n      const actionIndex = arrayFindIndex(actions, element =>\r\n        element.target === action.target &&\r\n        element.property === action.property\r\n      );\r\n      if (actionIndex !== -1) {\r\n        actions[actionIndex] = action;\r\n      } else {\r\n        actions.push(action);\r\n      }\r\n\r\n      // Look for existing revert action, else create it\r\n      const revertIndex = arrayFindIndex(this.$revertActions, element =>\r\n        element.target === change.target &&\r\n        element.property === item.property\r\n      );\r\n      if (revertIndex !== -1 && !change.restoreEntryValues) {\r\n        // We don't want to revert, so remove it\r\n        this.$revertActions.splice(revertIndex, 1);\r\n      } else if (revertIndex === -1 && change.restoreEntryValues) {\r\n        this.$revertActions.push({\r\n          target: change.target,\r\n          property: item.property,\r\n          value: change.target.$properties[item.property].binding ||\r\n                  change.target.$properties[item.property].val,\r\n          from: undefined,\r\n          to: change.target[item.property]\r\n        });\r\n      }\r\n    }\r\n  }\r\n  $onVisibleChanged_(newVal) {\r\n    this.css.visibility = newVal ? \"inherit\" : \"hidden\";\r\n  }\r\n  $onClipChanged(newVal) {\r\n    this.css.overflow = newVal ? \"hidden\" : \"visible\";\r\n  }\r\n  $onZChanged() {\r\n    this.$updateTransform();\r\n  }\r\n  $onXChanged(newVal) {\r\n    this.css.left = `${newVal}px`;\r\n    this.$updateHGeometry();\r\n  }\r\n  $onYChanged(newVal) {\r\n    this.css.top = `${newVal}px`;\r\n    this.$updateVGeometry();\r\n  }\r\n  $onWidthChanged_(newVal) {\r\n    this.css.width = newVal ? `${newVal}px` : \"auto\";\r\n  }\r\n  $onHeightChanged_(newVal) {\r\n    this.css.height = newVal ? `${newVal}px` : \"auto\";\r\n  }\r\n  $onFocusChanged_(newVal) {\r\n    if (newVal) {\r\n      if (this.dom.firstChild) {\r\n        this.dom.firstChild.focus();\r\n      }\r\n      document.qmlFocus = this;\r\n      this.$context.activeFocus = this;\r\n    } else if (document.qmlFocus === this) {\r\n      document.getElementsByTagName(\"BODY\")[0].focus();\r\n      document.qmlFocus = QmlWeb.engine.rootContext().base;\r\n      this.$context.activeFocus = null;\r\n    }\r\n  }\r\n  setupFocusOnDom(element) {\r\n    const updateFocus = () => {\r\n      const hasFocus = document.activeElement === this.dom ||\r\n                       document.activeElement === this.dom.firstChild;\r\n      if (this.focus !== hasFocus) {\r\n        this.focus = hasFocus;\r\n      }\r\n    };\r\n    element.addEventListener(\"focus\", updateFocus);\r\n    element.addEventListener(\"blur\", updateFocus);\r\n  }\r\n  $updateTransform() {\r\n    const QMLTranslate = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Translate\");\r\n    const QMLRotation = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Rotation\");\r\n    const QMLScale = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"Scale\");\r\n    let transform = `rotate(${this.rotation}deg) scale(${this.scale})`;\r\n    let filter = \"\";\r\n    const transformStyle = \"preserve-3d\";\r\n\r\n    for (let i = 0; i < this.transform.length; i++) {\r\n      const t = this.transform[i];\r\n      if (t instanceof QMLRotation) {\r\n        const ax = t.axis;\r\n        transform += ` rotate3d(${ax.x}, ${ax.y}, ${ax.z}, ${ax.angle}deg)`;\r\n      } else if (t instanceof QMLScale) {\r\n        transform += ` scale(${t.xScale}, ${t.yScale})`;\r\n      } else if (t instanceof QMLTranslate) {\r\n        transform += ` translate(${t.x}px, ${t.y}px)`;\r\n      } else if (typeof t.transformType !== \"undefined\") {\r\n        if (t.transformType === \"filter\") {\r\n          filter += `${t.operation}(${t.parameters}) `;\r\n        }\r\n      } else if (typeof t === \"string\") {\r\n        transform += t;\r\n      }\r\n    }\r\n    if (typeof this.z === \"number\") {\r\n      transform += ` translate3d(0, 0, ${this.z}px)`;\r\n      // should also consider z as zIndex for stacking order behaviour of qml\r\n      // see http://doc.qt.io/qt-5/qml-qtquick-item.html#z-prop\r\n      this.dom.style.zIndex = this.z;\r\n    }\r\n    this.dom.style.transform = transform;\r\n    this.dom.style.transformStyle = transformStyle;\r\n    this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\r\n    this.dom.style.webkitTransformStyle = transformStyle;\r\n    this.dom.style.msTransform = transform;     // IE\r\n    this.dom.style.filter = filter;\r\n    this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\r\n  }\r\n  Component$onCompleted_() {\r\n    this.$calculateOpacity();\r\n  }\r\n  $calculateOpacity() {\r\n    // TODO: reset all opacity on layer.enabled changed\r\n    /*\r\n    if (false) { // TODO: check layer.enabled\r\n      this.css.opacity = this.opacity;\r\n    }\r\n    */\r\n    const parentOpacity = this.$parent && this.$parent.$opacity || 1;\r\n    this.$opacity = this.opacity * parentOpacity;\r\n    if (this.impl) {\r\n      this.impl.style.opacity = this.$opacity;\r\n    }\r\n  }\r\n  $onImplicitWidthChanged() {\r\n    if (this.$isUsingImplicitWidth) {\r\n      this.width = this.implicitWidth;\r\n      this.$isUsingImplicitWidth = true;\r\n    }\r\n  }\r\n  $onImplicitHeightChanged() {\r\n    if (this.$isUsingImplicitHeight) {\r\n      this.height = this.implicitHeight;\r\n      this.$isUsingImplicitHeight = true;\r\n    }\r\n  }\r\n  $updateHGeometry(newVal, oldVal, propName) {\r\n    const anchors = this.anchors || this;\r\n    if (this.$updatingHGeometry) {\r\n      return;\r\n    }\r\n    this.$updatingHGeometry = true;\r\n\r\n    const flags = QmlWeb.Signal.UniqueConnection;\r\n    const lM = anchors.leftMargin || anchors.margins;\r\n    const rM = anchors.rightMargin || anchors.margins;\r\n    const w = this.width;\r\n    const left = this.parent ? this.parent.left : 0;\r\n\r\n    // Width\r\n    if (propName === \"width\") {\r\n      this.$isUsingImplicitWidth = false;\r\n    }\r\n\r\n    // Position TODO: Layouts\r\n\r\n    const u = {}; // our update object\r\n\r\n    if (anchors.fill !== undefined) {\r\n      const fill = anchors.fill;\r\n      const props = fill.$properties;\r\n      props.left.changed.connect(this, this.$updateHGeometry, flags);\r\n      props.right.changed.connect(this, this.$updateHGeometry, flags);\r\n      props.width.changed.connect(this, this.$updateHGeometry, flags);\r\n\r\n      this.$isUsingImplicitWidth = false;\r\n      u.width = fill.width - lM - rM;\r\n      u.x = fill.left - left + lM;\r\n      u.left = fill.left + lM;\r\n      u.right = fill.right - rM;\r\n      u.horizontalCenter = (u.left + u.right) / 2;\r\n    } else if (anchors.centerIn !== undefined) {\r\n      const horizontalCenter = anchors.centerIn.$properties.horizontalCenter;\r\n      horizontalCenter.changed.connect(this, this.$updateHGeometry, flags);\r\n\r\n      u.horizontalCenter = anchors.centerIn.horizontalCenter;\r\n      u.x = u.horizontalCenter - w / 2 - left;\r\n      u.left = u.horizontalCenter - w / 2;\r\n      u.right = u.horizontalCenter + w / 2;\r\n    } else if (anchors.left !== undefined) {\r\n      u.left = anchors.left + lM;\r\n      if (anchors.right !== undefined) {\r\n        u.right = anchors.right - rM;\r\n        this.$isUsingImplicitWidth = false;\r\n        u.width = u.right - u.left;\r\n        u.x = u.left - left;\r\n        u.horizontalCenter = (u.right + u.left) / 2;\r\n      } else if (anchors.horizontalCenter !== undefined) {\r\n        u.horizontalCenter = anchors.horizontalCenter;\r\n        this.$isUsingImplicitWidth = false;\r\n        u.width = (u.horizontalCenter - u.left) * 2;\r\n        u.x = u.left - left;\r\n        u.right = 2 * u.horizontalCenter - u.left;\r\n      } else {\r\n        u.x = u.left - left;\r\n        u.right = u.left + w;\r\n        u.horizontalCenter = u.left + w / 2;\r\n      }\r\n    } else if (anchors.right !== undefined) {\r\n      u.right = anchors.right - rM;\r\n      if (anchors.horizontalCenter !== undefined) {\r\n        u.horizontalCenter = anchors.horizontalCenter;\r\n        this.$isUsingImplicitWidth = false;\r\n        u.width = (u.right - u.horizontalCenter) * 2;\r\n        u.x = 2 * u.horizontalCenter - u.right - left;\r\n        u.left = 2 * u.horizontalCenter - u.right;\r\n      } else {\r\n        u.x = u.right - w - left;\r\n        u.left = u.right - w;\r\n        u.horizontalCenter = u.right - w / 2;\r\n      }\r\n    } else if (anchors.horizontalCenter !== undefined) {\r\n      u.horizontalCenter = anchors.horizontalCenter;\r\n      u.x = u.horizontalCenter - w / 2 - left;\r\n      u.left = u.horizontalCenter - w / 2;\r\n      u.right = u.horizontalCenter + w / 2;\r\n    } else {\r\n      if (this.parent) {\r\n        const leftProp = this.parent.$properties.left;\r\n        leftProp.changed.connect(this, this.$updateHGeometry, flags);\r\n      }\r\n\r\n      u.left = this.x + left;\r\n      u.right = u.left + w;\r\n      u.horizontalCenter = u.left + w / 2;\r\n    }\r\n\r\n    for (const key in u) {\r\n      this[key] = u[key];\r\n    }\r\n\r\n    this.$updatingHGeometry = false;\r\n\r\n    if (this.parent) this.$updateChildrenRect(this.parent);\r\n  }\r\n  $updateVGeometry(newVal, oldVal, propName) {\r\n    const anchors = this.anchors || this;\r\n    if (this.$updatingVGeometry) {\r\n      return;\r\n    }\r\n    this.$updatingVGeometry = true;\r\n\r\n    const flags = QmlWeb.Signal.UniqueConnection;\r\n    const tM = anchors.topMargin || anchors.margins;\r\n    const bM = anchors.bottomMargin || anchors.margins;\r\n    const h = this.height;\r\n    const top = this.parent ? this.parent.top : 0;\r\n\r\n    // HeighttopProp\r\n    if (propName === \"height\") {\r\n      this.$isUsingImplicitHeight = false;\r\n    }\r\n\r\n    // Position TODO: Layouts\r\n\r\n    const u = {}; // our update object\r\n\r\n    if (anchors.fill !== undefined) {\r\n      const fill = anchors.fill;\r\n      const props = fill.$properties;\r\n      props.top.changed.connect(this, this.$updateVGeometry, flags);\r\n      props.bottom.changed.connect(this, this.$updateVGeometry, flags);\r\n      props.height.changed.connect(this, this.$updateVGeometry, flags);\r\n\r\n      this.$isUsingImplicitHeight = false;\r\n      u.height = fill.height - tM - bM;\r\n      u.y = fill.top - top + tM;\r\n      u.top = fill.top + tM;\r\n      u.bottom = fill.bottom - bM;\r\n      u.verticalCenter = (u.top + u.bottom) / 2;\r\n    } else if (anchors.centerIn !== undefined) {\r\n      const verticalCenter = anchors.centerIn.$properties.verticalCenter;\r\n      verticalCenter.changed.connect(this, this.$updateVGeometry, flags);\r\n\r\n      u.verticalCenter = anchors.centerIn.verticalCenter;\r\n      u.y = u.verticalCenter - h / 2 - top;\r\n      u.top = u.verticalCenter - h / 2;\r\n      u.bottom = u.verticalCenter + h / 2;\r\n    } else if (anchors.top !== undefined) {\r\n      u.top = anchors.top + tM;\r\n      if (anchors.bottom !== undefined) {\r\n        u.bottom = anchors.bottom - bM;\r\n        this.$isUsingImplicitHeight = false;\r\n        u.height = u.bottom - u.top;\r\n        u.y = u.top - top;\r\n        u.verticalCenter = (u.bottom + u.top) / 2;\r\n      } else if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\r\n        this.$isUsingImplicitHeight = false;\r\n        u.height = (u.verticalCenter - u.top) * 2;\r\n        u.y = u.top - top;\r\n        u.bottom = 2 * u.verticalCenter - u.top;\r\n      } else {\r\n        u.y = u.top - top;\r\n        u.bottom = u.top + h;\r\n        u.verticalCenter = u.top + h / 2;\r\n      }\r\n    } else if (anchors.bottom !== undefined) {\r\n      u.bottom = anchors.bottom - bM;\r\n      if ((u.verticalCenter = anchors.verticalCenter) !== undefined) {\r\n        this.$isUsingImplicitHeight = false;\r\n        u.height = (u.bottom - u.verticalCenter) * 2;\r\n        u.y = 2 * u.verticalCenter - u.bottom - top;\r\n        u.top = 2 * u.verticalCenter - u.bottom;\r\n      } else {\r\n        u.y = u.bottom - h - top;\r\n        u.top = u.bottom - h;\r\n        u.verticalCenter = u.bottom - h / 2;\r\n      }\r\n    } else if (anchors.verticalCenter !== undefined) {\r\n      u.verticalCenter = anchors.verticalCenter;\r\n      u.y = u.verticalCenter - h / 2 - top;\r\n      u.top = u.verticalCenter - h / 2;\r\n      u.bottom = u.verticalCenter + h / 2;\r\n    } else {\r\n      if (this.parent) {\r\n        const topProp = this.parent.$properties.top;\r\n        topProp.changed.connect(this, this.$updateVGeometry, flags);\r\n      }\r\n\r\n      u.top = this.y + top;\r\n      u.bottom = u.top + h;\r\n      u.verticalCenter = u.top + h / 2;\r\n    }\r\n\r\n    for (const key in u) {\r\n      this[key] = u[key];\r\n    }\r\n\r\n    this.$updatingVGeometry = false;\r\n\r\n    if (this.parent) this.$updateChildrenRect(this.parent);\r\n  }\r\n  $updateChildrenRect(component) {\r\n    if (!component || !component.children || component.children.length === 0) {\r\n      return;\r\n    }\r\n    const children = component.children;\r\n\r\n    let maxWidth = 0;\r\n    let maxHeight = 0;\r\n    let minX = children.length > 0 ? children[0].x : 0;\r\n    let minY = children.length > 0 ? children[0].y : 0;\r\n\r\n    for (let i = 0; i < children.length; i++) {\r\n      const child = children[i];\r\n      maxWidth = Math.max(maxWidth, child.x + child.width);\r\n      maxHeight = Math.max(maxHeight, child.y + child.heighth);\r\n      minX = Math.min(minX, child.x);\r\n      minY = Math.min(minX, child.y);\r\n    }\r\n\r\n    component.childrenRect.x = minX;\r\n    component.childrenRect.y = minY;\r\n    component.childrenRect.width = maxWidth;\r\n    component.childrenRect.height = maxHeight;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ListElement\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    for (const i in meta.object) {\r\n      if (i[0] !== \"$\") {\r\n        QmlWeb.createProperty(\"variant\", this, i);\r\n      }\r\n    }\r\n    QmlWeb.applyProperties(meta.object, this, this, this.$context);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ListModel\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    count: \"int\",\r\n    $items: \"list\"\r\n  },\r\n  defaultProperty: \"$items\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$firstItem = true;\r\n    this.$itemsChanged.connect(this, this.$on$itemsChanged);\r\n    this.$model = new QmlWeb.JSItemModel();\r\n    this.$model.data = (index, role) => this.$items[index][role];\r\n    this.$model.rowCount = () => this.$items.length;\r\n  }\r\n  $on$itemsChanged(newVal) {\r\n    this.count = this.$items.length;\r\n    if (this.$firstItem && newVal.length > 0) {\r\n      const QMLListElement = QmlWeb.getConstructor(\r\n        \"QtQuick\", \"2.0\", \"ListElement\"\r\n      );\r\n      this.$firstItem = false;\r\n      const roleNames = [];\r\n      let dict = newVal[0];\r\n      if (dict instanceof QMLListElement) {\r\n        dict = dict.$properties;\r\n      }\r\n      for (const i in dict) {\r\n        if (i !== \"index\") {\r\n          roleNames.push(i);\r\n        }\r\n      }\r\n      this.$model.setRoleNames(roleNames);\r\n    }\r\n  }\r\n  append(dict) {\r\n    const index = this.$items.length;\r\n    let c = 0;\r\n\r\n    if (dict instanceof Array) {\r\n      for (const key in dict) {\r\n        this.$items.push(dict[key]);\r\n        c++;\r\n      }\r\n    } else {\r\n      this.$items.push(dict);\r\n      c = 1;\r\n    }\r\n\r\n    this.$itemsChanged(this.$items);\r\n    this.$model.rowsInserted(index, index + c);\r\n  }\r\n  clear() {\r\n    this.$items.length = 0;\r\n    this.count = 0;\r\n    this.$model.modelReset();\r\n  }\r\n  get(index) {\r\n    return this.$items[index];\r\n  }\r\n  insert(index, dict) {\r\n    this.$items.splice(index, 0, dict);\r\n    this.$itemsChanged(this.$items);\r\n    this.$model.rowsInserted(index, index + 1);\r\n  }\r\n  move(from, to, n) {\r\n    const vals = this.$items.splice(from, n);\r\n    for (let i = 0; i < vals.length; i++) {\r\n      this.$items.splice(to + i, 0, vals[i]);\r\n    }\r\n    this.$model.rowsMoved(from, from + n, to);\r\n  }\r\n  remove(index) {\r\n    this.$items.splice(index, 1);\r\n    this.$model.rowsRemoved(index, index + 1);\r\n    this.count = this.$items.length;\r\n  }\r\n  set(index, dict) {\r\n    this.$items[index] = dict;\r\n    this.$model.dataChanged(index, index);\r\n  }\r\n  setProperty(index, property, value) {\r\n    this.$items[index][property] = value;\r\n    this.$model.dataChanged(index, index);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ListView\",\r\n  versions: /.*/,\r\n  baseClass: \"Repeater\",\r\n  properties: {\r\n    orientation: \"enum\",\r\n    spacing: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    this.modelChanged.connect(this, this.$styleChanged);\r\n    this.delegateChanged.connect(this, this.$styleChanged);\r\n    this.orientationChanged.connect(this, this.$styleChanged);\r\n    this.spacingChanged.connect(this, this.$styleChanged);\r\n    this._childrenInserted.connect(this, this.$applyStyleOnItem);\r\n  }\r\n  container() {\r\n    return this;\r\n  }\r\n  $applyStyleOnItem($item) {\r\n    const Qt = QmlWeb.Qt;\r\n    $item.dom.style.position = \"initial\";\r\n    if (this.orientation === Qt.Horizontal) {\r\n      $item.dom.style.display = \"inline-block\";\r\n      if ($item !== this.$items[0]) {\r\n        $item.dom.style[\"margin-left\"] = `${this.spacing}px`;\r\n      }\r\n    } else {\r\n      $item.dom.style.display = \"block\";\r\n      if ($item !== this.$items[0]) {\r\n        $item.dom.style[\"margin-top\"] = `${this.spacing}px`;\r\n      }\r\n    }\r\n  }\r\n  $styleChanged() {\r\n    for (let i = 0; i < this.$items.length; ++i) {\r\n      this.$applyStyleOnItem(this.$items[i]);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Loader\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    active: { type: \"bool\", initialValue: true },\r\n    asynchronous: \"bool\",\r\n    item: \"var\",\r\n    progress: \"real\",\r\n    source: \"url\",\r\n    sourceComponent: \"Component\",\r\n    status: { type: \"enum\", initialValue: 1 }\r\n  },\r\n  signals: {\r\n    loaded: []\r\n  },\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$sourceUrl = \"\";\r\n\r\n    this.activeChanged.connect(this, this.$onActiveChanged);\r\n    this.sourceChanged.connect(this, this.$onSourceChanged);\r\n    this.sourceComponentChanged.connect(this, this.$onSourceComponentChanged);\r\n    this.widthChanged.connect(this, this.$updateGeometry);\r\n    this.heightChanged.connect(this, this.$updateGeometry);\r\n  }\r\n  $onActiveChanged() {\r\n    if (!this.active) {\r\n      this.$unload();\r\n      return;\r\n    }\r\n    if (this.source) {\r\n      this.$onSourceChanged(this.source);\r\n    } else if (this.sourceComponent) {\r\n      this.$onSourceComponentChanged(this.sourceComponent);\r\n    }\r\n  }\r\n  $onSourceChanged(fileName) {\r\n    // TODO\r\n    // if (fileName == this.$sourceUrl && this.item !== undefined) return;\r\n    if (!this.active) return;\r\n    this.$unload();\r\n\r\n    if (!fileName) {\r\n      this.sourceComponent = null;\r\n      this.$sourceUrl = fileName;\r\n      return;\r\n    }\r\n\r\n    const tree = QmlWeb.engine.loadComponent(fileName);\r\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n    const meta = { object: tree, context: this.$context, parent: this };\r\n    const qmlComponent = new QMLComponent(meta);\r\n    qmlComponent.$basePath = QmlWeb.engine.extractBasePath(tree.$file);\r\n    qmlComponent.$imports = tree.$imports;\r\n    qmlComponent.$file = tree.$file;\r\n    QmlWeb.engine.loadImports(tree.$imports, qmlComponent.$basePath,\r\n      qmlComponent.importContextId);\r\n    const loadedComponent = this.$createComponentObject(qmlComponent, this);\r\n    this.sourceComponent = loadedComponent;\r\n    this.$sourceUrl = fileName;\r\n  }\r\n  $onSourceComponentChanged(newItem) {\r\n    if (!this.active) return;\r\n    this.$unload();\r\n\r\n    if (!newItem) {\r\n      this.item = null;\r\n      return;\r\n    }\r\n\r\n    const QMLComponent = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"Component\");\r\n    let qmlComponent = newItem;\r\n    if (newItem instanceof QMLComponent) {\r\n      qmlComponent = newItem.$createObject(this, {}, this);\r\n    }\r\n    qmlComponent.parent = this;\r\n    this.item = qmlComponent;\r\n    this.$updateGeometry();\r\n    if (this.item) {\r\n      this.loaded();\r\n    }\r\n  }\r\n  setSource(url, options) {\r\n    this.$sourceUrl = url;\r\n    this.props = options;\r\n    this.source = url;\r\n  }\r\n  $unload() {\r\n    if (!this.item) return;\r\n    this.item.$delete();\r\n    this.item.parent = undefined;\r\n    this.item = undefined;\r\n  }\r\n  $callOnCompleted(child) {\r\n    child.Component.completed();\r\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\r\n    for (let i = 0; i < child.$tidyupList.length; i++) {\r\n      if (child.$tidyupList[i] instanceof QMLBaseObject) {\r\n        this.$callOnCompleted(child.$tidyupList[i]);\r\n      }\r\n    }\r\n  }\r\n  $createComponentObject(qmlComponent, parent) {\r\n    const newComponent = qmlComponent.createObject(parent);\r\n    if (QmlWeb.engine.operationState !== QmlWeb.QMLOperationState.Init) {\r\n      // We don't call those on first creation, as they will be called\r\n      // by the regular creation-procedures at the right time.\r\n      QmlWeb.engine.$initializePropertyBindings();\r\n      this.$callOnCompleted(newComponent);\r\n    }\r\n    return newComponent;\r\n  }\r\n  $updateGeometry() {\r\n    // Loader size doesn't exist\r\n    if (!this.width) {\r\n      this.width = this.item ? this.item.width : 0;\r\n    } else if (this.item) {\r\n      // Loader size exists\r\n      this.item.width = this.width;\r\n    }\r\n\r\n    if (!this.height) {\r\n      this.height = this.item ? this.item.height : 0;\r\n    } else if (this.item) {\r\n      // Loader size exists\r\n      this.item.height = this.height;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"MouseArea\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    acceptedButtons: { type: \"variant\", initialValue: 1 }, // Qt.LeftButton\r\n    enabled: { type: \"bool\", initialValue: true },\r\n    hoverEnabled: \"bool\",\r\n    mouseX: \"real\",\r\n    mouseY: \"real\",\r\n    pressed: \"bool\",\r\n    containsMouse: \"bool\",\r\n    pressedButtons: { type: \"variant\", initialValue: 0 },\r\n    cursorShape: \"enum\" // Qt.ArrowCursor\r\n  },\r\n  signals: {\r\n    clicked: [{ type: \"variant\", name: \"mouse\" }],\r\n    entered: [],\r\n    exited: [],\r\n    positionChanged: [{ type: \"variant\", name: \"mouse\" }],\r\n    wheel: [{ type: \"variant\", name: \"wheel\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.dom.style.pointerEvents = \"all\";\r\n\r\n    // IE does not handle mouse clicks to transparent divs, so we have\r\n    // to set a background color and make it invisible using opacity\r\n    // as that doesn't affect the mouse handling.\r\n    this.dom.style.backgroundColor = \"white\";\r\n    this.dom.style.opacity = 0;\r\n\r\n    this.cursorShapeChanged.connect(this, this.$onCursorShapeChanged);\r\n\r\n    this.dom.addEventListener(\"click\", e => this.$handleClick(e));\r\n    this.dom.addEventListener(\"contextmenu\", e => this.$handleClick(e));\r\n    const handleMouseMove = e => {\r\n      if (!this.enabled || !this.hoverEnabled && !this.pressed) return;\r\n      this.$handlePositionChanged(e);\r\n    };\r\n    const handleMouseUp = () => {\r\n      this.pressed = false;\r\n      this.pressedButtons = 0;\r\n      document.removeEventListener(\"mouseup\", handleMouseUp);\r\n      this.$clientTransform = undefined;\r\n      document.removeEventListener(\"mousemove\", handleMouseMove);\r\n    };\r\n    this.dom.addEventListener(\"mousedown\", e => {\r\n      if (!this.enabled) return;\r\n      // Handle scale and translate transformations\r\n      const boundingRect = this.dom.getBoundingClientRect();\r\n      this.$clientTransform = {\r\n        x: boundingRect.left,\r\n        y: boundingRect.top,\r\n        xScale: this.width ?\r\n          (boundingRect.right - boundingRect.left) / this.width : 1,\r\n        yScale: this.height ?\r\n          (boundingRect.bottom - boundingRect.top) / this.height : 1\r\n      };\r\n      const mouse = this.$eventToMouse(e);\r\n      this.mouseX = mouse.x;\r\n      this.mouseY = mouse.y;\r\n      this.pressed = true;\r\n      this.pressedButtons = mouse.button;\r\n      document.addEventListener(\"mouseup\", handleMouseUp);\r\n      document.addEventListener(\"mousemove\", handleMouseMove);\r\n    });\r\n    this.dom.addEventListener(\"mouseover\", () => {\r\n      this.containsMouse = true;\r\n      this.entered();\r\n    });\r\n    this.dom.addEventListener(\"mouseout\", () => {\r\n      this.containsMouse = false;\r\n      this.exited();\r\n    });\r\n    // This is to emit positionChanged for `hoverEnabled` only. When `pressed`,\r\n    // `positionChanged` is handled by a temporary `mousemove` event listener\r\n    // on `document`.\r\n    this.dom.addEventListener(\"mousemove\", e => {\r\n      if (!this.enabled || !this.hoverEnabled || this.pressed) return;\r\n      this.$handlePositionChanged(e);\r\n    });\r\n    this.dom.addEventListener(\"wheel\", e => {\r\n      this.$handleWheel(e);\r\n    });\r\n  }\r\n  $onCursorShapeChanged() {\r\n    this.dom.style.cursor = this.$cursorShapeToCSS();\r\n  }\r\n  $handlePositionChanged(e) {\r\n    const mouse = this.$eventToMouse(e);\r\n    this.mouseX = mouse.x;\r\n    this.mouseY = mouse.y;\r\n    this.positionChanged(mouse);\r\n  }\r\n  $handleWheel(e) {\r\n    const wheel = this.$eventToMouse(e);\r\n    wheel.angleDelta = { x: e.deltaX, y: e.deltaY };\r\n    wheel.accepted = false;\r\n\r\n    this.wheel(wheel);\r\n\r\n    if (wheel.accepted) {\r\n      e.stopPropagation();\r\n      e.preventDefault();\r\n    }\r\n  }\r\n  $handleClick(e) {\r\n    const mouse = this.$eventToMouse(e);\r\n    if (this.enabled && this.acceptedButtons & mouse.button) {\r\n      this.clicked(mouse);\r\n    }\r\n    // This decides whether to show the browser's context menu on right click or\r\n    // not\r\n    return !(this.acceptedButtons & QmlWeb.Qt.RightButton);\r\n  }\r\n  $eventToMouse(e) {\r\n    const Qt = QmlWeb.Qt;\r\n    const mouse = {\r\n      accepted: true,\r\n      button: e.button === 0 ? Qt.LeftButton :\r\n              e.button === 1 ? Qt.MiddleButton :\r\n              e.button === 2 ? Qt.RightButton :\r\n              0,\r\n      modifiers: e.ctrlKey * Qt.CtrlModifier\r\n               | e.altKey * Qt.AltModifier\r\n               | e.shiftKey * Qt.ShiftModifier\r\n               | e.metaKey * Qt.MetaModifier\r\n    };\r\n    if (this.$clientTransform) {\r\n      // Handle scale and translate transformations\r\n      mouse.x = (e.clientX - this.$clientTransform.x)\r\n        / this.$clientTransform.xScale;\r\n      mouse.y = (e.clientY - this.$clientTransform.y)\r\n        / this.$clientTransform.yScale;\r\n    } else {\r\n      mouse.x = e.offsetX || e.layerX;\r\n      mouse.y = e.offsetY || e.layerY;\r\n    }\r\n    return mouse;\r\n  }\r\n\r\n  // eslint-disable-next-line complexity\r\n  $cursorShapeToCSS() {\r\n    const Qt = QmlWeb.Qt;\r\n    switch (this.cursorShape) {\r\n      case Qt.ArrowCursor: return \"default\";\r\n      case Qt.UpArrowCursor: return \"n-resize\";\r\n      case Qt.CrossCursor: return \"crosshair\";\r\n      case Qt.WaitCursor: return \"wait\";\r\n      case Qt.IBeamCursor: return \"text\";\r\n      case Qt.SizeVerCursor: return \"ew-resize\";\r\n      case Qt.SizeHorCursor: return \"ns-resize\";\r\n      case Qt.SizeBDiagCursor: return \"nesw-resize\";\r\n      case Qt.SizeFDiagCursor: return \"nwse-resize\";\r\n      case Qt.SizeAllCursor: return \"all-scroll\";\r\n      case Qt.BlankCursor: return \"none\";\r\n      case Qt.SplitVCursor: return \"row-resize\";\r\n      case Qt.SplitHCursor: return \"col-resize\";\r\n      case Qt.PointingHandCursor: return \"pointer\";\r\n      case Qt.ForbiddenCursor: return \"not-allowed\";\r\n      case Qt.WhatsThisCursor: return \"help\";\r\n      case Qt.BusyCursor: return \"progress\";\r\n      case Qt.OpenHandCursor: return \"grab\";\r\n      case Qt.ClosedHandCursor: return \"grabbing\";\r\n      case Qt.DragCopyCursor: return \"copy\";\r\n      case Qt.DragMoveCursor: return \"move\";\r\n      case Qt.DragLinkCursor: return \"alias\";\r\n      //case Qt.BitmapCursor: return \"auto\";\r\n      //case Qt.CustomCursor: return \"auto\";\r\n    }\r\n    return \"auto\";\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"NumberAnimation\",\r\n  versions: /.*/,\r\n  baseClass: \"PropertyAnimation\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$at = 0;\r\n    this.$loop = 0;\r\n\r\n    QmlWeb.engine.$addTicker((...args) => this.$ticker(...args));\r\n    this.runningChanged.connect(this, this.$onRunningChanged);\r\n  }\r\n  $startLoop() {\r\n    for (const i in this.$actions) {\r\n      const action = this.$actions[i];\r\n      action.from = action.from !== undefined ?\r\n                      action.from :\r\n                      action.target[action.property];\r\n    }\r\n    this.$at = 0;\r\n  }\r\n  $ticker(now, elapsed) {\r\n    if (!this.running && this.$loop !== -1 || this.paused) {\r\n      // $loop === -1 is a marker to just finish this run\r\n      return;\r\n    }\r\n    if (this.$at === 0 && this.$loop === 0 && !this.$actions.length) {\r\n      this.$redoActions();\r\n    }\r\n    this.$at += elapsed / this.duration;\r\n    if (this.$at >= 1) {\r\n      this.complete();\r\n      return;\r\n    }\r\n    for (const i in this.$actions) {\r\n      const action = this.$actions[i];\r\n      const value = action.from + (action.to - action.from) *\r\n                    this.easing.$valueForProgress(this.$at);\r\n      const property = action.target.$properties[action.property];\r\n      property.set(value, QmlWeb.QMLProperty.ReasonAnimation);\r\n    }\r\n  }\r\n  $onRunningChanged(newVal) {\r\n    if (newVal) {\r\n      this.$startLoop();\r\n      this.paused = false;\r\n    } else if (this.alwaysRunToEnd && this.$at < 1) {\r\n      this.$loop = -1; // -1 is used as a marker to stop\r\n    } else {\r\n      this.$loop = 0;\r\n      this.$actions = [];\r\n    }\r\n  }\r\n  complete() {\r\n    for (const i in this.$actions) {\r\n      const action = this.$actions[i];\r\n      const property = action.target.$properties[action.property];\r\n      property.set(action.to, QmlWeb.QMLProperty.ReasonAnimation);\r\n    }\r\n    this.$loop++;\r\n    if (this.$loop === this.loops) {\r\n      this.running = false;\r\n    } else if (!this.running) {\r\n      this.$actions = [];\r\n    } else {\r\n      this.$startLoop(this);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"OpacityAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ParallelAnimation\",\r\n  versions: /.*/,\r\n  baseClass: \"Animation\",\r\n  enums: {\r\n    Animation: { Infinite: Math.Infinite }\r\n  },\r\n  properties: {\r\n    animations: \"list\"\r\n  },\r\n  defaultProperty: \"animations\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$runningAnimations = 0;\r\n\r\n    this.animationsChanged.connect(this, this.$onAnimationsChanged);\r\n\r\n    QmlWeb.engine.$registerStart(() => {\r\n      if (!this.running) return;\r\n      self.running = false; // toggled back by start();\r\n      self.start();\r\n    });\r\n    QmlWeb.engine.$registerStop(() => this.stop());\r\n  }\r\n  $onAnimationsChanged() {\r\n    const flags = QmlWeb.Signal.UniqueConnection;\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      const animation = this.animations[i];\r\n      animation.runningChanged.connect(this, this.$animationFinished, flags);\r\n    }\r\n  }\r\n  $animationFinished(newVal) {\r\n    this.$runningAnimations += newVal ? 1 : -1;\r\n    if (this.$runningAnimations === 0) {\r\n      this.running = false;\r\n    }\r\n  }\r\n  start() {\r\n    if (this.running) return;\r\n    this.running = true;\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      this.animations[i].start();\r\n    }\r\n  }\r\n  stop() {\r\n    if (!this.running) return;\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      this.animations[i].stop();\r\n    }\r\n    this.running = false;\r\n  }\r\n  complete() {\r\n    this.stop();\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"PauseAnimation\",\r\n  versions: /.*/,\r\n  baseClass: \"Animation\",\r\n  properties: {\r\n    duration: { type: \"int\", initialValue: 250 }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$at = 0;\r\n\r\n    QmlWeb.engine.$addTicker((...args) => this.$ticker(...args));\r\n    this.runningChanged.connect(this, this.$onRunningChanged);\r\n  }\r\n  $ticker(now, elapsed) {\r\n    if (!this.running || this.paused) {\r\n      return;\r\n    }\r\n    this.$at += elapsed / this.duration;\r\n    if (this.$at >= 1) {\r\n      this.complete();\r\n    }\r\n  }\r\n  $onRunningChanged(newVal) {\r\n    if (newVal) {\r\n      this.$at = 0;\r\n      this.paused = false;\r\n    }\r\n  }\r\n  complete() {\r\n    this.running = false;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Positioner\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    spacing: \"int\",\r\n    padding: \"int\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.childrenChanged.connect(this, this.$onChildrenChanged);\r\n    this.spacingChanged.connect(this, this.layoutChildren);\r\n    this.childrenChanged.connect(this, this.layoutChildren);\r\n    this.layoutChildren();\r\n  }\r\n  $onChildrenChanged() {\r\n    const flags = QmlWeb.Signal.UniqueConnection;\r\n    for (let i = 0; i < this.children.length; i++) {\r\n      const child = this.children[i];\r\n      child.widthChanged.connect(this, this.layoutChildren, flags);\r\n      child.heightChanged.connect(this, this.layoutChildren, flags);\r\n      child.visibleChanged.connect(this, this.layoutChildren, flags);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"PropertyAnimation\",\r\n  versions: /.*/,\r\n  baseClass: \"Animation\",\r\n  properties: {\r\n    duration: { type: \"int\", initialValue: 250 },\r\n    from: \"real\",\r\n    to: \"real\",\r\n    properties: \"string\",\r\n    property: \"string\",\r\n    target: \"QtObject\",\r\n    targets: \"list\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.easing = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.easing, {\r\n      type: { type: \"enum\", initialValue: this.Easing.Linear },\r\n      amplitude: { type: \"real\", initialValue: 1 },\r\n      overshoot: { type: \"real\", initialValue: 1.70158 },\r\n      period: { type: \"real\", initialValue: 0.3 },\r\n      bezierCurve: \"list\"\r\n    });\r\n\r\n    this.easing.$valueForProgress = function(t) {\r\n      return QmlWeb.$ease(\r\n        this.type, this.period, this.amplitude, this.overshoot, t\r\n      );\r\n    };\r\n\r\n    this.$props = [];\r\n    this.$targets = [];\r\n    this.$actions = [];\r\n\r\n    this.targetChanged.connect(this, this.$redoTargets);\r\n    this.targetsChanged.connect(this, this.$redoTargets);\r\n    this.propertyChanged.connect(this, this.$redoProperties);\r\n    this.propertiesChanged.connect(this, this.$redoProperties);\r\n\r\n    if (meta.object.$on !== undefined) {\r\n      this.property = meta.object.$on;\r\n      this.target = this.$parent;\r\n      this.running = true;\r\n    }\r\n  }\r\n  $redoActions() {\r\n    this.$actions = [];\r\n    for (let i = 0; i < this.$targets.length; i++) {\r\n      for (const j in this.$props) {\r\n        this.$actions.push({\r\n          target: this.$targets[i],\r\n          property: this.$props[j],\r\n          from: this.from,\r\n          to: this.to\r\n        });\r\n      }\r\n    }\r\n  }\r\n  $redoProperties() {\r\n    this.$props = this.properties.split(\",\");\r\n\r\n    // Remove whitespaces\r\n    for (let i = 0; i < this.$props.length; i++) {\r\n      const matches = this.$props[i].match(/\\w+/);\r\n      if (matches) {\r\n        this.$props[i] = matches[0];\r\n      } else {\r\n        this.$props.splice(i, 1);\r\n        i--;\r\n      }\r\n    }\r\n    // Merge properties and property\r\n    if (this.property && this.$props.indexOf(this.property) === -1) {\r\n      this.$props.push(this.property);\r\n    }\r\n  }\r\n  $redoTargets() {\r\n    this.$targets = this.targets.slice();\r\n    if (this.target && this.$targets.indexOf(this.target) === -1) {\r\n      this.$targets.push(this.target);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"PropertyChanges\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    target: \"QtObject\",\r\n    explicit: \"bool\",\r\n    restoreEntryValues: { type: \"bool\", initialValue: true }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$actions = [];\r\n  }\r\n  $setCustomData(property, value) {\r\n    this.$actions.push({ property, value });\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Rectangle\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    color: { type: \"color\", initialValue: \"white\" },\r\n    radius: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.border = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.border, {\r\n      color: { type: \"color\", initialValue: \"black\" },\r\n      width: { type: \"int\", initialValue: 1 }\r\n    });\r\n    this.$borderActive = false;\r\n\r\n    const bg = this.impl = document.createElement(\"div\");\r\n    bg.style.pointerEvents = \"none\";\r\n    bg.style.position = \"absolute\";\r\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = \"0px\";\r\n    bg.style.borderWidth = \"0px\";\r\n    bg.style.borderStyle = \"solid\";\r\n    bg.style.borderColor = this.border.color.$css;\r\n    bg.style.backgroundColor = this.color.$css;\r\n    this.dom.appendChild(bg);\r\n\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n    this.radiusChanged.connect(this, this.$onRadiusChanged);\r\n    this.border.colorChanged.connect(this, this.border$onColorChanged);\r\n    this.border.widthChanged.connect(this, this.border$onWidthChanged);\r\n    this.widthChanged.connect(this, this.$updateBorder);\r\n    this.heightChanged.connect(this, this.$updateBorder);\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.impl.style.backgroundColor = newVal.$css;\r\n  }\r\n  border$onColorChanged(newVal) {\r\n    this.$borderActive = true;\r\n    this.impl.style.borderColor = newVal.$css;\r\n    this.$updateBorder();\r\n  }\r\n  border$onWidthChanged() {\r\n    this.$borderActive = true;\r\n    this.$updateBorder();\r\n  }\r\n  $onRadiusChanged(newVal) {\r\n    this.impl.style.borderRadius = `${newVal}px`;\r\n  }\r\n  $updateBorder() {\r\n    const border = this.$borderActive ? Math.max(0, this.border.width) : 0;\r\n    const style = this.impl.style;\r\n    if (border * 2 > this.width || border * 2 > this.height) {\r\n      // Border is covering the whole background\r\n      style.borderWidth = \"0px\";\r\n      style.borderTopWidth = `${this.height}px`;\r\n    } else {\r\n      style.borderWidth = `${border}px`;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"RegExpValidator\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    regExp: \"var\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n  validate(string) {\r\n    if (!this.regExp) return true;\r\n    return this.regExp.test(string);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Repeater\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    delegate: \"Component\",\r\n    model: { type: \"variant\", initialValue: 0 },\r\n    count: \"int\"\r\n  },\r\n  signals: {\r\n    _childrenInserted: []\r\n  },\r\n  defaultProperty: \"delegate\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.parent = meta.parent;\r\n    // TODO: some (all ?) of the components including Repeater needs to know own\r\n    // parent at creation time. Please consider this major change.\r\n\r\n    this.$completed = false;\r\n    this.$items = []; // List of created items\r\n\r\n    this.modelChanged.connect(this, this.$onModelChanged);\r\n    this.delegateChanged.connect(this, this.$onDelegateChanged);\r\n    this.parentChanged.connect(this, this.$onParentChanged);\r\n  }\r\n  container() {\r\n    return this.parent;\r\n  }\r\n  itemAt(index) {\r\n    return this.$items[index];\r\n  }\r\n  $onModelChanged() {\r\n    this.$applyModel();\r\n  }\r\n  $onDelegateChanged() {\r\n    this.$applyModel();\r\n  }\r\n  $onParentChanged() {\r\n    this.$applyModel();\r\n  }\r\n  $getModel() {\r\n    const QMLListModel = QmlWeb.getConstructor(\"QtQuick\", \"2.0\", \"ListModel\");\r\n    return this.model instanceof QMLListModel ?\r\n            this.model.$model :\r\n            this.model;\r\n  }\r\n  $applyModel() {\r\n    if (!this.delegate || !this.parent) {\r\n      return;\r\n    }\r\n    const model = this.$getModel();\r\n    if (model instanceof QmlWeb.JSItemModel) {\r\n      const flags = QmlWeb.Signal.UniqueConnection;\r\n      model.dataChanged.connect(this, this.$_onModelDataChanged, flags);\r\n      model.rowsInserted.connect(this, this.$_onRowsInserted, flags);\r\n      model.rowsMoved.connect(this, this.$_onRowsMoved, flags);\r\n      model.rowsRemoved.connect(this, this.$_onRowsRemoved, flags);\r\n      model.modelReset.connect(this, this.$_onModelReset, flags);\r\n\r\n      this.$removeChildren(0, this.$items.length);\r\n      this.$insertChildren(0, model.rowCount());\r\n    } else if (typeof model === \"number\") {\r\n      if (this.$items.length > model) {\r\n        // have more than we need\r\n        this.$removeChildren(model, this.$items.length);\r\n      } else {\r\n        // need more\r\n        this.$insertChildren(this.$items.length, model);\r\n      }\r\n    } else if (model instanceof Array) {\r\n      this.$removeChildren(0, this.$items.length);\r\n      this.$insertChildren(0, model.length);\r\n    }\r\n    this.count = this.$items.length;\r\n  }\r\n  $callOnCompleted(child) {\r\n    child.Component.completed();\r\n    const QMLBaseObject = QmlWeb.getConstructor(\"QtQml\", \"2.0\", \"QtObject\");\r\n    for (let i = 0; i < child.$tidyupList.length; i++) {\r\n      if (child.$tidyupList[i] instanceof QMLBaseObject) {\r\n        this.$callOnCompleted(child.$tidyupList[i]);\r\n      }\r\n    }\r\n  }\r\n  $_onModelDataChanged(startIndex, endIndex, roles) {\r\n    const model = this.$getModel();\r\n    const roleNames = roles || model.roleNames;\r\n    for (let index = startIndex; index <= endIndex; index++) {\r\n      const item = this.$items[index];\r\n      const modelData = item.$properties.model;\r\n      for (const i in roleNames) {\r\n        const roleName = roleNames[i];\r\n        const roleData = model.data(index, roleName);\r\n        item.$properties[roleName].set(\r\n          roleData,\r\n          QmlWeb.QMLProperty.ReasonInit,\r\n          item,\r\n          this.model.$context\r\n        );\r\n        modelData[roleName] = roleData;\r\n      }\r\n      item.$properties.model.set(\r\n        modelData,\r\n        QmlWeb.QMLProperty.ReasonInit,\r\n        item,\r\n        this.model.$context\r\n      );\r\n    }\r\n  }\r\n  $_onRowsInserted(startIndex, endIndex) {\r\n    this.$insertChildren(startIndex, endIndex);\r\n    this.count = this.$items.length;\r\n  }\r\n  $_onRowsMoved(sourceStartIndex, sourceEndIndex, destinationIndex) {\r\n    const vals = this.$items.splice(\r\n      sourceStartIndex,\r\n      sourceEndIndex - sourceStartIndex\r\n    );\r\n    for (let i = 0; i < vals.length; i++) {\r\n      this.$items.splice(destinationIndex + i, 0, vals[i]);\r\n    }\r\n    const smallestChangedIndex = sourceStartIndex < destinationIndex ?\r\n                                  sourceStartIndex :\r\n                                  destinationIndex;\r\n    for (let i = smallestChangedIndex; i < this.$items.length; i++) {\r\n      this.$items[i].index = i;\r\n    }\r\n  }\r\n  $_onRowsRemoved(startIndex, endIndex) {\r\n    this.$removeChildren(startIndex, endIndex);\r\n    for (let i = startIndex; i < this.$items.length; i++) {\r\n      this.$items[i].index = i;\r\n    }\r\n    this.count = this.$items.length;\r\n  }\r\n  $_onModelReset() {\r\n    this.$applyModel();\r\n  }\r\n  $insertChildren(startIndex, endIndex) {\r\n    if (endIndex <= 0) {\r\n      this.count = 0;\r\n      return;\r\n    }\r\n\r\n    const QMLOperationState = QmlWeb.QMLOperationState;\r\n    const createProperty = QmlWeb.createProperty;\r\n    const model = this.$getModel();\r\n    let index;\r\n    for (index = startIndex; index < endIndex; index++) {\r\n      const newItem = this.delegate.$createObject(this.parent);\r\n      createProperty(\"int\", newItem, \"index\", { initialValue: index });\r\n\r\n      if (typeof model === \"number\" || model instanceof Array) {\r\n        if (typeof newItem.$properties.modelData === \"undefined\") {\r\n          createProperty(\"variant\", newItem, \"modelData\");\r\n        }\r\n        const value = model instanceof Array ?\r\n                      model[index] :\r\n                      typeof model === \"number\" ? index : \"undefined\";\r\n        newItem.$properties.modelData.set(value, QmlWeb.QMLProperty.ReasonInit,\r\n          newItem, model.$context);\r\n      } else {\r\n        // QML exposes a \"model\" property in the scope that contains all role\r\n        // data.\r\n        const modelData = {};\r\n        for (let i = 0; i < model.roleNames.length; i++) {\r\n          const roleName = model.roleNames[i];\r\n          if (typeof newItem.$properties[roleName] === \"undefined\") {\r\n            createProperty(\"variant\", newItem, roleName);\r\n          }\r\n          const roleData = model.data(index, roleName);\r\n          modelData[roleName] = roleData;\r\n          newItem.$properties[roleName].set(\r\n            roleData, QmlWeb.QMLProperty.ReasonInit,\r\n            newItem, this.model.$context\r\n          );\r\n        }\r\n        if (typeof newItem.$properties.model === \"undefined\") {\r\n          createProperty(\"variant\", newItem, \"model\");\r\n        }\r\n        newItem.$properties.model.set(\r\n          modelData, QmlWeb.QMLProperty.ReasonInit,\r\n          newItem, this.model.$context\r\n        );\r\n      }\r\n\r\n      this.$items.splice(index, 0, newItem);\r\n\r\n      // parent must be set after the roles have been added to newItem scope in\r\n      // case we are outside of QMLOperationState.Init and parentChanged has\r\n      // any side effects that result in those roleNames being referenced.\r\n      newItem.parent = this.parent;\r\n\r\n      // TODO debug this. Without check to Init, Completed sometimes called\r\n      // twice.. But is this check correct?\r\n      if (QmlWeb.engine.operationState !== QMLOperationState.Init &&\r\n          QmlWeb.engine.operationState !== QMLOperationState.Idle) {\r\n        // We don't call those on first creation, as they will be called\r\n        // by the regular creation-procedures at the right time.\r\n        this.$callOnCompleted(newItem);\r\n      }\r\n    }\r\n    if (QmlWeb.engine.operationState !== QMLOperationState.Init) {\r\n      // We don't call those on first creation, as they will be called\r\n      // by the regular creation-procedures at the right time.\r\n      QmlWeb.engine.$initializePropertyBindings();\r\n    }\r\n\r\n    if (index > 0) {\r\n      this.container().childrenChanged();\r\n    }\r\n\r\n    for (let i = endIndex; i < this.$items.length; i++) {\r\n      this.$items[i].index = i;\r\n    }\r\n  }\r\n  $removeChildren(startIndex, endIndex) {\r\n    const removed = this.$items.splice(startIndex, endIndex - startIndex);\r\n    for (const index in removed) {\r\n      removed[index].$delete();\r\n      this.$removeChildProperties(removed[index]);\r\n    }\r\n  }\r\n  $removeChildProperties(child) {\r\n    const signals = QmlWeb.engine.completedSignals;\r\n    signals.splice(signals.indexOf(child.Component.completed), 1);\r\n    for (let i = 0; i < child.children.length; i++) {\r\n      this.$removeChildProperties(child.children[i]);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Rotation\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    angle: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.axis = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.axis, {\r\n      x: \"real\",\r\n      y: \"real\",\r\n      z: { type: \"real\", initialValue: 1 }\r\n    });\r\n\r\n    this.origin = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.origin, {\r\n      x: \"real\",\r\n      y: \"real\"\r\n    });\r\n\r\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.origin.xChanged.connect(this, this.$updateOrigin);\r\n    this.origin.yChanged.connect(this, this.$updateOrigin);\r\n    this.$parent.$updateTransform();\r\n  }\r\n  $updateOrigin() {\r\n    const style = this.$parent.dom.style;\r\n    style.transformOrigin = `${this.origin.x}px ${this.origin.y}px`;\r\n    style.webkitTransformOrigin = `${this.origin.x}px ${this.origin.y}px`;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"RotationAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Row\",\r\n  versions: /.*/,\r\n  baseClass: \"Positioner\",\r\n  properties: {\r\n    layoutDirection: \"enum\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\r\n    this.layoutChildren();\r\n  }\r\n  layoutChildren() {\r\n    let curPos = this.padding;\r\n    let maxHeight = 0;\r\n    // When layoutDirection is RightToLeft we need oposite order\r\n    let i = this.layoutDirection === 1 ? this.children.length - 1 : 0;\r\n    const endPoint = this.layoutDirection === 1 ? -1 : this.children.length;\r\n    const step = this.layoutDirection === 1 ? -1 : 1;\r\n    for (; i !== endPoint; i += step) {\r\n      const child = this.children[i];\r\n      if (!(child.visible && child.width && child.height)) {\r\n        continue;\r\n      }\r\n      maxHeight = child.height > maxHeight ? child.height : maxHeight;\r\n\r\n      child.x = curPos;\r\n      if (this.padding > 0) child.y = this.padding;\r\n\r\n      curPos += child.width + this.spacing;\r\n    }\r\n    this.implicitHeight = maxHeight + this.padding * 2;\r\n    // We want no spacing at the right side\r\n    this.implicitWidth = curPos - this.spacing + this.padding;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Scale\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    xScale: { type: \"real\", initialValue: 1 },\r\n    yScale: { type: \"real\", initialValue: 1 }\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.origin = new QmlWeb.QObject(this);\r\n    QmlWeb.createProperties(this.origin, {\r\n      x: \"real\",\r\n      y: \"real\"\r\n    });\r\n\r\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.origin.xChanged.connect(this, this.$updateOrigin);\r\n    this.origin.yChanged.connect(this, this.$updateOrigin);\r\n\r\n    /* QML default origin is top-left, while CSS default origin is centre, so\r\n     * $updateOrigin must be called to set the initial transformOrigin. */\r\n    this.$updateOrigin();\r\n  }\r\n  $updateOrigin() {\r\n    const style = this.$parent.dom.style;\r\n    style.transformOrigin = `${this.origin.x}px ${this.origin.y}px`;\r\n    style.webkitTransformOrigin = `${this.origin.x}px ${this.origin.y}px`;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ScaleAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"SequentialAnimation\",\r\n  versions: /.*/,\r\n  baseClass: \"Animation\",\r\n  properties: {\r\n    animations: \"list\"\r\n  },\r\n  defaultProperty: \"animations\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.animationsChanged.connect(this, this.$onAnimatonsChanged);\r\n\r\n    QmlWeb.engine.$registerStart(() => {\r\n      if (!this.running) return;\r\n      this.running = false; // toggled back by start();\r\n      this.start();\r\n    });\r\n    QmlWeb.engine.$registerStop(() => self.stop());\r\n  }\r\n  $onAnimatonsChanged() {\r\n    const flags = QmlWeb.Signal.UniqueConnection;\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      const animation = this.animations[i];\r\n      animation.runningChanged.connect(this, this.$nextAnimation, flags);\r\n    }\r\n  }\r\n  $nextAnimation(proceed) {\r\n    if (this.running && !proceed) {\r\n      this.$curIndex++;\r\n      if (this.$curIndex < this.animations.length) {\r\n        const anim = this.animations[this.$curIndex];\r\n        console.log(\"nextAnimation\", this, this.$curIndex, anim);\r\n        anim.start();\r\n      } else {\r\n        this.$passedLoops++;\r\n        if (this.$passedLoops >= this.loops) {\r\n          this.complete();\r\n        } else {\r\n          this.$curIndex = -1;\r\n          this.$nextAnimation();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  start() {\r\n    if (this.running) return;\r\n    this.running = true;\r\n    this.$curIndex = -1;\r\n    this.$passedLoops = 0;\r\n    this.$nextAnimation();\r\n  }\r\n  stop() {\r\n    if (!this.running) return;\r\n    this.running = false;\r\n    if (this.$curIndex < this.animations.length) {\r\n      this.animations[this.$curIndex].stop();\r\n    }\r\n  }\r\n  complete() {\r\n    if (!this.running) return;\r\n    if (this.$curIndex < this.animations.length) {\r\n      // Stop current animation\r\n      this.animations[this.$curIndex].stop();\r\n    }\r\n    this.running = false;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ShaderEffect\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    ShaderEffect: {\r\n      NoCulling: 0, BackFaceCulling: 1, FrontFaceCulling: 2,\r\n      Compiled: 0, Uncompiled: 1, Error: 2\r\n    }\r\n  },\r\n  properties: {\r\n    blending: { type: \"bool\", initialValue: true },\r\n    cullMode: \"enum\", // ShaderEffect.NoCulling\r\n    fragmentShader: \"string\",\r\n    log: \"string\",\r\n    mesh: \"var\",\r\n    status: { type: \"enum\", initialValue: 1 }, // ShaderEffect.Uncompiled\r\n    supportsAtlasTextures: \"bool\",\r\n    vertexShader: \"string\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"ShaderEffectSource\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    ShaderEffectSource: {\r\n      Alpha: 0x6406, RGB: 0x6407, RGBA: 0x6408,\r\n      NoMirroring: 0, MirrorHorizontally: 1, MirrorVertically: 2,\r\n      ClampToEdge: 0, RepeatHorizontally: 1, RepeatVertically: 2, Repeat: 3\r\n    }\r\n  },\r\n  properties: {\r\n    format: { type: \"enum\", initialValue: 0x6408 }, // ShaderEffectSource.RGBA\r\n    hideSource: \"bool\",\r\n    live: { type: \"bool\", initialValue: true },\r\n    mipmap: \"bool\",\r\n    recursive: \"bool\",\r\n    sourceItem: \"Item\",\r\n    sourceRect: \"rect\",\r\n    textureMirroring: { type: \"enum\", initialValue: 2 }, // MirrorVertically\r\n    textureSize: \"size\",\r\n    wrapMode: \"enum\" // ShaderEffectSource.ClampToEdge\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO\r\n  }\r\n  scheduleUpdate() {\r\n    // TODO\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"State\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    name: \"string\",\r\n    changes: \"list\",\r\n    extend: \"string\",\r\n    when: \"bool\"\r\n  },\r\n  defaultProperty: \"changes\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$item = this.$parent;\r\n\r\n    this.whenChanged.connect(this, this.$onWhenChanged);\r\n  }\r\n  $getAllChanges() {\r\n    if (this.extend) {\r\n      /* ECMAScript 2015. TODO: polyfill Array?\r\n      const base = this.$item.states.find(state => state.name === this.extend);\r\n      */\r\n      const states = this.$item.states;\r\n      const base = states.filter(state => state.name === this.extend)[0];\r\n      if (base) {\r\n        return base.$getAllChanges().concat(this.changes);\r\n      }\r\n      console.error(\"Can't find the state to extend!\");\r\n    }\r\n    return this.changes;\r\n  }\r\n  $onWhenChanged(newVal) {\r\n    if (newVal) {\r\n      this.$item.state = this.name;\r\n    } else if (this.$item.state === this.name) {\r\n      this.$item.state = \"\";\r\n    }\r\n  }\r\n});\r\n","const platformsDetectors = [\r\n  //{ name: \"W8\", regexp: /Windows NT 6\\.2/ },\r\n  //{ name: \"W7\", regexp: /Windows NT 6\\.1/ },\r\n  //{ name: \"Windows\", regexp: /Windows NT/ },\r\n  { name: \"OSX\", regexp: /Macintosh/ }\r\n];\r\n\r\nconst systemPalettes = {};\r\n\r\nQmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"SystemPalette\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    SystemPalette: {\r\n      Active: 0, Inactive: 2, Disabled: 1\r\n    }\r\n  },\r\n  properties: {\r\n    alternateBase: { type: \"color\", readOnly: true },\r\n    base: { type: \"color\", readOnly: true },\r\n    button: { type: \"color\", readOnly: true },\r\n    buttonText: { type: \"color\", readOnly: true },\r\n    dark: { type: \"color\", readOnly: true },\r\n    highlight: { type: \"color\", readOnly: true },\r\n    highlightedText: { type: \"color\", readOnly: true },\r\n    light: { type: \"color\", readOnly: true },\r\n    mid: { type: \"color\", readOnly: true },\r\n    midlight: { type: \"color\", readOnly: true },\r\n    shadow: { type: \"color\", readOnly: true },\r\n    text: { type: \"color\", readOnly: true },\r\n    window: { type: \"color\", readOnly: true },\r\n    windowText: { type: \"color\", readOnly: true },\r\n\r\n    colorGroup: \"enum\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.colorGroupChanged.connect(this, this.$onColorGroupChanged);\r\n\r\n    this.$platform = \"OSX\";\r\n    // Detect OS\r\n    for (let i = 0; i < platformsDetectors.length; ++i) {\r\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\r\n        this.$platform = platformsDetectors[i].name;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.$onColorGroupChanged(this.colorGroup);\r\n  }\r\n  $onColorGroupChanged(newVal) {\r\n    const name = [\"active\", \"disabled\", \"inactive\"][newVal];\r\n    const pallete = systemPalettes[this.$platform][name];\r\n    this.$canEditReadOnlyProperties = true;\r\n    Object.keys(pallete).forEach(key => {\r\n      this[key] = pallete[key];\r\n    });\r\n    delete this.$canEditReadOnlyProperties;\r\n  }\r\n});\r\n\r\nsystemPalettes.OSX = {\r\n  active: {\r\n    alternateBase: \"#f6f6f6\",\r\n    base: \"#ffffff\",\r\n    button: \"#ededed\",\r\n    buttonText: \"#000000\",\r\n    dark: \"#bfbfbf\",\r\n    highlight: \"#fbed73\",\r\n    highlightText: \"#000000\",\r\n    light: \"#ffffff\",\r\n    mid: \"#a9a9a9\",\r\n    midlight: \"#f6f6f6\",\r\n    shadow: \"#8b8b8b\",\r\n    text: \"#000000\",\r\n    window: \"#ededed\",\r\n    windowText: \"#000000\"\r\n  },\r\n  inactive: {\r\n    alternateBase: \"#f6f6f6\",\r\n    base: \"#ffffff\",\r\n    button: \"#ededed\",\r\n    buttonText: \"#000000\",\r\n    dark: \"#bfbfbf\",\r\n    highlight: \"#d0d0d0\",\r\n    highlightText: \"#000000\",\r\n    light: \"#ffffff\",\r\n    mid: \"#a9a9a9\",\r\n    midlight: \"#f6f6f6\",\r\n    shadow: \"#8b8b8b\",\r\n    text: \"#000000\",\r\n    window: \"#ededed\",\r\n    windowText: \"#000000\"\r\n  },\r\n  disabled: {\r\n    alternateBase: \"#f6f6f6\",\r\n    base: \"#ededed\",\r\n    button: \"#ededed\",\r\n    buttonText: \"#949494\",\r\n    dark: \"#bfbfbf\",\r\n    highlight: \"#d0d0d0\",\r\n    highlightText: \"#7f7f7f\",\r\n    light: \"#ffffff\",\r\n    mid: \"#a9a9a9\",\r\n    midlight: \"#f6f6f6\",\r\n    shadow: \"#8b8b8b\",\r\n    text: \"#7f7f7f\",\r\n    window: \"#ededed\",\r\n    windowText: \"#7f7f7f\"\r\n  }\r\n};\r\n\r\nQmlWeb.systemPalettes = systemPalettes;\r\nQmlWeb.platformsDetectors = platformsDetectors;\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Text\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    Text: {\r\n      NoWrap: 0, WordWrap: 1, WrapAnywhere: 2, Wrap: 3,\r\n      WrapAtWordBoundaryOrAnywhere: 4,\r\n      AlignLeft: 1, AlignRight: 2, AlignHCenter: 4, AlignJustify: 8,\r\n      AlignTop: 32, AlignBottom: 64, AlignVCenter: 128,\r\n      AutoText: 2, PlainText: 0, StyledText: 4, RichText: 1,\r\n      Normal: 0, Outline: 1, Raised: 2, Sunken: 3\r\n    }\r\n  },\r\n  properties: {\r\n    color: { type: \"color\", initialValue: \"black\" },\r\n    text: \"string\",\r\n    textFormat: { type: \"enum\", initialValue: 2 }, // Text.AutoText\r\n    font: \"font\",\r\n    lineHeight: \"real\",\r\n    wrapMode: { type: \"enum\", initialValue: 0 }, // Text.NoWrap\r\n    horizontalAlignment: { type: \"enum\", initialValue: 1 }, // Text.AlignLeft\r\n    style: \"enum\",\r\n    styleColor: \"color\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    const fc = this.impl = document.createElement(\"span\");\r\n    fc.style.pointerEvents = \"none\";\r\n    fc.style.width = \"100%\";\r\n    fc.style.height = \"100%\";\r\n    fc.style.whiteSpace = \"pre\";\r\n    this.dom.style.textAlign = \"left\";\r\n    this.dom.appendChild(fc);\r\n\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.textFormatChanged.connect(this, this.$onTextFormatChanged);\r\n    this.lineHeightChanged.connect(this, this.$onLineHeightChanged);\r\n    this.wrapModeChanged.connect(this, this.$onWrapModeChanged);\r\n    this.horizontalAlignmentChanged.connect(this,\r\n                                            this.$onHorizontalAlignmentChanged);\r\n    this.styleChanged.connect(this, this.$onStyleChanged);\r\n    this.styleColorChanged.connect(this, this.$onStyleColorChanged);\r\n\r\n    this.widthChanged.connect(this, this.$onWidthChanged);\r\n    this.fontChanged.connect(this, this.$onFontChanged);\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n  }\r\n  $redrawText() {\r\n    const text = this.text;\r\n    let format = this.textFormat;\r\n    if (format === this.Text.AutoText) {\r\n      // NOTE: this is not the exact same heuristics that Qt uses\r\n      if (/<[a-zA-Z]+(\\s[^>]*)?\\/?>/.test(text)) {\r\n        format = this.Text.StyledText;\r\n      } else {\r\n        format = this.Text.PlainText;\r\n      }\r\n    }\r\n    if (format === this.Text.PlainText) {\r\n      this.impl.innerHTML = \"\";\r\n      this.impl.appendChild(document.createTextNode(text));\r\n    } else {\r\n      // TODO: sanitize StyledText/RichText\r\n      this.impl.innerHTML = text;\r\n    }\r\n    this.$updateImplicit();\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.impl.style.color = newVal.$css;\r\n  }\r\n  $onTextChanged() {\r\n    this.$redrawText();\r\n  }\r\n  $onTextFormatChanged() {\r\n    this.$redrawText();\r\n  }\r\n  $onWidthChanged() {\r\n    this.$updateImplicit();\r\n  }\r\n  $onLineHeightChanged(newVal) {\r\n    this.impl.style.lineHeight = `${newVal}px`;\r\n    this.$updateImplicit();\r\n  }\r\n  $onStyleChanged(newVal) {\r\n    this.$updateShadow(newVal, this.styleColor.$css);\r\n  }\r\n  $onStyleColorChanged(newVal) {\r\n    this.$updateShadow(this.style, newVal.$css);\r\n  }\r\n  $onWrapModeChanged(newVal) {\r\n    const style = this.impl.style;\r\n    switch (newVal) {\r\n      case this.Text.NoWrap:\r\n        style.whiteSpace = \"pre\";\r\n        break;\r\n      case this.Text.WordWrap:\r\n        style.whiteSpace = \"pre-wrap\";\r\n        style.wordWrap = \"normal\";\r\n        break;\r\n      case this.Text.WrapAnywhere:\r\n        style.whiteSpace = \"pre-wrap\";\r\n        style.wordBreak = \"break-all\";\r\n        break;\r\n      case this.Text.Wrap:\r\n      case this.Text.WrapAtWordBoundaryOrAnywhere:\r\n        style.whiteSpace = \"pre-wrap\";\r\n        style.wordWrap = \"break-word\";\r\n    }\r\n    this.$updateJustifyWhiteSpace();\r\n  }\r\n  $onHorizontalAlignmentChanged(newVal) {\r\n    let textAlign = null;\r\n    switch (newVal) {\r\n      case this.Text.AlignLeft:\r\n        textAlign = \"left\";\r\n        break;\r\n      case this.Text.AlignRight:\r\n        textAlign = \"right\";\r\n        break;\r\n      case this.Text.AlignHCenter:\r\n        textAlign = \"center\";\r\n        break;\r\n      case this.Text.AlignJustify:\r\n        textAlign = \"justify\";\r\n        break;\r\n    }\r\n    this.dom.style.textAlign = textAlign;\r\n    this.$updateJustifyWhiteSpace();\r\n  }\r\n  $onFontChanged() {\r\n    this.$updateImplicit();\r\n  }\r\n  Component$onCompleted() {\r\n    this.$updateImplicit();\r\n  }\r\n  $updateImplicit() {\r\n    if (!this.text || !this.dom) {\r\n      this.implicitHeight = this.implicitWidth = 0;\r\n      return;\r\n    }\r\n\r\n    if (!this.$isUsingImplicitWidth) {\r\n      this.implicitWidth = this.impl.offsetWidth;\r\n      this.implicitHeight = this.impl.offsetHeight;\r\n      return;\r\n    }\r\n\r\n    const fc = this.impl;\r\n    const engine = QmlWeb.engine;\r\n    // Need to move the child out of it's parent so that it can properly\r\n    // recalculate it's \"natural\" offsetWidth/offsetHeight\r\n    if (engine.dom === document.body && engine.dom !== engine.domTarget) {\r\n      // Can't use document.body here, as it could have Shadow DOM inside\r\n      // The root is document.body, though, so it's probably not hidden\r\n      engine.domTarget.appendChild(fc);\r\n    } else {\r\n      document.body.appendChild(fc);\r\n    }\r\n    const height = fc.offsetHeight;\r\n    const width = fc.offsetWidth;\r\n    this.dom.appendChild(fc);\r\n\r\n    this.implicitHeight = height;\r\n    this.implicitWidth = width;\r\n  }\r\n  $updateShadow(textStyle, styleColor) {\r\n    const style = this.impl.style;\r\n    switch (textStyle) {\r\n      case 0:\r\n        style.textShadow = \"none\";\r\n        break;\r\n      case 1:\r\n        style.textShadow = [\r\n          `1px 0 0 ${styleColor}`,\r\n          `-1px 0 0 ${styleColor}`,\r\n          `0 1px 0 ${styleColor}`,\r\n          `0 -1px 0 ${styleColor}`\r\n        ].join(\",\");\r\n        break;\r\n      case 2:\r\n        style.textShadow = `1px 1px 0 ${styleColor}`;\r\n        break;\r\n      case 3:\r\n        style.textShadow = `-1px -1px 0 ${styleColor}`;\r\n        break;\r\n    }\r\n  }\r\n  $updateJustifyWhiteSpace() {\r\n    const style = this.impl.style;\r\n    // AlignJustify doesn't work with pre/pre-wrap, so we decide the lesser of\r\n    // the two evils to be ignoring \"\\n\"s inside the text.\r\n    if (this.horizontalAlignment === this.Text.AlignJustify) {\r\n      style.whiteSpace = \"normal\";\r\n    }\r\n    this.$updateImplicit();\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"TextEdit\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  properties: {\r\n    activeFocusOnPress: { type: \"bool\", initialValue: true },\r\n    baseUrl: \"url\",\r\n    canPaste: \"bool\",\r\n    canRedo: \"bool\",\r\n    canUndo: \"bool\",\r\n    color: { type: \"color\", initialValue: \"white\" },\r\n    contentHeight: \"real\",\r\n    contentWidth: \"real\",\r\n    cursorDelegate: \"Component\",\r\n    cursorPosition: \"int\",\r\n    cursorRectangle: \"rect\",\r\n    cursorVisible: { type: \"bool\", initialValue: true },\r\n    effectiveHorizontalAlignment: \"enum\",\r\n    font: \"font\",\r\n    horizontalAlignment: \"enum\",\r\n    hoveredLink: \"string\",\r\n    inputMethodComposing: \"bool\",\r\n    inputMethodHints: \"enum\",\r\n    length: \"int\",\r\n    lineCount: \"int\",\r\n    mouseSelectionMode: \"enum\",\r\n    persistentSelection: \"bool\",\r\n    readOnly: \"bool\",\r\n    renderType: \"enum\",\r\n    selectByKeyboard: { type: \"bool\", initialValue: true },\r\n    selectByMouse: \"bool\",\r\n    selectedText: \"string\",\r\n    selectedTextColor: { type: \"color\", initialValue: \"yellow\" },\r\n    selectionColor: { type: \"color\", initialValue: \"pink\" },\r\n    selectionEnd: \"int\",\r\n    selectionStart: \"int\",\r\n    text: \"string\",\r\n    textDocument: \"TextDocument\",\r\n    textFormat: \"enum\",\r\n    textMargin: \"real\",\r\n    verticalAlignment: \"enum\",\r\n    wrapMode: \"enum\"\r\n  },\r\n  signals: {\r\n    linkActivated: [{ type: \"string\", name: \"link\" }],\r\n    linkHovered: [{ type: \"string\", name: \"link\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // Undo / Redo stacks;\r\n    this.undoStack = [];\r\n    this.undoStackPosition = -1;\r\n    this.redoStack = [];\r\n    this.redoStackPosition = -1;\r\n\r\n    const textarea = this.impl = document.createElement(\"textarea\");\r\n    textarea.style.pointerEvents = \"auto\";\r\n    textarea.style.width = \"100%\";\r\n    textarea.style.height = \"100%\";\r\n    textarea.style.boxSizing = \"border-box\";\r\n    textarea.style.borderWidth = \"0\";\r\n    textarea.style.background = \"none\";\r\n    textarea.style.outline = \"none\";\r\n    textarea.style.resize = \"none\";\r\n    textarea.style.padding = \"0\"; // TODO: padding/*Padding props from Qt 5.6\r\n    // In some browsers text-areas have a margin by default, which distorts\r\n    // the positioning, so we need to manually set it to 0.\r\n    textarea.style.margin = \"0\";\r\n    textarea.disabled = false;\r\n    this.dom.appendChild(textarea);\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.colorChanged.connect(this, this.$onColorChanged);\r\n\r\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\r\n  }\r\n  append(text) {\r\n    this.text += text;\r\n  }\r\n  copy() {\r\n    // TODO\r\n  }\r\n  cut() {\r\n    this.text = this.text(0, this.selectionStart) +\r\n                this.text(this.selectionEnd, this.text.length);\r\n    // TODO\r\n  }\r\n  deselect() {\r\n    //this.selectionStart = -1;\r\n    //this.selectionEnd = -1;\r\n    //this.selectedText = null;\r\n    // TODO\r\n  }\r\n  getFormattedText(start, end) {\r\n    const text = this.text.slice(start, end);\r\n    // TODO\r\n    // process text\r\n    return text;\r\n  }\r\n  getText(start, end) {\r\n    return this.text.slice(start, end);\r\n  }\r\n  insert(/*position, text*/) {\r\n    // TODO\r\n  }\r\n  isRightToLeft(/*start, end*/) {\r\n    // TODO\r\n  }\r\n  linkAt(/*x, y*/) {\r\n    // TODO\r\n  }\r\n  moveCursorSelection(/*x, y*/) {\r\n    // TODO\r\n  }\r\n  paste() {\r\n    // TODO\r\n  }\r\n  positionAt(/*x, y*/) {\r\n    // TODO\r\n  }\r\n  positionToRectangle(/*position*/) {\r\n    // TODO\r\n  }\r\n  redo() {\r\n    // TODO\r\n  }\r\n  remove(/*start, end*/) {\r\n    // TODO\r\n  }\r\n  select(/*start, end*/) {\r\n    // TODO\r\n  }\r\n  selectAll() {\r\n    // TODO\r\n  }\r\n  selectWord() {\r\n    // TODO\r\n  }\r\n  undo() {\r\n    // TODO\r\n  }\r\n  Component$onCompleted() {\r\n    this.selectByKeyboard = !this.readOnly;\r\n    this.impl.readOnly = this.readOnly;\r\n    this.$updateValue();\r\n    this.implicitWidth = this.offsetWidth;\r\n    this.implicitHeight = this.offsetHeight;\r\n  }\r\n  $onTextChanged(newVal) {\r\n    this.impl.value = newVal;\r\n  }\r\n  $onColorChanged(newVal) {\r\n    this.impl.style.color = newVal.$css;\r\n  }\r\n  $updateValue() {\r\n    if (this.text !== this.impl.value) {\r\n      this.text = this.impl.value;\r\n    }\r\n    this.length = this.text.length;\r\n    this.lineCount = this.$getLineCount();\r\n    this.$updateCss();\r\n  }\r\n  // Transfer dom style to firstChild,\r\n  // then clear corresponding dom style\r\n  $updateCss() {\r\n    const supported = [\r\n      \"border\",\r\n      \"borderRadius\",\r\n      \"borderWidth\",\r\n      \"borderColor\",\r\n      \"backgroundColor\",\r\n    ];\r\n    const style = this.impl.style;\r\n    for (let n = 0; n < supported.length; n++) {\r\n      const o = supported[n];\r\n      const v = this.css[o];\r\n      if (v) {\r\n        style[o] = v;\r\n        this.css[o] = null;\r\n      }\r\n    }\r\n  }\r\n  $getLineCount() {\r\n    return this.text.split(/\\n/).length;\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"TextInput\",\r\n  versions: /.*/,\r\n  baseClass: \"Item\",\r\n  enums: {\r\n    TextInput: { Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3 }\r\n  },\r\n  properties: {\r\n    text: \"string\",\r\n    font: \"font\",\r\n    maximumLength: { type: \"int\", initialValue: -1 },\r\n    readOnly: \"bool\",\r\n    validator: \"var\",\r\n    echoMode: \"enum\" // TextInput.Normal\r\n  },\r\n  signals: {\r\n    accepted: []\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    const input = this.impl = document.createElement(\"input\");\r\n    input.type = \"text\";\r\n    input.disabled = true;\r\n    input.style.pointerEvents = \"auto\";\r\n    // In some browsers text-inputs have a margin by default, which distorts\r\n    // the positioning, so we need to manually set it to 0.\r\n    input.style.margin = \"0\";\r\n    input.style.padding = \"0\";\r\n    input.style.width = \"100%\";\r\n    input.style.height = \"100%\";\r\n    this.dom.appendChild(input);\r\n    this.setupFocusOnDom(input);\r\n    input.disabled = false;\r\n\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n    this.textChanged.connect(this, this.$onTextChanged);\r\n    this.echoModeChanged.connect(this, this.$onEchoModeChanged);\r\n    this.maximumLengthChanged.connect(this, this.$onMaximumLengthChanged);\r\n    this.readOnlyChanged.connect(this, this.$onReadOnlyChanged);\r\n    this.Keys.pressed.connect(this, this.Keys$onPressed);\r\n\r\n    this.impl.addEventListener(\"input\", () => this.$updateValue());\r\n  }\r\n  Component$onCompleted() {\r\n    this.implicitWidth = this.impl.offsetWidth;\r\n    this.implicitHeight = this.impl.offsetHeight;\r\n  }\r\n  $onTextChanged(newVal) {\r\n    // We have to check if value actually changes.\r\n    // If we do not have this check, then after user updates text input\r\n    // following occurs: user updates gui text -> updateValue gets called ->\r\n    // textChanged gets called -> gui value updates again -> caret position\r\n    // moves to the right!\r\n    if (this.impl.value !== newVal) {\r\n      this.impl.value = newVal;\r\n    }\r\n  }\r\n  $onEchoModeChanged(newVal) {\r\n    const TextInput = this.TextInput;\r\n    const input = this.impl;\r\n    switch (newVal) {\r\n      case TextInput.Normal:\r\n        input.type = \"text\";\r\n        break;\r\n      case TextInput.Password:\r\n        input.type = \"password\";\r\n        break;\r\n      case TextInput.NoEcho:\r\n        // Not supported, use password, that's nearest\r\n        input.type = \"password\";\r\n        break;\r\n      case TextInput.PasswordEchoOnEdit:\r\n        // Not supported, use password, that's nearest\r\n        input.type = \"password\";\r\n        break;\r\n    }\r\n  }\r\n  $onMaximumLengthChanged(newVal) {\r\n    this.impl.maxLength = newVal < 0 ? null : newVal;\r\n  }\r\n  $onReadOnlyChanged(newVal) {\r\n    this.impl.disabled = newVal;\r\n  }\r\n  Keys$onPressed(e) {\r\n    const Qt = QmlWeb.Qt;\r\n    const submit = e.key === Qt.Key_Return || e.key === Qt.Key_Enter;\r\n    if (submit && this.$testValidator()) {\r\n      this.accepted();\r\n      e.accepted = true;\r\n    }\r\n  }\r\n  $testValidator() {\r\n    if (this.validator) {\r\n      return this.validator.validate(this.text);\r\n    }\r\n    return true;\r\n  }\r\n  $updateValue() {\r\n    if (this.text !== this.impl.value) {\r\n      this.$canEditReadOnlyProperties = true;\r\n      this.text = this.impl.value;\r\n      this.$canEditReadOnlyProperties = false;\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Transition\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    animations: \"list\",\r\n    from: { type: \"string\", initialValue: \"*\" },\r\n    to: { type: \"string\", initialValue: \"*\" },\r\n    reversible: \"bool\"\r\n  },\r\n  defaultProperty: \"animations\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$item = this.$parent;\r\n  }\r\n  $start(actions) {\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      const animation = this.animations[i];\r\n      animation.$actions = [];\r\n      const { $targets, $props, $actions } = animation;\r\n      for (const j in actions) {\r\n        const action = actions[j];\r\n        if (($targets.length === 0 || $targets.indexOf(action.target) !== -1) &&\r\n            ($props.length === 0 || $props.indexOf(action.property) !== -1)) {\r\n          $actions.push(action);\r\n        }\r\n      }\r\n      animation.start();\r\n    }\r\n  }\r\n  $stop() {\r\n    for (let i = 0; i < this.animations.length; i++) {\r\n      this.animations[i].stop();\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"Translate\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  properties: {\r\n    x: \"real\",\r\n    y: \"real\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"UniformAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\",\r\n  properties: {\r\n    uniform: \"string\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"XAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtQuick\",\r\n  name: \"YAnimator\",\r\n  versions: /^2\\./,\r\n  baseClass: \"Animator\"\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtTest\",\r\n  name: \"TestCase\",\r\n  versions: /^1\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    completed: \"bool\",\r\n    name: \"string\",\r\n    optional: \"bool\",\r\n    running: \"bool\",\r\n    when: \"bool\",\r\n    windowShown: \"bool\"\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n    this.Component.completed.connect(this, this.Component$onCompleted);\r\n\r\n    const engine = QmlWeb.engine;\r\n    if (!engine.tests) {\r\n      QmlWeb.engine.tests = {\r\n        name: engine.name || `Run_${Math.random().toString(36).slice(2, 10)}`,\r\n        started: false,\r\n        finished: false,\r\n        duration: 0,\r\n        total: 0,\r\n        completed: 0,\r\n        errors: [],\r\n        stats: {\r\n          pass: 0,\r\n          fail: 0,\r\n          skip: 0\r\n        }\r\n      };\r\n    }\r\n    QmlWeb.engine.tests.total++;\r\n\r\n    this.console = {\r\n      assert: (...a) => console.assert(...a),\r\n      error: (...a) => console.error(`QSYSTEM: ${this.$testId} qml:`, ...a),\r\n      info: (...a) => console.info(`QINFO  : ${this.$testId} qml:`, ...a),\r\n      log: (...a) => console.log(`QDEBUG : ${this.$testId} qml:`, ...a),\r\n      time: (...a) => console.time(...a),\r\n      timeEnd: (...a) => console.timeEnd(...a),\r\n      trace: (...a) => console.trace(...a),\r\n      warn: (...a) => console.warn(`QWARN  : ${this.$testId} qml:`, ...a)\r\n    };\r\n  }\r\n\r\n  Component$onCompleted() {\r\n    const info = QmlWeb.engine.tests;\r\n    if (!info.started) {\r\n      console.log(`********* Start testing of ${info.name} *********`);\r\n      console.log(`Config: Using QmlWeb, ${window.navigator.userAgent}`);\r\n      info.started = true;\r\n    }\r\n\r\n    const keys = Object.keys(this);\r\n    const tests = keys\r\n        .filter(key => key.lastIndexOf(\"test_\", 0) === 0)\r\n        .filter(key => key.indexOf(\"_data\", key.length - 5) === -1)\r\n        .sort();\r\n\r\n    tests.unshift(\"initTestCase\");\r\n    tests.push(\"cleanupTestCase\");\r\n    tests.forEach(test => {\r\n      this.$testId = `${info.name}::${this.name}::${test}()`;\r\n      const special = test === \"initTestCase\" || test === \"cleanupTestCase\";\r\n\r\n      const dstart = performance.now();\r\n      let data;\r\n      if (this[`${test}_data`] && !special) {\r\n        data = this[`${test}_data`]();\r\n        if (!data || !data.length) {\r\n          this.warn(`no data supplied for ${test}() by ${test}_data()`);\r\n          data = [];\r\n        }\r\n      } else if (this.init_data && !special) {\r\n        data = this.init_data();\r\n        if (!data || !data.length) {\r\n          data = undefined;\r\n        }\r\n      }\r\n      if (!data) {\r\n        data = [null];\r\n      }\r\n      const dend = performance.now();\r\n      info.duration += dend - dstart;\r\n\r\n      data.forEach(row => {\r\n        const arg = row ? row.tag : \"\";\r\n        this.$testId = `${info.name}::${this.name}::${test}(${arg})`;\r\n        const start = performance.now();\r\n        let error;\r\n        try {\r\n          if (!special) {\r\n            this.init();\r\n          }\r\n          this[test](row);\r\n        } catch (e) {\r\n          error = e;\r\n        } finally {\r\n          if (!special) {\r\n            this.cleanup();\r\n          }\r\n        }\r\n        const end = performance.now();\r\n        info.duration += end - start;\r\n        if (error && error.skip) {\r\n          info.stats.skip++;\r\n          console.log(`SKIP   : ${this.$testId} ${error.message}`);\r\n        } else if (error) {\r\n          info.stats.fail++;\r\n          info.errors.push(`${this.$testId} ${error.message}`);\r\n          console.log(`FAIL!  : ${this.$testId} ${error.message}`);\r\n          if (\"actual\" in error) {\r\n            console.log(`   Actual   (): ${error.actual}`);\r\n          }\r\n          if (\"expected\" in error) {\r\n            console.log(`   Expected (): ${error.expected}`);\r\n          }\r\n        } else {\r\n          info.stats.pass++;\r\n          console.log(`PASS   : ${this.$testId}`);\r\n        }\r\n      });\r\n\r\n      this.$testId = `${info.name}::UnknownTestFunc()`;\r\n    });\r\n\r\n    // TODO: benchmarks\r\n\r\n    info.completed++;\r\n    if (info.completed === info.total) {\r\n      info.finished = true;\r\n      const { pass, fail, skip } = info.stats;\r\n      const duration = Math.round(info.duration * 100) / 100;\r\n      console.log(\r\n        `Totals: ${pass} passed, ${fail} failed, ${skip} skipped, ${duration}ms`\r\n      );\r\n      console.log(`********* Finished testing of ${info.name} *********`);\r\n    }\r\n  }\r\n\r\n  // No-ops\r\n  init() {}\r\n  initTestCase() {}\r\n  cleanup() {}\r\n  cleanupTestCase() {}\r\n\r\n  // API\r\n  compare(actual, expected, message = \"\") {\r\n    if (actual !== expected) {\r\n      const err = new Error(message);\r\n      err.actual = actual;\r\n      err.expected = expected;\r\n      throw err;\r\n    }\r\n  }\r\n  verify(condition, message = \"\") {\r\n    if (!condition) {\r\n      throw new Error(`'${message}' returned FALSE. ()`);\r\n    }\r\n  }\r\n  fail(message = \"\") {\r\n    throw new Error(message);\r\n  }\r\n  warn(message) {\r\n    console.warn(`WARNING: ${this.$testId} ${message}`);\r\n  }\r\n  skip(message = \"\") {\r\n    const err = new Error(message);\r\n    err.skip = true;\r\n    throw err;\r\n  }\r\n  /*\r\n  expectFail(tag, message) {\r\n    // TODO\r\n  }\r\n  expectFailContinue(tag, message) {\r\n    // TODO\r\n  }\r\n  findChild(parent, objectName) {\r\n    // TODO\r\n    // return QtObject\r\n  }\r\n  fuzzyCompare(actual, expected, delta, message) {\r\n    // TODO\r\n  }\r\n  grabImage(item) {\r\n    if (!window.top || !window.top.callPhantom) {\r\n      this.skip(\"Can't use TestCase::grabImage() without PhantomJS.\");\r\n    }\r\n    // TODO\r\n    return {\r\n      red: (x, y) => {},\r\n      green: (x, y) => {},\r\n      blue: (x, y) => {},\r\n      alpha: (x, y) => {},\r\n      pixel: (x, y) => {},\r\n      equals: image => false\r\n    };\r\n  }\r\n  ignoreWarning(message) {\r\n    // TODO\r\n  }\r\n  sleep(ms) {\r\n    // TODO\r\n  }\r\n  tryCompare(obj, property, expected, timeout, message) {\r\n    // TODO\r\n  }\r\n  wait(ms) {\r\n    // TODO\r\n  }\r\n  waitForRendering(item, timeout = 5000) {\r\n    // TODO\r\n  }\r\n  */\r\n\r\n  // TODO\r\n  /*\r\n  // Events\r\n  keyClick(key, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  keyPress(key, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  keyRelease(key, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseClick(item, x, y, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseDoubleClick(item, x, y, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseDoubleClickSequence(item, x, y, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseDrag(item, x, y, dx, dy, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseMove(item, x, y, delay = -1) {\r\n    // TODO\r\n  }\r\n  mousePress(item, x, y, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseRelease(item, x, y, button, modifiers, delay = -1) {\r\n    // TODO\r\n  }\r\n  mouseWheel(item, x, y, xDelta, yDelta, button, modifiers, delay = -1) {\r\n    // button = Qt.LeftButton, modifiers = Qt.NoModifier\r\n    // TODO\r\n  }\r\n  */\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtWebEngine\",\r\n  name: \"WebEngineView\",\r\n  versions: /^5\\./,\r\n  baseClass: \"QtWebView.WebView\", // It's easier this way\r\n  properties: {\r\n    // TODO\r\n  },\r\n  signals: {\r\n    // TODO\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    // TODO: implement more features on top of WebView\r\n  }\r\n});\r\n","// WARNING: Can have wrong behavior if url is changed while the socket is in\r\n// Connecting state.\r\n// TODO: Recheck everything.\r\n\r\nQmlWeb.registerQmlType({\r\n  module: \"QtWebSockets\",\r\n  name: \"WebSocket\",\r\n  versions: /.*/,\r\n  baseClass: \"QtQml.QtObject\",\r\n  enums: {\r\n    WebSocket: { Connecting: 0, Open: 1, Closing: 2, Closed: 3, Error: 4 }\r\n  },\r\n  properties: {\r\n    active: \"bool\",\r\n    status: { type: \"enum\", initialValue: 3 }, // WebSocket.Closed\r\n    errorString: \"string\",\r\n    url: \"url\"\r\n  },\r\n  signals: {\r\n    textMessageReceived: [{ type: \"string\", name: \"message\" }]\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.$socket = undefined;\r\n    this.$reconnect = false;\r\n\r\n    this.statusChanged.connect(this, this.$onStatusChanged);\r\n    this.activeChanged.connect(this, this.$reconnectSocket);\r\n    this.urlChanged.connect(this, this.$reconnectSocket);\r\n  }\r\n  $onStatusChanged(status) {\r\n    if (status !== this.WebSocket.Error) {\r\n      this.errorString = \"\";\r\n    }\r\n  }\r\n  $connectSocket() {\r\n    this.$reconnect = false;\r\n\r\n    if (!this.url || !this.active) {\r\n      return;\r\n    }\r\n\r\n    this.status = this.WebSocket.Connecting;\r\n    this.$socket = new WebSocket(this.url);\r\n    this.$socket.onopen = () => {\r\n      this.status = this.WebSocket.Open;\r\n    };\r\n    this.$socket.onclose = () => {\r\n      this.status = this.WebSocket.Closed;\r\n      if (this.$reconnect) {\r\n        this.$connectSocket();\r\n      }\r\n    };\r\n    this.$socket.onerror = error => {\r\n      this.errorString = error.message;\r\n      this.status = this.WebSocket.Error;\r\n    };\r\n    this.$socket.onmessage = message => {\r\n      this.textMessageReceived(message.data);\r\n    };\r\n  }\r\n  $reconnectSocket() {\r\n    this.$reconnect = true;\r\n    if (this.status === this.WebSocket.Open) {\r\n      this.status = this.WebSocket.Closing;\r\n      this.$socket.close();\r\n    } else if (this.status !== this.WebSocket.Closing) {\r\n      this.$connectSocket();\r\n    }\r\n  }\r\n  sendTextMessage(message) {\r\n    if (this.status === this.WebSocket.Open) {\r\n      this.$socket.send(message);\r\n    }\r\n  }\r\n});\r\n","QmlWeb.registerQmlType({\r\n  module: \"QtWebView\",\r\n  name: \"WebView\",\r\n  versions: /^1\\./,\r\n  baseClass: \"QtQuick.Item\",\r\n  properties: {\r\n    canGoBack: \"bool\", // TODO\r\n    canGoForward: \"bool\", // TODO\r\n    loadProgress: \"int\",\r\n    loading: \"bool\",\r\n    title: \"string\",\r\n    url: \"url\"\r\n  },\r\n  signals: {\r\n    /* // TODO\r\n    loadingChanged: [\r\n      { type: \"WebViewLoadRequest\", name: \"loadRequest\" }\r\n    ]\r\n    */\r\n  }\r\n}, class {\r\n  constructor(meta) {\r\n    QmlWeb.callSuper(this, meta);\r\n\r\n    this.urlChanged.connect(this, this.$onUrlChanged);\r\n\r\n    const iframe = this.impl = document.createElement(\"iframe\");\r\n    iframe.style.display = \"block\";\r\n    iframe.style.position = \"absolute\";\r\n    iframe.style.width = \"100%\";\r\n    iframe.style.height = \"100%\";\r\n    iframe.style.borderWidth = \"0\";\r\n    iframe.style.pointerEvents = \"auto\";\r\n    this.dom.appendChild(iframe);\r\n\r\n    iframe.onload = () => {\r\n      try {\r\n        this.title = iframe.contentDocument.title;\r\n      } catch (e) {\r\n        console.log(`CSP prevents us from reading title for ${this.url}`);\r\n        this.title = \"\";\r\n      }\r\n      this.loadProgress = 100;\r\n      this.loading = false;\r\n    };\r\n    iframe.onerror = () => {\r\n      this.title = \"\";\r\n      this.loadProgress = 0;\r\n      this.loading = false;\r\n    };\r\n  }\r\n  $onUrlChanged(newVal) {\r\n    this.loadProgress = 0;\r\n    this.loading = true;\r\n    this.impl.src = newVal;\r\n  }\r\n});\r\n"]}